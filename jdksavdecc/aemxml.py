# ./aemxml.py
# -*- coding: utf-8 -*-
# PyXB bindings for NM:d9e752f864ba64a51addc078e127048bafddaaec
# Generated 2013-11-01 07:58:24.509354 by PyXB version 1.2.3
# Namespace http://grouper.ieee.org/groups/1722/1/contributions/xml

import pyxb
import pyxb.binding
import pyxb.binding.saxer
import io
import pyxb.utils.utility
import pyxb.utils.domutils
import sys

# Unique identifier for bindings created at the same time
_GenerationUID = pyxb.utils.utility.UniqueIdentifier('urn:uuid:0e48ba33-4306-11e3-bae9-b8f6b115dcd5')

# Version of PyXB used to generate the bindings
_PyXBVersion = '1.2.3'
# Generated bindings are not compatible across PyXB versions
if pyxb.__version__ != _PyXBVersion:
    raise pyxb.PyXBVersionError(_PyXBVersion)

# Import bindings for namespaces imported into schema
import pyxb.binding.datatypes

# NOTE: All namespace declarations are reserved within the binding
Namespace = pyxb.namespace.NamespaceForURI(u'http://grouper.ieee.org/groups/1722/1/contributions/xml', create_if_missing=True)
Namespace.configureCategories(['typeBinding', 'elementBinding'])

def CreateFromDocument (xml_text, default_namespace=None, location_base=None):
    """Parse the given XML and use the document element to create a
    Python instance.

    @param xml_text An XML document.  This should be data (Python 2
    str or Python 3 bytes), or a text (Python 2 unicode or Python 3
    str) in the L{pyxb._InputEncoding} encoding.

    @keyword default_namespace The L{pyxb.Namespace} instance to use as the
    default namespace where there is no default namespace in scope.
    If unspecified or C{None}, the namespace of the module containing
    this function will be used.

    @keyword location_base: An object to be recorded as the base of all
    L{pyxb.utils.utility.Location} instances associated with events and
    objects handled by the parser.  You might pass the URI from which
    the document was obtained.
    """

    if pyxb.XMLStyle_saxer != pyxb._XMLStyle:
        dom = pyxb.utils.domutils.StringToDOM(xml_text)
        return CreateFromDOM(dom.documentElement)
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    saxer = pyxb.binding.saxer.make_parser(fallback_namespace=default_namespace, location_base=location_base)
    handler = saxer.getContentHandler()
    xmld = xml_text
    if isinstance(xmld, unicode):
        xmld = xmld.encode(pyxb._InputEncoding)
    saxer.parse(io.BytesIO(xmld))
    instance = handler.rootObject()
    return instance

def CreateFromDOM (node, default_namespace=None):
    """Create a Python instance from the given DOM node.
    The node tag must correspond to an element declaration in this module.

    @deprecated: Forcing use of DOM interface is unnecessary; use L{CreateFromDocument}."""
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    return pyxb.binding.basis.element.AnyCreateFromDOM(node, default_namespace)


# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}Float
class Float (pyxb.binding.datatypes.float):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Float')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1656, 4)
    _Documentation = None
Float._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'Float', Float)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}Double
class Double (pyxb.binding.datatypes.double):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Double')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1659, 4)
    _Documentation = None
Double._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'Double', Double)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}AVDECCString
class AVDECCString (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AVDECCString')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1662, 4)
    _Documentation = None
AVDECCString._CF_maxLength = pyxb.binding.facets.CF_maxLength(value=pyxb.binding.datatypes.nonNegativeInteger(64L))
AVDECCString._InitializeFacetMap(AVDECCString._CF_maxLength)
Namespace.addCategoryObject('typeBinding', u'AVDECCString', AVDECCString)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}ControlValueString
class ControlValueString (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ControlValueString')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1667, 4)
    _Documentation = None
ControlValueString._CF_maxLength = pyxb.binding.facets.CF_maxLength(value=pyxb.binding.datatypes.nonNegativeInteger(406L))
ControlValueString._InitializeFacetMap(ControlValueString._CF_maxLength)
Namespace.addCategoryObject('typeBinding', u'ControlValueString', ControlValueString)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}HexBlobData
class HexBlobData (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'HexBlobData')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1672, 4)
    _Documentation = None
HexBlobData._CF_pattern = pyxb.binding.facets.CF_pattern()
HexBlobData._CF_pattern.addPattern(pattern=u'([\\t\\r\\n ]*[0-9a-f][0-9a-f][\\t\\r\\n ]*)*')
HexBlobData._InitializeFacetMap(HexBlobData._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'HexBlobData', HexBlobData)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}HexData
class HexData (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'HexData')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1677, 4)
    _Documentation = None
HexData._CF_pattern = pyxb.binding.facets.CF_pattern()
HexData._CF_pattern.addPattern(pattern=u'[0-9a-f]*')
HexData._InitializeFacetMap(HexData._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'HexData', HexData)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}Units
class Units (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Units')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1682, 4)
    _Documentation = None
Units._CF_pattern = pyxb.binding.facets.CF_pattern()
Units._CF_pattern.addPattern(pattern=u'[0-9a-f]{4}')
Units._InitializeFacetMap(Units._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'Units', Units)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}EUI64
class EUI64 (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EUI64')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1687, 4)
    _Documentation = None
EUI64._CF_pattern = pyxb.binding.facets.CF_pattern()
EUI64._CF_pattern.addPattern(pattern=u'[0-9a-f]{16}')
EUI64._InitializeFacetMap(EUI64._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'EUI64', EUI64)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}EUI48
class EUI48 (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EUI48')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1692, 4)
    _Documentation = None
EUI48._CF_pattern = pyxb.binding.facets.CF_pattern()
EUI48._CF_pattern.addPattern(pattern=u'[0-9a-f]{12}')
EUI48._InitializeFacetMap(EUI48._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'EUI48', EUI48)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}MAC
class MAC (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MAC')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1697, 4)
    _Documentation = None
MAC._CF_pattern = pyxb.binding.facets.CF_pattern()
MAC._CF_pattern.addPattern(pattern=u'[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}')
MAC._InitializeFacetMap(MAC._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'MAC', MAC)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}Octet
class Octet (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Octet')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1702, 4)
    _Documentation = None
Octet._CF_pattern = pyxb.binding.facets.CF_pattern()
Octet._CF_pattern.addPattern(pattern=u'[0-9a-f]{2}')
Octet._InitializeFacetMap(Octet._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'Octet', Octet)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}Doublet
class Doublet (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Doublet')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1707, 4)
    _Documentation = None
Doublet._CF_pattern = pyxb.binding.facets.CF_pattern()
Doublet._CF_pattern.addPattern(pattern=u'[0-9a-f]{4}')
Doublet._InitializeFacetMap(Doublet._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'Doublet', Doublet)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}Quadlet
class Quadlet (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Quadlet')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1712, 4)
    _Documentation = None
Quadlet._CF_pattern = pyxb.binding.facets.CF_pattern()
Quadlet._CF_pattern.addPattern(pattern=u'[0-9a-f]{8}')
Quadlet._InitializeFacetMap(Quadlet._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'Quadlet', Quadlet)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}Octlet
class Octlet (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Octlet')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1717, 4)
    _Documentation = None
Octlet._CF_pattern = pyxb.binding.facets.CF_pattern()
Octlet._CF_pattern.addPattern(pattern=u'[0-9a-f]{16}')
Octlet._InitializeFacetMap(Octlet._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'Octlet', Octlet)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}GPTPSeconds
class GPTPSeconds (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GPTPSeconds')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1722, 4)
    _Documentation = None
GPTPSeconds._CF_pattern = pyxb.binding.facets.CF_pattern()
GPTPSeconds._CF_pattern.addPattern(pattern=u'[0-9a-f]{12}')
GPTPSeconds._InitializeFacetMap(GPTPSeconds._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'GPTPSeconds', GPTPSeconds)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}GPTPNanoseconds
class GPTPNanoseconds (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'GPTPNanoseconds')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1727, 4)
    _Documentation = None
GPTPNanoseconds._CF_pattern = pyxb.binding.facets.CF_pattern()
GPTPNanoseconds._CF_pattern.addPattern(pattern=u'[0-9a-f]{8}')
GPTPNanoseconds._InitializeFacetMap(GPTPNanoseconds._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'GPTPNanoseconds', GPTPNanoseconds)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}DescriptorType
class DescriptorType (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DescriptorType')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1732, 4)
    _Documentation = None
DescriptorType._CF_pattern = pyxb.binding.facets.CF_pattern()
DescriptorType._CF_pattern.addPattern(pattern=u'[0-9a-f]{4}')
DescriptorType._InitializeFacetMap(DescriptorType._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'DescriptorType', DescriptorType)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}DescriptorIndex
class DescriptorIndex (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DescriptorIndex')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1737, 4)
    _Documentation = None
DescriptorIndex._CF_pattern = pyxb.binding.facets.CF_pattern()
DescriptorIndex._CF_pattern.addPattern(pattern=u'[0-9a-f]{4}')
DescriptorIndex._InitializeFacetMap(DescriptorIndex._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'DescriptorIndex', DescriptorIndex)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}StreamFormat
class StreamFormat (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'StreamFormat')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1742, 4)
    _Documentation = None
StreamFormat._CF_pattern = pyxb.binding.facets.CF_pattern()
StreamFormat._CF_pattern.addPattern(pattern=u'[0-9a-f]{16}')
StreamFormat._InitializeFacetMap(StreamFormat._CF_pattern)
Namespace.addCategoryObject('typeBinding', u'StreamFormat', StreamFormat)

# Atomic simple type: {http://grouper.ieee.org/groups/1722/1/contributions/xml}ColorSpace
class ColorSpace (Doublet):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ColorSpace')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1747, 4)
    _Documentation = None
ColorSpace._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', u'ColorSpace', ColorSpace)

# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}EntityV1 with content type ELEMENT_ONLY
class EntityV1 (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.1"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'EntityV1')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 22, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}entity_id uses Python identifier entity_id
    __entity_id = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'entity_id'), 'entity_id', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlentity_id', False, pyxb.utils.utility.Location('avdecc.xsd', 27, 12), )

    
    entity_id = property(__entity_id.value, __entity_id.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}entity_model_id uses Python identifier entity_model_id
    __entity_model_id = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'entity_model_id'), 'entity_model_id', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlentity_model_id', False, pyxb.utils.utility.Location('avdecc.xsd', 28, 12), )

    
    entity_model_id = property(__entity_model_id.value, __entity_model_id.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}entity_capabilities uses Python identifier entity_capabilities
    __entity_capabilities = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'entity_capabilities'), 'entity_capabilities', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlentity_capabilities', False, pyxb.utils.utility.Location('avdecc.xsd', 29, 12), )

    
    entity_capabilities = property(__entity_capabilities.value, __entity_capabilities.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}talker_stream_sources uses Python identifier talker_stream_sources
    __talker_stream_sources = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'talker_stream_sources'), 'talker_stream_sources', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmltalker_stream_sources', False, pyxb.utils.utility.Location('avdecc.xsd', 30, 12), )

    
    talker_stream_sources = property(__talker_stream_sources.value, __talker_stream_sources.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}talker_capabilties uses Python identifier talker_capabilties
    __talker_capabilties = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'talker_capabilties'), 'talker_capabilties', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmltalker_capabilties', False, pyxb.utils.utility.Location('avdecc.xsd', 31, 12), )

    
    talker_capabilties = property(__talker_capabilties.value, __talker_capabilties.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}listener_stream_sinks uses Python identifier listener_stream_sinks
    __listener_stream_sinks = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'listener_stream_sinks'), 'listener_stream_sinks', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmllistener_stream_sinks', False, pyxb.utils.utility.Location('avdecc.xsd', 32, 12), )

    
    listener_stream_sinks = property(__listener_stream_sinks.value, __listener_stream_sinks.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}listener_capabilities uses Python identifier listener_capabilities
    __listener_capabilities = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'listener_capabilities'), 'listener_capabilities', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmllistener_capabilities', False, pyxb.utils.utility.Location('avdecc.xsd', 33, 12), )

    
    listener_capabilities = property(__listener_capabilities.value, __listener_capabilities.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controller_capabilities uses Python identifier controller_capabilities
    __controller_capabilities = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controller_capabilities'), 'controller_capabilities', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlcontroller_capabilities', False, pyxb.utils.utility.Location('avdecc.xsd', 34, 12), )

    
    controller_capabilities = property(__controller_capabilities.value, __controller_capabilities.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}association_id uses Python identifier association_id
    __association_id = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'association_id'), 'association_id', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlassociation_id', False, pyxb.utils.utility.Location('avdecc.xsd', 35, 12), )

    
    association_id = property(__association_id.value, __association_id.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}entity_name uses Python identifier entity_name
    __entity_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'entity_name'), 'entity_name', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlentity_name', False, pyxb.utils.utility.Location('avdecc.xsd', 36, 12), )

    
    entity_name = property(__entity_name.value, __entity_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}vendor_name uses Python identifier vendor_name
    __vendor_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'vendor_name'), 'vendor_name', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlvendor_name', False, pyxb.utils.utility.Location('avdecc.xsd', 37, 12), )

    
    vendor_name = property(__vendor_name.value, __vendor_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}model_name uses Python identifier model_name
    __model_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'model_name'), 'model_name', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlmodel_name', False, pyxb.utils.utility.Location('avdecc.xsd', 38, 12), )

    
    model_name = property(__model_name.value, __model_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}firmware_version uses Python identifier firmware_version
    __firmware_version = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'firmware_version'), 'firmware_version', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlfirmware_version', False, pyxb.utils.utility.Location('avdecc.xsd', 39, 12), )

    
    firmware_version = property(__firmware_version.value, __firmware_version.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}group_name uses Python identifier group_name
    __group_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'group_name'), 'group_name', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlgroup_name', False, pyxb.utils.utility.Location('avdecc.xsd', 40, 12), )

    
    group_name = property(__group_name.value, __group_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}serial_number uses Python identifier serial_number
    __serial_number = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'serial_number'), 'serial_number', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlserial_number', False, pyxb.utils.utility.Location('avdecc.xsd', 41, 12), )

    
    serial_number = property(__serial_number.value, __serial_number.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_configuration uses Python identifier current_configuration
    __current_configuration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_configuration'), 'current_configuration', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_configuration', False, pyxb.utils.utility.Location('avdecc.xsd', 42, 12), )

    
    current_configuration = property(__current_configuration.value, __current_configuration.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}configurations uses Python identifier configurations
    __configurations = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'configurations'), 'configurations', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_httpgrouper_ieee_orggroups17221contributionsxmlconfigurations', False, pyxb.utils.utility.Location('avdecc.xsd', 43, 12), )

    
    configurations = property(__configurations.value, __configurations.set, None, None)

    
    # Attribute version uses Python identifier version
    __version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'version'), 'version', '__httpgrouper_ieee_orggroups17221contributionsxml_EntityV1_version', pyxb.binding.datatypes.string, required=True)
    __version._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 45, 8)
    __version._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 45, 8)
    
    version = property(__version.value, __version.set, None, None)

    _ElementMap.update({
        __entity_id.name() : __entity_id,
        __entity_model_id.name() : __entity_model_id,
        __entity_capabilities.name() : __entity_capabilities,
        __talker_stream_sources.name() : __talker_stream_sources,
        __talker_capabilties.name() : __talker_capabilties,
        __listener_stream_sinks.name() : __listener_stream_sinks,
        __listener_capabilities.name() : __listener_capabilities,
        __controller_capabilities.name() : __controller_capabilities,
        __association_id.name() : __association_id,
        __entity_name.name() : __entity_name,
        __vendor_name.name() : __vendor_name,
        __model_name.name() : __model_name,
        __firmware_version.name() : __firmware_version,
        __group_name.name() : __group_name,
        __serial_number.name() : __serial_number,
        __current_configuration.name() : __current_configuration,
        __configurations.name() : __configurations
    })
    _AttributeMap.update({
        __version.name() : __version
    })
Namespace.addCategoryObject('typeBinding', u'EntityV1', EntityV1)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ConfigurationDescriptors with content type ELEMENT_ONLY
class ConfigurationDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ConfigurationDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConfigurationDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 48, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}configuration uses Python identifier configuration
    __configuration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'configuration'), 'configuration', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlconfiguration', True, pyxb.utils.utility.Location('avdecc.xsd', 50, 12), )

    
    configuration = property(__configuration.value, __configuration.set, None, None)

    _ElementMap.update({
        __configuration.name() : __configuration
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ConfigurationDescriptors', ConfigurationDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ConfigurationDescriptor with content type ELEMENT_ONLY
class ConfigurationDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.2"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ConfigurationDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 53, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 58, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 59, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}audio_units uses Python identifier audio_units
    __audio_units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'audio_units'), 'audio_units', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlaudio_units', False, pyxb.utils.utility.Location('avdecc.xsd', 60, 12), )

    
    audio_units = property(__audio_units.value, __audio_units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}video_units uses Python identifier video_units
    __video_units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'video_units'), 'video_units', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlvideo_units', False, pyxb.utils.utility.Location('avdecc.xsd', 61, 12), )

    
    video_units = property(__video_units.value, __video_units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sensor_units uses Python identifier sensor_units
    __sensor_units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sensor_units'), 'sensor_units', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsensor_units', False, pyxb.utils.utility.Location('avdecc.xsd', 62, 12), )

    
    sensor_units = property(__sensor_units.value, __sensor_units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_streams uses Python identifier input_streams
    __input_streams = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_streams'), 'input_streams', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinput_streams', False, pyxb.utils.utility.Location('avdecc.xsd', 63, 12), )

    
    input_streams = property(__input_streams.value, __input_streams.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_streams uses Python identifier output_streams
    __output_streams = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_streams'), 'output_streams', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloutput_streams', False, pyxb.utils.utility.Location('avdecc.xsd', 64, 12), )

    
    output_streams = property(__output_streams.value, __output_streams.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_jacks uses Python identifier input_jacks
    __input_jacks = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_jacks'), 'input_jacks', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinput_jacks', False, pyxb.utils.utility.Location('avdecc.xsd', 65, 12), )

    
    input_jacks = property(__input_jacks.value, __input_jacks.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_jacks uses Python identifier output_jacks
    __output_jacks = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_jacks'), 'output_jacks', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloutput_jacks', False, pyxb.utils.utility.Location('avdecc.xsd', 66, 12), )

    
    output_jacks = property(__output_jacks.value, __output_jacks.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}avb_interfaces uses Python identifier avb_interfaces
    __avb_interfaces = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'avb_interfaces'), 'avb_interfaces', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlavb_interfaces', False, pyxb.utils.utility.Location('avdecc.xsd', 67, 12), )

    
    avb_interfaces = property(__avb_interfaces.value, __avb_interfaces.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_sources uses Python identifier clock_sources
    __clock_sources = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_sources'), 'clock_sources', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_sources', False, pyxb.utils.utility.Location('avdecc.xsd', 68, 12), )

    
    clock_sources = property(__clock_sources.value, __clock_sources.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controls uses Python identifier controls
    __controls = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controls'), 'controls', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrols', False, pyxb.utils.utility.Location('avdecc.xsd', 69, 12), )

    
    controls = property(__controls.value, __controls.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_selectors uses Python identifier signal_selectors
    __signal_selectors = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors'), 'signal_selectors', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_selectors', False, pyxb.utils.utility.Location('avdecc.xsd', 70, 12), )

    
    signal_selectors = property(__signal_selectors.value, __signal_selectors.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}mixers uses Python identifier mixers
    __mixers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'mixers'), 'mixers', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmixers', False, pyxb.utils.utility.Location('avdecc.xsd', 71, 12), )

    
    mixers = property(__mixers.value, __mixers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}matrices uses Python identifier matrices
    __matrices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'matrices'), 'matrices', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmatrices', False, pyxb.utils.utility.Location('avdecc.xsd', 72, 12), )

    
    matrices = property(__matrices.value, __matrices.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}locales uses Python identifier locales
    __locales = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'locales'), 'locales', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocales', False, pyxb.utils.utility.Location('avdecc.xsd', 73, 12), )

    
    locales = property(__locales.value, __locales.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}splitters uses Python identifier splitters
    __splitters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'splitters'), 'splitters', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsplitters', False, pyxb.utils.utility.Location('avdecc.xsd', 74, 12), )

    
    splitters = property(__splitters.value, __splitters.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}combiners uses Python identifier combiners
    __combiners = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'combiners'), 'combiners', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcombiners', False, pyxb.utils.utility.Location('avdecc.xsd', 75, 12), )

    
    combiners = property(__combiners.value, __combiners.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}demultiplexers uses Python identifier demultiplexers
    __demultiplexers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers'), 'demultiplexers', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmldemultiplexers', False, pyxb.utils.utility.Location('avdecc.xsd', 76, 12), )

    
    demultiplexers = property(__demultiplexers.value, __demultiplexers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}multiplexers uses Python identifier multiplexers
    __multiplexers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'multiplexers'), 'multiplexers', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmultiplexers', False, pyxb.utils.utility.Location('avdecc.xsd', 77, 12), )

    
    multiplexers = property(__multiplexers.value, __multiplexers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}transcoders uses Python identifier transcoders
    __transcoders = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'transcoders'), 'transcoders', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmltranscoders', False, pyxb.utils.utility.Location('avdecc.xsd', 78, 12), )

    
    transcoders = property(__transcoders.value, __transcoders.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}memory_objects uses Python identifier memory_objects
    __memory_objects = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'memory_objects'), 'memory_objects', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmemory_objects', False, pyxb.utils.utility.Location('avdecc.xsd', 79, 12), )

    
    memory_objects = property(__memory_objects.value, __memory_objects.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_domains uses Python identifier clock_domains
    __clock_domains = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_domains'), 'clock_domains', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_domains', False, pyxb.utils.utility.Location('avdecc.xsd', 80, 12), )

    
    clock_domains = property(__clock_domains.value, __clock_domains.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_blocks uses Python identifier control_blocks
    __control_blocks = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_blocks'), 'control_blocks', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_blocks', False, pyxb.utils.utility.Location('avdecc.xsd', 81, 12), )

    
    control_blocks = property(__control_blocks.value, __control_blocks.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_ConfigurationDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 83, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 83, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __audio_units.name() : __audio_units,
        __video_units.name() : __video_units,
        __sensor_units.name() : __sensor_units,
        __input_streams.name() : __input_streams,
        __output_streams.name() : __output_streams,
        __input_jacks.name() : __input_jacks,
        __output_jacks.name() : __output_jacks,
        __avb_interfaces.name() : __avb_interfaces,
        __clock_sources.name() : __clock_sources,
        __controls.name() : __controls,
        __signal_selectors.name() : __signal_selectors,
        __mixers.name() : __mixers,
        __matrices.name() : __matrices,
        __locales.name() : __locales,
        __splitters.name() : __splitters,
        __combiners.name() : __combiners,
        __demultiplexers.name() : __demultiplexers,
        __multiplexers.name() : __multiplexers,
        __transcoders.name() : __transcoders,
        __memory_objects.name() : __memory_objects,
        __clock_domains.name() : __clock_domains,
        __control_blocks.name() : __control_blocks
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'ConfigurationDescriptor', ConfigurationDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioUnitDescriptors with content type ELEMENT_ONLY
class AudioUnitDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioUnitDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AudioUnitDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 86, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}audio_unit uses Python identifier audio_unit
    __audio_unit = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'audio_unit'), 'audio_unit', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlaudio_unit', True, pyxb.utils.utility.Location('avdecc.xsd', 88, 12), )

    
    audio_unit = property(__audio_unit.value, __audio_unit.set, None, None)

    _ElementMap.update({
        __audio_unit.name() : __audio_unit
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AudioUnitDescriptors', AudioUnitDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioUnitDescriptor with content type ELEMENT_ONLY
class AudioUnitDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.3"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AudioUnitDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 91, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 96, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 97, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_domain_index uses Python identifier clock_domain_index
    __clock_domain_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), 'clock_domain_index', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_domain_index', False, pyxb.utils.utility.Location('avdecc.xsd', 98, 12), )

    
    clock_domain_index = property(__clock_domain_index.value, __clock_domain_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_stream_ports uses Python identifier input_stream_ports
    __input_stream_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_stream_ports'), 'input_stream_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinput_stream_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 99, 12), )

    
    input_stream_ports = property(__input_stream_ports.value, __input_stream_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_stream_ports uses Python identifier output_stream_ports
    __output_stream_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_stream_ports'), 'output_stream_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloutput_stream_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 100, 12), )

    
    output_stream_ports = property(__output_stream_ports.value, __output_stream_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_external_ports uses Python identifier input_external_ports
    __input_external_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_external_ports'), 'input_external_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinput_external_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 101, 12), )

    
    input_external_ports = property(__input_external_ports.value, __input_external_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_external_ports uses Python identifier output_external_ports
    __output_external_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_external_ports'), 'output_external_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloutput_external_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 102, 12), )

    
    output_external_ports = property(__output_external_ports.value, __output_external_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_internal_ports uses Python identifier input_internal_ports
    __input_internal_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_internal_ports'), 'input_internal_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinput_internal_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 103, 12), )

    
    input_internal_ports = property(__input_internal_ports.value, __input_internal_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_internal_ports uses Python identifier output_internal_ports
    __output_internal_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_internal_ports'), 'output_internal_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloutput_internal_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 104, 12), )

    
    output_internal_ports = property(__output_internal_ports.value, __output_internal_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controls uses Python identifier controls
    __controls = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controls'), 'controls', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrols', False, pyxb.utils.utility.Location('avdecc.xsd', 105, 12), )

    
    controls = property(__controls.value, __controls.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_selectors uses Python identifier signal_selectors
    __signal_selectors = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors'), 'signal_selectors', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_selectors', False, pyxb.utils.utility.Location('avdecc.xsd', 106, 12), )

    
    signal_selectors = property(__signal_selectors.value, __signal_selectors.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}mixers uses Python identifier mixers
    __mixers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'mixers'), 'mixers', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmixers', False, pyxb.utils.utility.Location('avdecc.xsd', 107, 12), )

    
    mixers = property(__mixers.value, __mixers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}matrices uses Python identifier matrices
    __matrices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'matrices'), 'matrices', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmatrices', False, pyxb.utils.utility.Location('avdecc.xsd', 108, 12), )

    
    matrices = property(__matrices.value, __matrices.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}splitters uses Python identifier splitters
    __splitters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'splitters'), 'splitters', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsplitters', False, pyxb.utils.utility.Location('avdecc.xsd', 109, 12), )

    
    splitters = property(__splitters.value, __splitters.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}combiners uses Python identifier combiners
    __combiners = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'combiners'), 'combiners', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcombiners', False, pyxb.utils.utility.Location('avdecc.xsd', 110, 12), )

    
    combiners = property(__combiners.value, __combiners.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}demultiplexers uses Python identifier demultiplexers
    __demultiplexers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers'), 'demultiplexers', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmldemultiplexers', False, pyxb.utils.utility.Location('avdecc.xsd', 111, 12), )

    
    demultiplexers = property(__demultiplexers.value, __demultiplexers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}multiplexers uses Python identifier multiplexers
    __multiplexers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'multiplexers'), 'multiplexers', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmultiplexers', False, pyxb.utils.utility.Location('avdecc.xsd', 112, 12), )

    
    multiplexers = property(__multiplexers.value, __multiplexers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}transcoders uses Python identifier transcoders
    __transcoders = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'transcoders'), 'transcoders', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmltranscoders', False, pyxb.utils.utility.Location('avdecc.xsd', 113, 12), )

    
    transcoders = property(__transcoders.value, __transcoders.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_blocks uses Python identifier control_blocks
    __control_blocks = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_blocks'), 'control_blocks', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_blocks', False, pyxb.utils.utility.Location('avdecc.xsd', 114, 12), )

    
    control_blocks = property(__control_blocks.value, __control_blocks.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_sampling_rate uses Python identifier current_sampling_rate
    __current_sampling_rate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_sampling_rate'), 'current_sampling_rate', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_sampling_rate', False, pyxb.utils.utility.Location('avdecc.xsd', 115, 12), )

    
    current_sampling_rate = property(__current_sampling_rate.value, __current_sampling_rate.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sampling_rates uses Python identifier sampling_rates
    __sampling_rates = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sampling_rates'), 'sampling_rates', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsampling_rates', False, pyxb.utils.utility.Location('avdecc.xsd', 116, 12), )

    
    sampling_rates = property(__sampling_rates.value, __sampling_rates.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioUnitDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 118, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 118, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __clock_domain_index.name() : __clock_domain_index,
        __input_stream_ports.name() : __input_stream_ports,
        __output_stream_ports.name() : __output_stream_ports,
        __input_external_ports.name() : __input_external_ports,
        __output_external_ports.name() : __output_external_ports,
        __input_internal_ports.name() : __input_internal_ports,
        __output_internal_ports.name() : __output_internal_ports,
        __controls.name() : __controls,
        __signal_selectors.name() : __signal_selectors,
        __mixers.name() : __mixers,
        __matrices.name() : __matrices,
        __splitters.name() : __splitters,
        __combiners.name() : __combiners,
        __demultiplexers.name() : __demultiplexers,
        __multiplexers.name() : __multiplexers,
        __transcoders.name() : __transcoders,
        __control_blocks.name() : __control_blocks,
        __current_sampling_rate.name() : __current_sampling_rate,
        __sampling_rates.name() : __sampling_rates
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'AudioUnitDescriptor', AudioUnitDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoUnitDescriptors with content type ELEMENT_ONLY
class VideoUnitDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoUnitDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoUnitDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 121, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}video_unit uses Python identifier video_unit
    __video_unit = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'video_unit'), 'video_unit', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlvideo_unit', True, pyxb.utils.utility.Location('avdecc.xsd', 123, 12), )

    
    video_unit = property(__video_unit.value, __video_unit.set, None, None)

    _ElementMap.update({
        __video_unit.name() : __video_unit
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VideoUnitDescriptors', VideoUnitDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoUnitDescriptor with content type ELEMENT_ONLY
class VideoUnitDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.4"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoUnitDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 126, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 131, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 132, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_domain_index uses Python identifier clock_domain_index
    __clock_domain_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), 'clock_domain_index', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_domain_index', False, pyxb.utils.utility.Location('avdecc.xsd', 133, 12), )

    
    clock_domain_index = property(__clock_domain_index.value, __clock_domain_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_stream_ports uses Python identifier input_stream_ports
    __input_stream_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_stream_ports'), 'input_stream_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinput_stream_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 134, 12), )

    
    input_stream_ports = property(__input_stream_ports.value, __input_stream_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_stream_ports uses Python identifier output_stream_ports
    __output_stream_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_stream_ports'), 'output_stream_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloutput_stream_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 135, 12), )

    
    output_stream_ports = property(__output_stream_ports.value, __output_stream_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_external_ports uses Python identifier input_external_ports
    __input_external_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_external_ports'), 'input_external_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinput_external_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 136, 12), )

    
    input_external_ports = property(__input_external_ports.value, __input_external_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_external_ports uses Python identifier output_external_ports
    __output_external_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_external_ports'), 'output_external_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloutput_external_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 137, 12), )

    
    output_external_ports = property(__output_external_ports.value, __output_external_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_internal_ports uses Python identifier input_internal_ports
    __input_internal_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_internal_ports'), 'input_internal_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinput_internal_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 138, 12), )

    
    input_internal_ports = property(__input_internal_ports.value, __input_internal_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_internal_ports uses Python identifier output_internal_ports
    __output_internal_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_internal_ports'), 'output_internal_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloutput_internal_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 139, 12), )

    
    output_internal_ports = property(__output_internal_ports.value, __output_internal_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controls uses Python identifier controls
    __controls = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controls'), 'controls', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrols', False, pyxb.utils.utility.Location('avdecc.xsd', 140, 12), )

    
    controls = property(__controls.value, __controls.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_selectors uses Python identifier signal_selectors
    __signal_selectors = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors'), 'signal_selectors', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_selectors', False, pyxb.utils.utility.Location('avdecc.xsd', 141, 12), )

    
    signal_selectors = property(__signal_selectors.value, __signal_selectors.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}mixers uses Python identifier mixers
    __mixers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'mixers'), 'mixers', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmixers', False, pyxb.utils.utility.Location('avdecc.xsd', 142, 12), )

    
    mixers = property(__mixers.value, __mixers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}matrices uses Python identifier matrices
    __matrices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'matrices'), 'matrices', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmatrices', False, pyxb.utils.utility.Location('avdecc.xsd', 143, 12), )

    
    matrices = property(__matrices.value, __matrices.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}splitters uses Python identifier splitters
    __splitters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'splitters'), 'splitters', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsplitters', False, pyxb.utils.utility.Location('avdecc.xsd', 144, 12), )

    
    splitters = property(__splitters.value, __splitters.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}combiners uses Python identifier combiners
    __combiners = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'combiners'), 'combiners', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcombiners', False, pyxb.utils.utility.Location('avdecc.xsd', 145, 12), )

    
    combiners = property(__combiners.value, __combiners.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}demultiplexers uses Python identifier demultiplexers
    __demultiplexers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers'), 'demultiplexers', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmldemultiplexers', False, pyxb.utils.utility.Location('avdecc.xsd', 146, 12), )

    
    demultiplexers = property(__demultiplexers.value, __demultiplexers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}multiplexers uses Python identifier multiplexers
    __multiplexers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'multiplexers'), 'multiplexers', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmultiplexers', False, pyxb.utils.utility.Location('avdecc.xsd', 147, 12), )

    
    multiplexers = property(__multiplexers.value, __multiplexers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}transcoders uses Python identifier transcoders
    __transcoders = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'transcoders'), 'transcoders', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmltranscoders', False, pyxb.utils.utility.Location('avdecc.xsd', 148, 12), )

    
    transcoders = property(__transcoders.value, __transcoders.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_blocks uses Python identifier control_blocks
    __control_blocks = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_blocks'), 'control_blocks', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_blocks', False, pyxb.utils.utility.Location('avdecc.xsd', 149, 12), )

    
    control_blocks = property(__control_blocks.value, __control_blocks.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoUnitDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 151, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 151, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __clock_domain_index.name() : __clock_domain_index,
        __input_stream_ports.name() : __input_stream_ports,
        __output_stream_ports.name() : __output_stream_ports,
        __input_external_ports.name() : __input_external_ports,
        __output_external_ports.name() : __output_external_ports,
        __input_internal_ports.name() : __input_internal_ports,
        __output_internal_ports.name() : __output_internal_ports,
        __controls.name() : __controls,
        __signal_selectors.name() : __signal_selectors,
        __mixers.name() : __mixers,
        __matrices.name() : __matrices,
        __splitters.name() : __splitters,
        __combiners.name() : __combiners,
        __demultiplexers.name() : __demultiplexers,
        __multiplexers.name() : __multiplexers,
        __transcoders.name() : __transcoders,
        __control_blocks.name() : __control_blocks
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'VideoUnitDescriptor', VideoUnitDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorUnitDescriptors with content type ELEMENT_ONLY
class SensorUnitDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorUnitDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SensorUnitDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 154, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sensor_unit uses Python identifier sensor_unit
    __sensor_unit = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sensor_unit'), 'sensor_unit', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlsensor_unit', True, pyxb.utils.utility.Location('avdecc.xsd', 156, 12), )

    
    sensor_unit = property(__sensor_unit.value, __sensor_unit.set, None, None)

    _ElementMap.update({
        __sensor_unit.name() : __sensor_unit
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SensorUnitDescriptors', SensorUnitDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorUnitDescriptor with content type ELEMENT_ONLY
class SensorUnitDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.5"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SensorUnitDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 159, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 164, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 165, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_domain_index uses Python identifier clock_domain_index
    __clock_domain_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), 'clock_domain_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_domain_index', False, pyxb.utils.utility.Location('avdecc.xsd', 166, 12), )

    
    clock_domain_index = property(__clock_domain_index.value, __clock_domain_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_stream_ports uses Python identifier input_stream_ports
    __input_stream_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_stream_ports'), 'input_stream_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinput_stream_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 167, 12), )

    
    input_stream_ports = property(__input_stream_ports.value, __input_stream_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_stream_ports uses Python identifier output_stream_ports
    __output_stream_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_stream_ports'), 'output_stream_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloutput_stream_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 168, 12), )

    
    output_stream_ports = property(__output_stream_ports.value, __output_stream_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_external_ports uses Python identifier input_external_ports
    __input_external_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_external_ports'), 'input_external_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinput_external_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 169, 12), )

    
    input_external_ports = property(__input_external_ports.value, __input_external_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_external_ports uses Python identifier output_external_ports
    __output_external_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_external_ports'), 'output_external_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloutput_external_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 170, 12), )

    
    output_external_ports = property(__output_external_ports.value, __output_external_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_internal_ports uses Python identifier input_internal_ports
    __input_internal_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_internal_ports'), 'input_internal_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinput_internal_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 171, 12), )

    
    input_internal_ports = property(__input_internal_ports.value, __input_internal_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_internal_ports uses Python identifier output_internal_ports
    __output_internal_ports = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_internal_ports'), 'output_internal_ports', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloutput_internal_ports', False, pyxb.utils.utility.Location('avdecc.xsd', 172, 12), )

    
    output_internal_ports = property(__output_internal_ports.value, __output_internal_ports.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controls uses Python identifier controls
    __controls = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controls'), 'controls', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrols', False, pyxb.utils.utility.Location('avdecc.xsd', 173, 12), )

    
    controls = property(__controls.value, __controls.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_selectors uses Python identifier signal_selectors
    __signal_selectors = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors'), 'signal_selectors', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_selectors', False, pyxb.utils.utility.Location('avdecc.xsd', 174, 12), )

    
    signal_selectors = property(__signal_selectors.value, __signal_selectors.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}mixers uses Python identifier mixers
    __mixers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'mixers'), 'mixers', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmixers', False, pyxb.utils.utility.Location('avdecc.xsd', 175, 12), )

    
    mixers = property(__mixers.value, __mixers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}matrices uses Python identifier matrices
    __matrices = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'matrices'), 'matrices', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmatrices', False, pyxb.utils.utility.Location('avdecc.xsd', 176, 12), )

    
    matrices = property(__matrices.value, __matrices.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}splitters uses Python identifier splitters
    __splitters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'splitters'), 'splitters', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsplitters', False, pyxb.utils.utility.Location('avdecc.xsd', 177, 12), )

    
    splitters = property(__splitters.value, __splitters.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}combiners uses Python identifier combiners
    __combiners = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'combiners'), 'combiners', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcombiners', False, pyxb.utils.utility.Location('avdecc.xsd', 178, 12), )

    
    combiners = property(__combiners.value, __combiners.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}demultiplexers uses Python identifier demultiplexers
    __demultiplexers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers'), 'demultiplexers', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmldemultiplexers', False, pyxb.utils.utility.Location('avdecc.xsd', 179, 12), )

    
    demultiplexers = property(__demultiplexers.value, __demultiplexers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}multiplexers uses Python identifier multiplexers
    __multiplexers = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'multiplexers'), 'multiplexers', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmultiplexers', False, pyxb.utils.utility.Location('avdecc.xsd', 180, 12), )

    
    multiplexers = property(__multiplexers.value, __multiplexers.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}transcoders uses Python identifier transcoders
    __transcoders = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'transcoders'), 'transcoders', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmltranscoders', False, pyxb.utils.utility.Location('avdecc.xsd', 181, 12), )

    
    transcoders = property(__transcoders.value, __transcoders.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_blocks uses Python identifier control_blocks
    __control_blocks = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_blocks'), 'control_blocks', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_blocks', False, pyxb.utils.utility.Location('avdecc.xsd', 182, 12), )

    
    control_blocks = property(__control_blocks.value, __control_blocks.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorUnitDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 184, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 184, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __clock_domain_index.name() : __clock_domain_index,
        __input_stream_ports.name() : __input_stream_ports,
        __output_stream_ports.name() : __output_stream_ports,
        __input_external_ports.name() : __input_external_ports,
        __output_external_ports.name() : __output_external_ports,
        __input_internal_ports.name() : __input_internal_ports,
        __output_internal_ports.name() : __output_internal_ports,
        __controls.name() : __controls,
        __signal_selectors.name() : __signal_selectors,
        __mixers.name() : __mixers,
        __matrices.name() : __matrices,
        __splitters.name() : __splitters,
        __combiners.name() : __combiners,
        __demultiplexers.name() : __demultiplexers,
        __multiplexers.name() : __multiplexers,
        __transcoders.name() : __transcoders,
        __control_blocks.name() : __control_blocks
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'SensorUnitDescriptor', SensorUnitDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}StreamDescriptors with content type ELEMENT_ONLY
class StreamDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}StreamDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'StreamDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 187, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream uses Python identifier stream
    __stream = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream'), 'stream', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlstream', True, pyxb.utils.utility.Location('avdecc.xsd', 189, 12), )

    
    stream = property(__stream.value, __stream.set, None, None)

    _ElementMap.update({
        __stream.name() : __stream
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'StreamDescriptors', StreamDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}StreamDescriptor with content type ELEMENT_ONLY
class StreamDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.6"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'StreamDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 192, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 197, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 198, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_domain_index uses Python identifier clock_domain_index
    __clock_domain_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), 'clock_domain_index', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_domain_index', False, pyxb.utils.utility.Location('avdecc.xsd', 199, 12), )

    
    clock_domain_index = property(__clock_domain_index.value, __clock_domain_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream_flags uses Python identifier stream_flags
    __stream_flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream_flags'), 'stream_flags', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlstream_flags', False, pyxb.utils.utility.Location('avdecc.xsd', 200, 12), )

    
    stream_flags = property(__stream_flags.value, __stream_flags.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_stream_format uses Python identifier current_stream_format
    __current_stream_format = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_stream_format'), 'current_stream_format', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_stream_format', False, pyxb.utils.utility.Location('avdecc.xsd', 201, 12), )

    
    current_stream_format = property(__current_stream_format.value, __current_stream_format.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}backup_talker_entity_id0 uses Python identifier backup_talker_entity_id0
    __backup_talker_entity_id0 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_entity_id0'), 'backup_talker_entity_id0', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlbackup_talker_entity_id0', False, pyxb.utils.utility.Location('avdecc.xsd', 202, 12), )

    
    backup_talker_entity_id0 = property(__backup_talker_entity_id0.value, __backup_talker_entity_id0.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}backup_talker_uniqueid0 uses Python identifier backup_talker_uniqueid0
    __backup_talker_uniqueid0 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_uniqueid0'), 'backup_talker_uniqueid0', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlbackup_talker_uniqueid0', False, pyxb.utils.utility.Location('avdecc.xsd', 203, 12), )

    
    backup_talker_uniqueid0 = property(__backup_talker_uniqueid0.value, __backup_talker_uniqueid0.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}backup_talker_entity_id1 uses Python identifier backup_talker_entity_id1
    __backup_talker_entity_id1 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_entity_id1'), 'backup_talker_entity_id1', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlbackup_talker_entity_id1', False, pyxb.utils.utility.Location('avdecc.xsd', 204, 12), )

    
    backup_talker_entity_id1 = property(__backup_talker_entity_id1.value, __backup_talker_entity_id1.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}backup_talker_uniqueid1 uses Python identifier backup_talker_uniqueid1
    __backup_talker_uniqueid1 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_uniqueid1'), 'backup_talker_uniqueid1', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlbackup_talker_uniqueid1', False, pyxb.utils.utility.Location('avdecc.xsd', 205, 12), )

    
    backup_talker_uniqueid1 = property(__backup_talker_uniqueid1.value, __backup_talker_uniqueid1.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}backup_talker_entity_id2 uses Python identifier backup_talker_entity_id2
    __backup_talker_entity_id2 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_entity_id2'), 'backup_talker_entity_id2', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlbackup_talker_entity_id2', False, pyxb.utils.utility.Location('avdecc.xsd', 206, 12), )

    
    backup_talker_entity_id2 = property(__backup_talker_entity_id2.value, __backup_talker_entity_id2.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}backup_talker_uniqueid2 uses Python identifier backup_talker_uniqueid2
    __backup_talker_uniqueid2 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_uniqueid2'), 'backup_talker_uniqueid2', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlbackup_talker_uniqueid2', False, pyxb.utils.utility.Location('avdecc.xsd', 207, 12), )

    
    backup_talker_uniqueid2 = property(__backup_talker_uniqueid2.value, __backup_talker_uniqueid2.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}backed_up_talker_entity_id uses Python identifier backed_up_talker_entity_id
    __backed_up_talker_entity_id = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'backed_up_talker_entity_id'), 'backed_up_talker_entity_id', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlbacked_up_talker_entity_id', False, pyxb.utils.utility.Location('avdecc.xsd', 208, 12), )

    
    backed_up_talker_entity_id = property(__backed_up_talker_entity_id.value, __backed_up_talker_entity_id.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}backed_up_talker_uniqueid uses Python identifier backed_up_talker_uniqueid
    __backed_up_talker_uniqueid = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'backed_up_talker_uniqueid'), 'backed_up_talker_uniqueid', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlbacked_up_talker_uniqueid', False, pyxb.utils.utility.Location('avdecc.xsd', 209, 12), )

    
    backed_up_talker_uniqueid = property(__backed_up_talker_uniqueid.value, __backed_up_talker_uniqueid.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}avb_interface_index uses Python identifier avb_interface_index
    __avb_interface_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'avb_interface_index'), 'avb_interface_index', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlavb_interface_index', False, pyxb.utils.utility.Location('avdecc.xsd', 210, 12), )

    
    avb_interface_index = property(__avb_interface_index.value, __avb_interface_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}buffer_length uses Python identifier buffer_length
    __buffer_length = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'buffer_length'), 'buffer_length', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlbuffer_length', False, pyxb.utils.utility.Location('avdecc.xsd', 211, 12), )

    
    buffer_length = property(__buffer_length.value, __buffer_length.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream_formats uses Python identifier stream_formats
    __stream_formats = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream_formats'), 'stream_formats', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlstream_formats', False, pyxb.utils.utility.Location('avdecc.xsd', 212, 12), )

    
    stream_formats = property(__stream_formats.value, __stream_formats.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 214, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 214, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __clock_domain_index.name() : __clock_domain_index,
        __stream_flags.name() : __stream_flags,
        __current_stream_format.name() : __current_stream_format,
        __backup_talker_entity_id0.name() : __backup_talker_entity_id0,
        __backup_talker_uniqueid0.name() : __backup_talker_uniqueid0,
        __backup_talker_entity_id1.name() : __backup_talker_entity_id1,
        __backup_talker_uniqueid1.name() : __backup_talker_uniqueid1,
        __backup_talker_entity_id2.name() : __backup_talker_entity_id2,
        __backup_talker_uniqueid2.name() : __backup_talker_uniqueid2,
        __backed_up_talker_entity_id.name() : __backed_up_talker_entity_id,
        __backed_up_talker_uniqueid.name() : __backed_up_talker_uniqueid,
        __avb_interface_index.name() : __avb_interface_index,
        __buffer_length.name() : __buffer_length,
        __stream_formats.name() : __stream_formats
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'StreamDescriptor', StreamDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}JackDescriptors with content type ELEMENT_ONLY
class JackDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}JackDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'JackDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 217, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}jack uses Python identifier jack
    __jack = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'jack'), 'jack', '__httpgrouper_ieee_orggroups17221contributionsxml_JackDescriptors_httpgrouper_ieee_orggroups17221contributionsxmljack', True, pyxb.utils.utility.Location('avdecc.xsd', 219, 12), )

    
    jack = property(__jack.value, __jack.set, None, None)

    _ElementMap.update({
        __jack.name() : __jack
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'JackDescriptors', JackDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}JackDescriptor with content type ELEMENT_ONLY
class JackDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.7"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'JackDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 222, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_JackDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 227, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_JackDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 228, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}jack_flags uses Python identifier jack_flags
    __jack_flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'jack_flags'), 'jack_flags', '__httpgrouper_ieee_orggroups17221contributionsxml_JackDescriptor_httpgrouper_ieee_orggroups17221contributionsxmljack_flags', False, pyxb.utils.utility.Location('avdecc.xsd', 229, 12), )

    
    jack_flags = property(__jack_flags.value, __jack_flags.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}jack_type uses Python identifier jack_type
    __jack_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'jack_type'), 'jack_type', '__httpgrouper_ieee_orggroups17221contributionsxml_JackDescriptor_httpgrouper_ieee_orggroups17221contributionsxmljack_type', False, pyxb.utils.utility.Location('avdecc.xsd', 230, 12), )

    
    jack_type = property(__jack_type.value, __jack_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controls uses Python identifier controls
    __controls = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controls'), 'controls', '__httpgrouper_ieee_orggroups17221contributionsxml_JackDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrols', True, pyxb.utils.utility.Location('avdecc.xsd', 231, 12), )

    
    controls = property(__controls.value, __controls.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_JackDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 233, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 233, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __jack_flags.name() : __jack_flags,
        __jack_type.name() : __jack_type,
        __controls.name() : __controls
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'JackDescriptor', JackDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AVBInterfaceDescriptors with content type ELEMENT_ONLY
class AVBInterfaceDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AVBInterfaceDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AVBInterfaceDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 236, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}avb_interface uses Python identifier avb_interface
    __avb_interface = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'avb_interface'), 'avb_interface', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlavb_interface', True, pyxb.utils.utility.Location('avdecc.xsd', 238, 12), )

    
    avb_interface = property(__avb_interface.value, __avb_interface.set, None, None)

    _ElementMap.update({
        __avb_interface.name() : __avb_interface
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AVBInterfaceDescriptors', AVBInterfaceDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AVBInterfaceDescriptor with content type ELEMENT_ONLY
class AVBInterfaceDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.8"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AVBInterfaceDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 241, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 246, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 247, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}mac_address uses Python identifier mac_address
    __mac_address = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'mac_address'), 'mac_address', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmac_address', False, pyxb.utils.utility.Location('avdecc.xsd', 248, 12), )

    
    mac_address = property(__mac_address.value, __mac_address.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_identity uses Python identifier clock_identity
    __clock_identity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_identity'), 'clock_identity', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_identity', False, pyxb.utils.utility.Location('avdecc.xsd', 249, 12), )

    
    clock_identity = property(__clock_identity.value, __clock_identity.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}interface_flags uses Python identifier interface_flags
    __interface_flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'interface_flags'), 'interface_flags', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinterface_flags', False, pyxb.utils.utility.Location('avdecc.xsd', 250, 12), )

    
    interface_flags = property(__interface_flags.value, __interface_flags.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}priority1 uses Python identifier priority1
    __priority1 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'priority1'), 'priority1', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlpriority1', False, pyxb.utils.utility.Location('avdecc.xsd', 251, 12), )

    
    priority1 = property(__priority1.value, __priority1.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_class uses Python identifier clock_class
    __clock_class = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_class'), 'clock_class', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_class', False, pyxb.utils.utility.Location('avdecc.xsd', 252, 12), )

    
    clock_class = property(__clock_class.value, __clock_class.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}offset_scaled_log_variance uses Python identifier offset_scaled_log_variance
    __offset_scaled_log_variance = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'offset_scaled_log_variance'), 'offset_scaled_log_variance', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmloffset_scaled_log_variance', False, pyxb.utils.utility.Location('avdecc.xsd', 253, 12), )

    
    offset_scaled_log_variance = property(__offset_scaled_log_variance.value, __offset_scaled_log_variance.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_accuracy uses Python identifier clock_accuracy
    __clock_accuracy = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_accuracy'), 'clock_accuracy', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_accuracy', False, pyxb.utils.utility.Location('avdecc.xsd', 254, 12), )

    
    clock_accuracy = property(__clock_accuracy.value, __clock_accuracy.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}priority2 uses Python identifier priority2
    __priority2 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'priority2'), 'priority2', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlpriority2', False, pyxb.utils.utility.Location('avdecc.xsd', 255, 12), )

    
    priority2 = property(__priority2.value, __priority2.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}domain_number uses Python identifier domain_number
    __domain_number = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'domain_number'), 'domain_number', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmldomain_number', False, pyxb.utils.utility.Location('avdecc.xsd', 256, 12), )

    
    domain_number = property(__domain_number.value, __domain_number.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}log_sync_interval uses Python identifier log_sync_interval
    __log_sync_interval = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'log_sync_interval'), 'log_sync_interval', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllog_sync_interval', False, pyxb.utils.utility.Location('avdecc.xsd', 257, 12), )

    
    log_sync_interval = property(__log_sync_interval.value, __log_sync_interval.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}log_announce_interval uses Python identifier log_announce_interval
    __log_announce_interval = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'log_announce_interval'), 'log_announce_interval', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllog_announce_interval', False, pyxb.utils.utility.Location('avdecc.xsd', 258, 12), )

    
    log_announce_interval = property(__log_announce_interval.value, __log_announce_interval.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}log_pdelay_interval uses Python identifier log_pdelay_interval
    __log_pdelay_interval = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'log_pdelay_interval'), 'log_pdelay_interval', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllog_pdelay_interval', False, pyxb.utils.utility.Location('avdecc.xsd', 259, 12), )

    
    log_pdelay_interval = property(__log_pdelay_interval.value, __log_pdelay_interval.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}port_number uses Python identifier port_number
    __port_number = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'port_number'), 'port_number', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlport_number', False, pyxb.utils.utility.Location('avdecc.xsd', 260, 12), )

    
    port_number = property(__port_number.value, __port_number.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_AVBInterfaceDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 262, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 262, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __mac_address.name() : __mac_address,
        __clock_identity.name() : __clock_identity,
        __interface_flags.name() : __interface_flags,
        __priority1.name() : __priority1,
        __clock_class.name() : __clock_class,
        __offset_scaled_log_variance.name() : __offset_scaled_log_variance,
        __clock_accuracy.name() : __clock_accuracy,
        __priority2.name() : __priority2,
        __domain_number.name() : __domain_number,
        __log_sync_interval.name() : __log_sync_interval,
        __log_announce_interval.name() : __log_announce_interval,
        __log_pdelay_interval.name() : __log_pdelay_interval,
        __port_number.name() : __port_number
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'AVBInterfaceDescriptor', AVBInterfaceDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ClockSourceDescriptors with content type ELEMENT_ONLY
class ClockSourceDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ClockSourceDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ClockSourceDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 265, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_source uses Python identifier clock_source
    __clock_source = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_source'), 'clock_source', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockSourceDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlclock_source', True, pyxb.utils.utility.Location('avdecc.xsd', 267, 12), )

    
    clock_source = property(__clock_source.value, __clock_source.set, None, None)

    _ElementMap.update({
        __clock_source.name() : __clock_source
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ClockSourceDescriptors', ClockSourceDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ClockSourceDescriptor with content type ELEMENT_ONLY
class ClockSourceDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.9"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ClockSourceDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 270, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockSourceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 275, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockSourceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 276, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_source_flags uses Python identifier clock_source_flags
    __clock_source_flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_source_flags'), 'clock_source_flags', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockSourceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_source_flags', False, pyxb.utils.utility.Location('avdecc.xsd', 277, 12), )

    
    clock_source_flags = property(__clock_source_flags.value, __clock_source_flags.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_source_type uses Python identifier clock_source_type
    __clock_source_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_source_type'), 'clock_source_type', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockSourceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_source_type', False, pyxb.utils.utility.Location('avdecc.xsd', 278, 12), )

    
    clock_source_type = property(__clock_source_type.value, __clock_source_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_source_id uses Python identifier clock_source_id
    __clock_source_id = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_source_id'), 'clock_source_id', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockSourceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_source_id', False, pyxb.utils.utility.Location('avdecc.xsd', 279, 12), )

    
    clock_source_id = property(__clock_source_id.value, __clock_source_id.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_source_location_type uses Python identifier clock_source_location_type
    __clock_source_location_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_source_location_type'), 'clock_source_location_type', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockSourceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_source_location_type', False, pyxb.utils.utility.Location('avdecc.xsd', 280, 12), )

    
    clock_source_location_type = property(__clock_source_location_type.value, __clock_source_location_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_source_location_index uses Python identifier clock_source_location_index
    __clock_source_location_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_source_location_index'), 'clock_source_location_index', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockSourceDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_source_location_index', False, pyxb.utils.utility.Location('avdecc.xsd', 281, 12), )

    
    clock_source_location_index = property(__clock_source_location_index.value, __clock_source_location_index.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockSourceDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 283, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 283, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __clock_source_flags.name() : __clock_source_flags,
        __clock_source_type.name() : __clock_source_type,
        __clock_source_id.name() : __clock_source_id,
        __clock_source_location_type.name() : __clock_source_location_type,
        __clock_source_location_index.name() : __clock_source_location_index
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'ClockSourceDescriptor', ClockSourceDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MemoryObjectDescriptors with content type ELEMENT_ONLY
class MemoryObjectDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MemoryObjectDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MemoryObjectDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 286, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}memory_object uses Python identifier memory_object
    __memory_object = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'memory_object'), 'memory_object', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlmemory_object', True, pyxb.utils.utility.Location('avdecc.xsd', 288, 12), )

    
    memory_object = property(__memory_object.value, __memory_object.set, None, None)

    _ElementMap.update({
        __memory_object.name() : __memory_object
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MemoryObjectDescriptors', MemoryObjectDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MemoryObjectDescriptor with content type ELEMENT_ONLY
class MemoryObjectDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.10"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MemoryObjectDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 291, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 296, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 297, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}memory_object_type uses Python identifier memory_object_type
    __memory_object_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'memory_object_type'), 'memory_object_type', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmemory_object_type', False, pyxb.utils.utility.Location('avdecc.xsd', 298, 12), )

    
    memory_object_type = property(__memory_object_type.value, __memory_object_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}target_descriptor_type uses Python identifier target_descriptor_type
    __target_descriptor_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'target_descriptor_type'), 'target_descriptor_type', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptor_httpgrouper_ieee_orggroups17221contributionsxmltarget_descriptor_type', False, pyxb.utils.utility.Location('avdecc.xsd', 299, 12), )

    
    target_descriptor_type = property(__target_descriptor_type.value, __target_descriptor_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}target_descriptor_index uses Python identifier target_descriptor_index
    __target_descriptor_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'target_descriptor_index'), 'target_descriptor_index', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptor_httpgrouper_ieee_orggroups17221contributionsxmltarget_descriptor_index', False, pyxb.utils.utility.Location('avdecc.xsd', 300, 12), )

    
    target_descriptor_index = property(__target_descriptor_index.value, __target_descriptor_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}start_address uses Python identifier start_address
    __start_address = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'start_address'), 'start_address', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlstart_address', False, pyxb.utils.utility.Location('avdecc.xsd', 301, 12), )

    
    start_address = property(__start_address.value, __start_address.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum_length uses Python identifier maximum_length
    __maximum_length = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum_length'), 'maximum_length', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmaximum_length', False, pyxb.utils.utility.Location('avdecc.xsd', 302, 12), )

    
    maximum_length = property(__maximum_length.value, __maximum_length.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}length uses Python identifier length
    __length = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'length'), 'length', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllength', False, pyxb.utils.utility.Location('avdecc.xsd', 303, 12), )

    
    length = property(__length.value, __length.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}data_url uses Python identifier data_url
    __data_url = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'data_url'), 'data_url', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptor_httpgrouper_ieee_orggroups17221contributionsxmldata_url', False, pyxb.utils.utility.Location('avdecc.xsd', 305, 16), )

    
    data_url = property(__data_url.value, __data_url.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}data uses Python identifier data
    __data = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'data'), 'data', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptor_httpgrouper_ieee_orggroups17221contributionsxmldata', False, pyxb.utils.utility.Location('avdecc.xsd', 306, 16), )

    
    data = property(__data.value, __data.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_MemoryObjectDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 309, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 309, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __memory_object_type.name() : __memory_object_type,
        __target_descriptor_type.name() : __target_descriptor_type,
        __target_descriptor_index.name() : __target_descriptor_index,
        __start_address.name() : __start_address,
        __maximum_length.name() : __maximum_length,
        __length.name() : __length,
        __data_url.name() : __data_url,
        __data.name() : __data
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'MemoryObjectDescriptor', MemoryObjectDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}LocaleDescriptors with content type ELEMENT_ONLY
class LocaleDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}LocaleDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LocaleDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 312, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}locale uses Python identifier locale
    __locale = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'locale'), 'locale', '__httpgrouper_ieee_orggroups17221contributionsxml_LocaleDescriptors_httpgrouper_ieee_orggroups17221contributionsxmllocale', True, pyxb.utils.utility.Location('avdecc.xsd', 314, 12), )

    
    locale = property(__locale.value, __locale.set, None, None)

    _ElementMap.update({
        __locale.name() : __locale
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LocaleDescriptors', LocaleDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}LocaleDescriptor with content type ELEMENT_ONLY
class LocaleDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.11"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LocaleDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 317, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}locale_identifier uses Python identifier locale_identifier
    __locale_identifier = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'locale_identifier'), 'locale_identifier', '__httpgrouper_ieee_orggroups17221contributionsxml_LocaleDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocale_identifier', False, pyxb.utils.utility.Location('avdecc.xsd', 322, 12), )

    
    locale_identifier = property(__locale_identifier.value, __locale_identifier.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}locale_strings uses Python identifier locale_strings
    __locale_strings = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'locale_strings'), 'locale_strings', '__httpgrouper_ieee_orggroups17221contributionsxml_LocaleDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocale_strings', False, pyxb.utils.utility.Location('avdecc.xsd', 323, 12), )

    
    locale_strings = property(__locale_strings.value, __locale_strings.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_LocaleDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 325, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 325, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __locale_identifier.name() : __locale_identifier,
        __locale_strings.name() : __locale_strings
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'LocaleDescriptor', LocaleDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}StringsDescriptors with content type ELEMENT_ONLY
class StringsDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}StringsDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'StringsDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 328, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}strings uses Python identifier strings
    __strings = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'strings'), 'strings', '__httpgrouper_ieee_orggroups17221contributionsxml_StringsDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlstrings', True, pyxb.utils.utility.Location('avdecc.xsd', 330, 12), )

    
    strings = property(__strings.value, __strings.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_StringsDescriptors_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 332, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 332, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __strings.name() : __strings
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'StringsDescriptors', StringsDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}StringsDescriptor with content type ELEMENT_ONLY
class StringsDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.12"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'StringsDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 334, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}string uses Python identifier string
    __string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'string'), 'string', '__httpgrouper_ieee_orggroups17221contributionsxml_StringsDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlstring', True, pyxb.utils.utility.Location('avdecc.xsd', 339, 12), )

    
    string = property(__string.value, __string.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_StringsDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 341, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 341, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __string.name() : __string
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'StringsDescriptor', StringsDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioStreamPortDescriptors with content type ELEMENT_ONLY
class AudioStreamPortDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioStreamPortDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AudioStreamPortDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 344, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream_port uses Python identifier stream_port
    __stream_port = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream_port'), 'stream_port', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioStreamPortDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlstream_port', True, pyxb.utils.utility.Location('avdecc.xsd', 346, 12), )

    
    stream_port = property(__stream_port.value, __stream_port.set, None, None)

    _ElementMap.update({
        __stream_port.name() : __stream_port
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AudioStreamPortDescriptors', AudioStreamPortDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioStreamPortDescriptor with content type ELEMENT_ONLY
class AudioStreamPortDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.13"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AudioStreamPortDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 349, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_domain_index uses Python identifier clock_domain_index
    __clock_domain_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), 'clock_domain_index', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_domain_index', False, pyxb.utils.utility.Location('avdecc.xsd', 354, 12), )

    
    clock_domain_index = property(__clock_domain_index.value, __clock_domain_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}port_flags uses Python identifier port_flags
    __port_flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'port_flags'), 'port_flags', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlport_flags', False, pyxb.utils.utility.Location('avdecc.xsd', 355, 12), )

    
    port_flags = property(__port_flags.value, __port_flags.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controls uses Python identifier controls
    __controls = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controls'), 'controls', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrols', True, pyxb.utils.utility.Location('avdecc.xsd', 356, 12), )

    
    controls = property(__controls.value, __controls.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clusters uses Python identifier clusters
    __clusters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clusters'), 'clusters', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclusters', False, pyxb.utils.utility.Location('avdecc.xsd', 357, 12), )

    
    clusters = property(__clusters.value, __clusters.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maps uses Python identifier maps
    __maps = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maps'), 'maps', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmaps', True, pyxb.utils.utility.Location('avdecc.xsd', 358, 12), )

    
    maps = property(__maps.value, __maps.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioStreamPortDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 360, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 360, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __clock_domain_index.name() : __clock_domain_index,
        __port_flags.name() : __port_flags,
        __controls.name() : __controls,
        __clusters.name() : __clusters,
        __maps.name() : __maps
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'AudioStreamPortDescriptor', AudioStreamPortDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoStreamPortDescriptors with content type ELEMENT_ONLY
class VideoStreamPortDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoStreamPortDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoStreamPortDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 363, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream_port uses Python identifier stream_port
    __stream_port = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream_port'), 'stream_port', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoStreamPortDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlstream_port', True, pyxb.utils.utility.Location('avdecc.xsd', 365, 12), )

    
    stream_port = property(__stream_port.value, __stream_port.set, None, None)

    _ElementMap.update({
        __stream_port.name() : __stream_port
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VideoStreamPortDescriptors', VideoStreamPortDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoStreamPortDescriptor with content type ELEMENT_ONLY
class VideoStreamPortDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.13"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoStreamPortDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 368, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_domain_index uses Python identifier clock_domain_index
    __clock_domain_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), 'clock_domain_index', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_domain_index', False, pyxb.utils.utility.Location('avdecc.xsd', 373, 12), )

    
    clock_domain_index = property(__clock_domain_index.value, __clock_domain_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}port_flags uses Python identifier port_flags
    __port_flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'port_flags'), 'port_flags', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlport_flags', False, pyxb.utils.utility.Location('avdecc.xsd', 374, 12), )

    
    port_flags = property(__port_flags.value, __port_flags.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controls uses Python identifier controls
    __controls = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controls'), 'controls', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrols', True, pyxb.utils.utility.Location('avdecc.xsd', 375, 12), )

    
    controls = property(__controls.value, __controls.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clusters uses Python identifier clusters
    __clusters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clusters'), 'clusters', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclusters', False, pyxb.utils.utility.Location('avdecc.xsd', 376, 12), )

    
    clusters = property(__clusters.value, __clusters.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maps uses Python identifier maps
    __maps = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maps'), 'maps', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmaps', True, pyxb.utils.utility.Location('avdecc.xsd', 377, 12), )

    
    maps = property(__maps.value, __maps.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoStreamPortDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 379, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 379, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __clock_domain_index.name() : __clock_domain_index,
        __port_flags.name() : __port_flags,
        __controls.name() : __controls,
        __clusters.name() : __clusters,
        __maps.name() : __maps
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'VideoStreamPortDescriptor', VideoStreamPortDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorStreamPortDescriptors with content type ELEMENT_ONLY
class SensorStreamPortDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorStreamPortDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SensorStreamPortDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 382, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream_port uses Python identifier stream_port
    __stream_port = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream_port'), 'stream_port', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorStreamPortDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlstream_port', True, pyxb.utils.utility.Location('avdecc.xsd', 384, 12), )

    
    stream_port = property(__stream_port.value, __stream_port.set, None, None)

    _ElementMap.update({
        __stream_port.name() : __stream_port
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SensorStreamPortDescriptors', SensorStreamPortDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorStreamPortDescriptor with content type ELEMENT_ONLY
class SensorStreamPortDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.13"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SensorStreamPortDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 387, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_domain_index uses Python identifier clock_domain_index
    __clock_domain_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), 'clock_domain_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_domain_index', False, pyxb.utils.utility.Location('avdecc.xsd', 392, 12), )

    
    clock_domain_index = property(__clock_domain_index.value, __clock_domain_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}port_flags uses Python identifier port_flags
    __port_flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'port_flags'), 'port_flags', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlport_flags', False, pyxb.utils.utility.Location('avdecc.xsd', 393, 12), )

    
    port_flags = property(__port_flags.value, __port_flags.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controls uses Python identifier controls
    __controls = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controls'), 'controls', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrols', True, pyxb.utils.utility.Location('avdecc.xsd', 394, 12), )

    
    controls = property(__controls.value, __controls.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clusters uses Python identifier clusters
    __clusters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clusters'), 'clusters', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclusters', False, pyxb.utils.utility.Location('avdecc.xsd', 395, 12), )

    
    clusters = property(__clusters.value, __clusters.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maps uses Python identifier maps
    __maps = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maps'), 'maps', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorStreamPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmaps', True, pyxb.utils.utility.Location('avdecc.xsd', 396, 12), )

    
    maps = property(__maps.value, __maps.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorStreamPortDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 398, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 398, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __clock_domain_index.name() : __clock_domain_index,
        __port_flags.name() : __port_flags,
        __controls.name() : __controls,
        __clusters.name() : __clusters,
        __maps.name() : __maps
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'SensorStreamPortDescriptor', SensorStreamPortDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ExternalPortDescriptors with content type ELEMENT_ONLY
class ExternalPortDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ExternalPortDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ExternalPortDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 401, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}external_port uses Python identifier external_port
    __external_port = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'external_port'), 'external_port', '__httpgrouper_ieee_orggroups17221contributionsxml_ExternalPortDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlexternal_port', True, pyxb.utils.utility.Location('avdecc.xsd', 403, 12), )

    
    external_port = property(__external_port.value, __external_port.set, None, None)

    _ElementMap.update({
        __external_port.name() : __external_port
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ExternalPortDescriptors', ExternalPortDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ExternalPortDescriptor with content type ELEMENT_ONLY
class ExternalPortDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.14"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ExternalPortDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 406, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_domain_index uses Python identifier clock_domain_index
    __clock_domain_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), 'clock_domain_index', '__httpgrouper_ieee_orggroups17221contributionsxml_ExternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_domain_index', False, pyxb.utils.utility.Location('avdecc.xsd', 411, 12), )

    
    clock_domain_index = property(__clock_domain_index.value, __clock_domain_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}port_flags uses Python identifier port_flags
    __port_flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'port_flags'), 'port_flags', '__httpgrouper_ieee_orggroups17221contributionsxml_ExternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlport_flags', False, pyxb.utils.utility.Location('avdecc.xsd', 412, 12), )

    
    port_flags = property(__port_flags.value, __port_flags.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controls uses Python identifier controls
    __controls = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controls'), 'controls', '__httpgrouper_ieee_orggroups17221contributionsxml_ExternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrols', True, pyxb.utils.utility.Location('avdecc.xsd', 413, 12), )

    
    controls = property(__controls.value, __controls.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_ExternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 414, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_ExternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 415, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_ExternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 416, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_ExternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 417, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}jack_index uses Python identifier jack_index
    __jack_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'jack_index'), 'jack_index', '__httpgrouper_ieee_orggroups17221contributionsxml_ExternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmljack_index', False, pyxb.utils.utility.Location('avdecc.xsd', 418, 12), )

    
    jack_index = property(__jack_index.value, __jack_index.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_ExternalPortDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 420, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 420, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __clock_domain_index.name() : __clock_domain_index,
        __port_flags.name() : __port_flags,
        __controls.name() : __controls,
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output,
        __block_latency.name() : __block_latency,
        __jack_index.name() : __jack_index
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'ExternalPortDescriptor', ExternalPortDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}InternalPortDescriptors with content type ELEMENT_ONLY
class InternalPortDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}InternalPortDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'InternalPortDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 423, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}internal_port uses Python identifier internal_port
    __internal_port = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'internal_port'), 'internal_port', '__httpgrouper_ieee_orggroups17221contributionsxml_InternalPortDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlinternal_port', True, pyxb.utils.utility.Location('avdecc.xsd', 425, 12), )

    
    internal_port = property(__internal_port.value, __internal_port.set, None, None)

    _ElementMap.update({
        __internal_port.name() : __internal_port
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'InternalPortDescriptors', InternalPortDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}InternalPortDescriptor with content type ELEMENT_ONLY
class InternalPortDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.15"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'InternalPortDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 428, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_domain_index uses Python identifier clock_domain_index
    __clock_domain_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), 'clock_domain_index', '__httpgrouper_ieee_orggroups17221contributionsxml_InternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_domain_index', False, pyxb.utils.utility.Location('avdecc.xsd', 433, 12), )

    
    clock_domain_index = property(__clock_domain_index.value, __clock_domain_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}port_flags uses Python identifier port_flags
    __port_flags = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'port_flags'), 'port_flags', '__httpgrouper_ieee_orggroups17221contributionsxml_InternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlport_flags', False, pyxb.utils.utility.Location('avdecc.xsd', 434, 12), )

    
    port_flags = property(__port_flags.value, __port_flags.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controls uses Python identifier controls
    __controls = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controls'), 'controls', '__httpgrouper_ieee_orggroups17221contributionsxml_InternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrols', True, pyxb.utils.utility.Location('avdecc.xsd', 435, 12), )

    
    controls = property(__controls.value, __controls.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_InternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 436, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_InternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 437, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_InternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 438, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_InternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 439, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}internal_index uses Python identifier internal_index
    __internal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'internal_index'), 'internal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_InternalPortDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlinternal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 440, 12), )

    
    internal_index = property(__internal_index.value, __internal_index.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_InternalPortDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 442, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 442, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __clock_domain_index.name() : __clock_domain_index,
        __port_flags.name() : __port_flags,
        __controls.name() : __controls,
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output,
        __block_latency.name() : __block_latency,
        __internal_index.name() : __internal_index
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'InternalPortDescriptor', InternalPortDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioClusterDescriptors with content type ELEMENT_ONLY
class AudioClusterDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioClusterDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AudioClusterDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 445, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}audio_cluster uses Python identifier audio_cluster
    __audio_cluster = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'audio_cluster'), 'audio_cluster', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioClusterDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlaudio_cluster', True, pyxb.utils.utility.Location('avdecc.xsd', 447, 12), )

    
    audio_cluster = property(__audio_cluster.value, __audio_cluster.set, None, None)

    _ElementMap.update({
        __audio_cluster.name() : __audio_cluster
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AudioClusterDescriptors', AudioClusterDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioClusterDescriptor with content type ELEMENT_ONLY
class AudioClusterDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.16"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AudioClusterDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 450, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 455, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 456, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 457, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 458, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 459, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}path_latency uses Python identifier path_latency
    __path_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'path_latency'), 'path_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlpath_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 460, 12), )

    
    path_latency = property(__path_latency.value, __path_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 461, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}channel_count uses Python identifier channel_count
    __channel_count = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'channel_count'), 'channel_count', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlchannel_count', False, pyxb.utils.utility.Location('avdecc.xsd', 462, 12), )

    
    channel_count = property(__channel_count.value, __channel_count.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}format uses Python identifier format
    __format = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'format'), 'format', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlformat', False, pyxb.utils.utility.Location('avdecc.xsd', 463, 12), )

    
    format = property(__format.value, __format.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioClusterDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 465, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 465, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output,
        __path_latency.name() : __path_latency,
        __block_latency.name() : __block_latency,
        __channel_count.name() : __channel_count,
        __format.name() : __format
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'AudioClusterDescriptor', AudioClusterDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoClusterDescriptors with content type ELEMENT_ONLY
class VideoClusterDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoClusterDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoClusterDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 468, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}video_cluster uses Python identifier video_cluster
    __video_cluster = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'video_cluster'), 'video_cluster', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlvideo_cluster', True, pyxb.utils.utility.Location('avdecc.xsd', 470, 12), )

    
    video_cluster = property(__video_cluster.value, __video_cluster.set, None, None)

    _ElementMap.update({
        __video_cluster.name() : __video_cluster
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VideoClusterDescriptors', VideoClusterDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoClusterDescriptor with content type ELEMENT_ONLY
class VideoClusterDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.17"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoClusterDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 473, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 478, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 479, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 480, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 481, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 482, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}path_latency uses Python identifier path_latency
    __path_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'path_latency'), 'path_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlpath_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 483, 12), )

    
    path_latency = property(__path_latency.value, __path_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 484, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}format uses Python identifier format
    __format = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'format'), 'format', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlformat', False, pyxb.utils.utility.Location('avdecc.xsd', 485, 12), )

    
    format = property(__format.value, __format.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_format_specific uses Python identifier current_format_specific
    __current_format_specific = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_format_specific'), 'current_format_specific', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_format_specific', False, pyxb.utils.utility.Location('avdecc.xsd', 486, 12), )

    
    current_format_specific = property(__current_format_specific.value, __current_format_specific.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_sampling_rate uses Python identifier current_sampling_rate
    __current_sampling_rate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_sampling_rate'), 'current_sampling_rate', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_sampling_rate', False, pyxb.utils.utility.Location('avdecc.xsd', 487, 12), )

    
    current_sampling_rate = property(__current_sampling_rate.value, __current_sampling_rate.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_aspect_ratio uses Python identifier current_aspect_ratio
    __current_aspect_ratio = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_aspect_ratio'), 'current_aspect_ratio', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_aspect_ratio', False, pyxb.utils.utility.Location('avdecc.xsd', 488, 12), )

    
    current_aspect_ratio = property(__current_aspect_ratio.value, __current_aspect_ratio.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_video_size uses Python identifier current_video_size
    __current_video_size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_video_size'), 'current_video_size', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_video_size', False, pyxb.utils.utility.Location('avdecc.xsd', 489, 12), )

    
    current_video_size = property(__current_video_size.value, __current_video_size.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_color_space uses Python identifier current_color_space
    __current_color_space = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_color_space'), 'current_color_space', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_color_space', False, pyxb.utils.utility.Location('avdecc.xsd', 490, 12), )

    
    current_color_space = property(__current_color_space.value, __current_color_space.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}format_specifics uses Python identifier format_specifics
    __format_specifics = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'format_specifics'), 'format_specifics', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlformat_specifics', False, pyxb.utils.utility.Location('avdecc.xsd', 491, 12), )

    
    format_specifics = property(__format_specifics.value, __format_specifics.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sampling_rates uses Python identifier sampling_rates
    __sampling_rates = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sampling_rates'), 'sampling_rates', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsampling_rates', False, pyxb.utils.utility.Location('avdecc.xsd', 492, 12), )

    
    sampling_rates = property(__sampling_rates.value, __sampling_rates.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}aspect_ratios uses Python identifier aspect_ratios
    __aspect_ratios = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'aspect_ratios'), 'aspect_ratios', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlaspect_ratios', False, pyxb.utils.utility.Location('avdecc.xsd', 493, 12), )

    
    aspect_ratios = property(__aspect_ratios.value, __aspect_ratios.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}video_sizes uses Python identifier video_sizes
    __video_sizes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'video_sizes'), 'video_sizes', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlvideo_sizes', False, pyxb.utils.utility.Location('avdecc.xsd', 494, 12), )

    
    video_sizes = property(__video_sizes.value, __video_sizes.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}color_spaces uses Python identifier color_spaces
    __color_spaces = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'color_spaces'), 'color_spaces', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcolor_spaces', False, pyxb.utils.utility.Location('avdecc.xsd', 495, 12), )

    
    color_spaces = property(__color_spaces.value, __color_spaces.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 497, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 497, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output,
        __path_latency.name() : __path_latency,
        __block_latency.name() : __block_latency,
        __format.name() : __format,
        __current_format_specific.name() : __current_format_specific,
        __current_sampling_rate.name() : __current_sampling_rate,
        __current_aspect_ratio.name() : __current_aspect_ratio,
        __current_video_size.name() : __current_video_size,
        __current_color_space.name() : __current_color_space,
        __format_specifics.name() : __format_specifics,
        __sampling_rates.name() : __sampling_rates,
        __aspect_ratios.name() : __aspect_ratios,
        __video_sizes.name() : __video_sizes,
        __color_spaces.name() : __color_spaces
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'VideoClusterDescriptor', VideoClusterDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoClusterFormatSpecifics with content type ELEMENT_ONLY
class VideoClusterFormatSpecifics (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoClusterFormatSpecifics with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoClusterFormatSpecifics')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 499, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}format_specific uses Python identifier format_specific
    __format_specific = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'format_specific'), 'format_specific', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterFormatSpecifics_httpgrouper_ieee_orggroups17221contributionsxmlformat_specific', True, pyxb.utils.utility.Location('avdecc.xsd', 501, 12), )

    
    format_specific = property(__format_specific.value, __format_specific.set, None, None)

    _ElementMap.update({
        __format_specific.name() : __format_specific
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VideoClusterFormatSpecifics', VideoClusterFormatSpecifics)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoClusterAspectRatios with content type ELEMENT_ONLY
class VideoClusterAspectRatios (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoClusterAspectRatios with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoClusterAspectRatios')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 504, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}aspect_ratio uses Python identifier aspect_ratio
    __aspect_ratio = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'aspect_ratio'), 'aspect_ratio', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterAspectRatios_httpgrouper_ieee_orggroups17221contributionsxmlaspect_ratio', True, pyxb.utils.utility.Location('avdecc.xsd', 506, 12), )

    
    aspect_ratio = property(__aspect_ratio.value, __aspect_ratio.set, None, None)

    _ElementMap.update({
        __aspect_ratio.name() : __aspect_ratio
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VideoClusterAspectRatios', VideoClusterAspectRatios)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoClusterSizes with content type ELEMENT_ONLY
class VideoClusterSizes (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoClusterSizes with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoClusterSizes')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 509, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}video_size uses Python identifier video_size
    __video_size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'video_size'), 'video_size', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterSizes_httpgrouper_ieee_orggroups17221contributionsxmlvideo_size', True, pyxb.utils.utility.Location('avdecc.xsd', 511, 12), )

    
    video_size = property(__video_size.value, __video_size.set, None, None)

    _ElementMap.update({
        __video_size.name() : __video_size
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VideoClusterSizes', VideoClusterSizes)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoClusterColorSpaces with content type ELEMENT_ONLY
class VideoClusterColorSpaces (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoClusterColorSpaces with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoClusterColorSpaces')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 514, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}color_space uses Python identifier color_space
    __color_space = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'color_space'), 'color_space', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoClusterColorSpaces_httpgrouper_ieee_orggroups17221contributionsxmlcolor_space', True, pyxb.utils.utility.Location('avdecc.xsd', 516, 12), )

    
    color_space = property(__color_space.value, __color_space.set, None, None)

    _ElementMap.update({
        __color_space.name() : __color_space
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VideoClusterColorSpaces', VideoClusterColorSpaces)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorClusterDescriptors with content type ELEMENT_ONLY
class SensorClusterDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorClusterDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SensorClusterDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 520, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sensor_cluster uses Python identifier sensor_cluster
    __sensor_cluster = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sensor_cluster'), 'sensor_cluster', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlsensor_cluster', True, pyxb.utils.utility.Location('avdecc.xsd', 522, 12), )

    
    sensor_cluster = property(__sensor_cluster.value, __sensor_cluster.set, None, None)

    _ElementMap.update({
        __sensor_cluster.name() : __sensor_cluster
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SensorClusterDescriptors', SensorClusterDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorClusterDescriptor with content type ELEMENT_ONLY
class SensorClusterDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.18"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SensorClusterDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 525, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 530, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 531, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 532, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 533, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 534, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}path_latency uses Python identifier path_latency
    __path_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'path_latency'), 'path_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlpath_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 535, 12), )

    
    path_latency = property(__path_latency.value, __path_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 536, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_sensor_format uses Python identifier current_sensor_format
    __current_sensor_format = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_sensor_format'), 'current_sensor_format', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_sensor_format', False, pyxb.utils.utility.Location('avdecc.xsd', 537, 12), )

    
    current_sensor_format = property(__current_sensor_format.value, __current_sensor_format.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sampling_rate uses Python identifier sampling_rate
    __sampling_rate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sampling_rate'), 'sampling_rate', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsampling_rate', False, pyxb.utils.utility.Location('avdecc.xsd', 538, 12), )

    
    sampling_rate = property(__sampling_rate.value, __sampling_rate.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sensor_formats uses Python identifier sensor_formats
    __sensor_formats = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sensor_formats'), 'sensor_formats', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsensor_formats', False, pyxb.utils.utility.Location('avdecc.xsd', 539, 12), )

    
    sensor_formats = property(__sensor_formats.value, __sensor_formats.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sampling_rates uses Python identifier sampling_rates
    __sampling_rates = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sampling_rates'), 'sampling_rates', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsampling_rates', False, pyxb.utils.utility.Location('avdecc.xsd', 540, 12), )

    
    sampling_rates = property(__sampling_rates.value, __sampling_rates.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorClusterDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 542, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 542, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output,
        __path_latency.name() : __path_latency,
        __block_latency.name() : __block_latency,
        __current_sensor_format.name() : __current_sensor_format,
        __sampling_rate.name() : __sampling_rate,
        __sensor_formats.name() : __sensor_formats,
        __sampling_rates.name() : __sampling_rates
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'SensorClusterDescriptor', SensorClusterDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorFormats with content type ELEMENT_ONLY
class SensorFormats (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorFormats with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SensorFormats')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 544, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sensor_format uses Python identifier sensor_format
    __sensor_format = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sensor_format'), 'sensor_format', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorFormats_httpgrouper_ieee_orggroups17221contributionsxmlsensor_format', True, pyxb.utils.utility.Location('avdecc.xsd', 546, 12), )

    
    sensor_format = property(__sensor_format.value, __sensor_format.set, None, None)

    _ElementMap.update({
        __sensor_format.name() : __sensor_format
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SensorFormats', SensorFormats)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioMapDescriptors with content type ELEMENT_ONLY
class AudioMapDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioMapDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AudioMapDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 551, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}audio_map uses Python identifier audio_map
    __audio_map = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'audio_map'), 'audio_map', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioMapDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlaudio_map', True, pyxb.utils.utility.Location('avdecc.xsd', 553, 12), )

    
    audio_map = property(__audio_map.value, __audio_map.set, None, None)

    _ElementMap.update({
        __audio_map.name() : __audio_map
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AudioMapDescriptors', AudioMapDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioMapDescriptor with content type ELEMENT_ONLY
class AudioMapDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.19"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AudioMapDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 556, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}audio_mapping uses Python identifier audio_mapping
    __audio_mapping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'audio_mapping'), 'audio_mapping', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioMapDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlaudio_mapping', True, pyxb.utils.utility.Location('avdecc.xsd', 561, 12), )

    
    audio_mapping = property(__audio_mapping.value, __audio_mapping.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioMapDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 563, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 563, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __audio_mapping.name() : __audio_mapping
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'AudioMapDescriptor', AudioMapDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioMapping with content type ELEMENT_ONLY
class AudioMapping (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AudioMapping with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AudioMapping')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 565, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream_index uses Python identifier stream_index
    __stream_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream_index'), 'stream_index', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioMapping_httpgrouper_ieee_orggroups17221contributionsxmlstream_index', False, pyxb.utils.utility.Location('avdecc.xsd', 567, 12), )

    
    stream_index = property(__stream_index.value, __stream_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream_channel uses Python identifier stream_channel
    __stream_channel = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream_channel'), 'stream_channel', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioMapping_httpgrouper_ieee_orggroups17221contributionsxmlstream_channel', False, pyxb.utils.utility.Location('avdecc.xsd', 568, 12), )

    
    stream_channel = property(__stream_channel.value, __stream_channel.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}cluster_offset uses Python identifier cluster_offset
    __cluster_offset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'cluster_offset'), 'cluster_offset', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioMapping_httpgrouper_ieee_orggroups17221contributionsxmlcluster_offset', False, pyxb.utils.utility.Location('avdecc.xsd', 569, 12), )

    
    cluster_offset = property(__cluster_offset.value, __cluster_offset.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}cluster_channel uses Python identifier cluster_channel
    __cluster_channel = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'cluster_channel'), 'cluster_channel', '__httpgrouper_ieee_orggroups17221contributionsxml_AudioMapping_httpgrouper_ieee_orggroups17221contributionsxmlcluster_channel', False, pyxb.utils.utility.Location('avdecc.xsd', 570, 12), )

    
    cluster_channel = property(__cluster_channel.value, __cluster_channel.set, None, None)

    _ElementMap.update({
        __stream_index.name() : __stream_index,
        __stream_channel.name() : __stream_channel,
        __cluster_offset.name() : __cluster_offset,
        __cluster_channel.name() : __cluster_channel
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AudioMapping', AudioMapping)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoMapDescriptors with content type ELEMENT_ONLY
class VideoMapDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoMapDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoMapDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 574, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}video_map uses Python identifier video_map
    __video_map = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'video_map'), 'video_map', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoMapDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlvideo_map', True, pyxb.utils.utility.Location('avdecc.xsd', 576, 12), )

    
    video_map = property(__video_map.value, __video_map.set, None, None)

    _ElementMap.update({
        __video_map.name() : __video_map
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VideoMapDescriptors', VideoMapDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoMapDescriptor with content type ELEMENT_ONLY
class VideoMapDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.20"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoMapDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 579, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}video_mapping uses Python identifier video_mapping
    __video_mapping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'video_mapping'), 'video_mapping', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoMapDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlvideo_mapping', True, pyxb.utils.utility.Location('avdecc.xsd', 584, 12), )

    
    video_mapping = property(__video_mapping.value, __video_mapping.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoMapDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 586, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 586, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __video_mapping.name() : __video_mapping
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'VideoMapDescriptor', VideoMapDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoMapping with content type ELEMENT_ONLY
class VideoMapping (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoMapping with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoMapping')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 588, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream_index uses Python identifier stream_index
    __stream_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream_index'), 'stream_index', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoMapping_httpgrouper_ieee_orggroups17221contributionsxmlstream_index', False, pyxb.utils.utility.Location('avdecc.xsd', 590, 12), )

    
    stream_index = property(__stream_index.value, __stream_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}program_stream uses Python identifier program_stream
    __program_stream = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'program_stream'), 'program_stream', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoMapping_httpgrouper_ieee_orggroups17221contributionsxmlprogram_stream', False, pyxb.utils.utility.Location('avdecc.xsd', 591, 12), )

    
    program_stream = property(__program_stream.value, __program_stream.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}elementary_stream uses Python identifier elementary_stream
    __elementary_stream = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'elementary_stream'), 'elementary_stream', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoMapping_httpgrouper_ieee_orggroups17221contributionsxmlelementary_stream', False, pyxb.utils.utility.Location('avdecc.xsd', 592, 12), )

    
    elementary_stream = property(__elementary_stream.value, __elementary_stream.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}cluster_offset uses Python identifier cluster_offset
    __cluster_offset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'cluster_offset'), 'cluster_offset', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoMapping_httpgrouper_ieee_orggroups17221contributionsxmlcluster_offset', False, pyxb.utils.utility.Location('avdecc.xsd', 593, 12), )

    
    cluster_offset = property(__cluster_offset.value, __cluster_offset.set, None, None)

    _ElementMap.update({
        __stream_index.name() : __stream_index,
        __program_stream.name() : __program_stream,
        __elementary_stream.name() : __elementary_stream,
        __cluster_offset.name() : __cluster_offset
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VideoMapping', VideoMapping)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorMapDescriptors with content type ELEMENT_ONLY
class SensorMapDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorMapDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SensorMapDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 597, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sensor_map uses Python identifier sensor_map
    __sensor_map = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sensor_map'), 'sensor_map', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorMapDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlsensor_map', True, pyxb.utils.utility.Location('avdecc.xsd', 599, 12), )

    
    sensor_map = property(__sensor_map.value, __sensor_map.set, None, None)

    _ElementMap.update({
        __sensor_map.name() : __sensor_map
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SensorMapDescriptors', SensorMapDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorMapDescriptor with content type ELEMENT_ONLY
class SensorMapDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorMapDescriptor with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SensorMapDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 602, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sensor_mapping uses Python identifier sensor_mapping
    __sensor_mapping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sensor_mapping'), 'sensor_mapping', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorMapDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsensor_mapping', True, pyxb.utils.utility.Location('avdecc.xsd', 604, 12), )

    
    sensor_mapping = property(__sensor_mapping.value, __sensor_mapping.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorMapDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 606, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 606, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __sensor_mapping.name() : __sensor_mapping
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'SensorMapDescriptor', SensorMapDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SensorMapping with content type ELEMENT_ONLY
class SensorMapping (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.21"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SensorMapping')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 608, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream_index uses Python identifier stream_index
    __stream_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream_index'), 'stream_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorMapping_httpgrouper_ieee_orggroups17221contributionsxmlstream_index', False, pyxb.utils.utility.Location('avdecc.xsd', 613, 12), )

    
    stream_index = property(__stream_index.value, __stream_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream_signal uses Python identifier stream_signal
    __stream_signal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream_signal'), 'stream_signal', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorMapping_httpgrouper_ieee_orggroups17221contributionsxmlstream_signal', False, pyxb.utils.utility.Location('avdecc.xsd', 614, 12), )

    
    stream_signal = property(__stream_signal.value, __stream_signal.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}cluster_offset uses Python identifier cluster_offset
    __cluster_offset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'cluster_offset'), 'cluster_offset', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorMapping_httpgrouper_ieee_orggroups17221contributionsxmlcluster_offset', False, pyxb.utils.utility.Location('avdecc.xsd', 615, 12), )

    
    cluster_offset = property(__cluster_offset.value, __cluster_offset.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_SensorMapping_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 617, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 617, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __stream_index.name() : __stream_index,
        __stream_signal.name() : __stream_signal,
        __cluster_offset.name() : __cluster_offset
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'SensorMapping', SensorMapping)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ControlDescriptors with content type ELEMENT_ONLY
class ControlDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ControlDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ControlDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 620, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control uses Python identifier control
    __control = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control'), 'control', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlcontrol', True, pyxb.utils.utility.Location('avdecc.xsd', 622, 12), )

    
    control = property(__control.value, __control.set, None, None)

    _ElementMap.update({
        __control.name() : __control
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ControlDescriptors', ControlDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ControlDescriptor with content type ELEMENT_ONLY
class ControlDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.22"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ControlDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 625, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 630, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 631, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 632, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_latency uses Python identifier control_latency
    __control_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), 'control_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 633, 12), )

    
    control_latency = property(__control_latency.value, __control_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_domain uses Python identifier control_domain
    __control_domain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), 'control_domain', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_domain', False, pyxb.utils.utility.Location('avdecc.xsd', 634, 12), )

    
    control_domain = property(__control_domain.value, __control_domain.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_type uses Python identifier control_type
    __control_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_type'), 'control_type', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_type', False, pyxb.utils.utility.Location('avdecc.xsd', 635, 12), )

    
    control_type = property(__control_type.value, __control_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_value_type uses Python identifier control_value_type
    __control_value_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_value_type'), 'control_value_type', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_value_type', False, pyxb.utils.utility.Location('avdecc.xsd', 636, 12), )

    
    control_value_type = property(__control_value_type.value, __control_value_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}reset_time uses Python identifier reset_time
    __reset_time = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'reset_time'), 'reset_time', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlreset_time', False, pyxb.utils.utility.Location('avdecc.xsd', 637, 12), )

    
    reset_time = property(__reset_time.value, __reset_time.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 638, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 639, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 640, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}values uses Python identifier values
    __values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'values'), 'values', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlvalues', False, pyxb.utils.utility.Location('avdecc.xsd', 641, 12), )

    
    values = property(__values.value, __values.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 643, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 643, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __block_latency.name() : __block_latency,
        __control_latency.name() : __control_latency,
        __control_domain.name() : __control_domain,
        __control_type.name() : __control_type,
        __control_value_type.name() : __control_value_type,
        __reset_time.name() : __reset_time,
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output,
        __values.name() : __values
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'ControlDescriptor', ControlDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSelectorDescriptors with content type ELEMENT_ONLY
class SignalSelectorDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSelectorDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalSelectorDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 646, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_selector uses Python identifier signal_selector
    __signal_selector = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_selector'), 'signal_selector', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlsignal_selector', True, pyxb.utils.utility.Location('avdecc.xsd', 648, 12), )

    
    signal_selector = property(__signal_selector.value, __signal_selector.set, None, None)

    _ElementMap.update({
        __signal_selector.name() : __signal_selector
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalSelectorDescriptors', SignalSelectorDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSelectorDescriptor with content type ELEMENT_ONLY
class SignalSelectorDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.23"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalSelectorDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 651, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 656, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 657, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 658, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_latency uses Python identifier control_latency
    __control_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), 'control_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 659, 12), )

    
    control_latency = property(__control_latency.value, __control_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_domain uses Python identifier control_domain
    __control_domain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), 'control_domain', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_domain', False, pyxb.utils.utility.Location('avdecc.xsd', 660, 12), )

    
    control_domain = property(__control_domain.value, __control_domain.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_signal_type uses Python identifier current_signal_type
    __current_signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_signal_type'), 'current_signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_signal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 661, 12), )

    
    current_signal_type = property(__current_signal_type.value, __current_signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_signal_index uses Python identifier current_signal_index
    __current_signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_signal_index'), 'current_signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_signal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 662, 12), )

    
    current_signal_index = property(__current_signal_index.value, __current_signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_signal_output uses Python identifier current_signal_output
    __current_signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_signal_output'), 'current_signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_signal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 663, 12), )

    
    current_signal_output = property(__current_signal_output.value, __current_signal_output.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default_signal_type uses Python identifier default_signal_type
    __default_signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default_signal_type'), 'default_signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmldefault_signal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 664, 12), )

    
    default_signal_type = property(__default_signal_type.value, __default_signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default_signal_index uses Python identifier default_signal_index
    __default_signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default_signal_index'), 'default_signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmldefault_signal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 665, 12), )

    
    default_signal_index = property(__default_signal_index.value, __default_signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default_signal_output uses Python identifier default_signal_output
    __default_signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default_signal_output'), 'default_signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmldefault_signal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 666, 12), )

    
    default_signal_output = property(__default_signal_output.value, __default_signal_output.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sources uses Python identifier sources
    __sources = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sources'), 'sources', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsources', False, pyxb.utils.utility.Location('avdecc.xsd', 667, 12), )

    
    sources = property(__sources.value, __sources.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 669, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 669, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __block_latency.name() : __block_latency,
        __control_latency.name() : __control_latency,
        __control_domain.name() : __control_domain,
        __current_signal_type.name() : __current_signal_type,
        __current_signal_index.name() : __current_signal_index,
        __current_signal_output.name() : __current_signal_output,
        __default_signal_type.name() : __default_signal_type,
        __default_signal_index.name() : __default_signal_index,
        __default_signal_output.name() : __default_signal_output,
        __sources.name() : __sources
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'SignalSelectorDescriptor', SignalSelectorDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSelectorSignalSources with content type ELEMENT_ONLY
class SignalSelectorSignalSources (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSelectorSignalSources with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalSelectorSignalSources')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 671, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal uses Python identifier signal
    __signal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal'), 'signal', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorSignalSources_httpgrouper_ieee_orggroups17221contributionsxmlsignal', True, pyxb.utils.utility.Location('avdecc.xsd', 673, 12), )

    
    signal = property(__signal.value, __signal.set, None, None)

    _ElementMap.update({
        __signal.name() : __signal
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalSelectorSignalSources', SignalSelectorSignalSources)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSelectorSignalSource with content type ELEMENT_ONLY
class SignalSelectorSignalSource (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSelectorSignalSource with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalSelectorSignalSource')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 676, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 678, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 679, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSelectorSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 680, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    _ElementMap.update({
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalSelectorSignalSource', SignalSelectorSignalSource)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MixerDescriptors with content type ELEMENT_ONLY
class MixerDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MixerDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MixerDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 684, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}mixer uses Python identifier mixer
    __mixer = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'mixer'), 'mixer', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlmixer', True, pyxb.utils.utility.Location('avdecc.xsd', 686, 12), )

    
    mixer = property(__mixer.value, __mixer.set, None, None)

    _ElementMap.update({
        __mixer.name() : __mixer
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MixerDescriptors', MixerDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MixerDescriptor with content type ELEMENT_ONLY
class MixerDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.24"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MixerDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 689, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 694, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 695, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 696, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_latency uses Python identifier control_latency
    __control_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), 'control_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 697, 12), )

    
    control_latency = property(__control_latency.value, __control_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_domain uses Python identifier control_domain
    __control_domain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), 'control_domain', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_domain', False, pyxb.utils.utility.Location('avdecc.xsd', 698, 12), )

    
    control_domain = property(__control_domain.value, __control_domain.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_value_type uses Python identifier control_value_type
    __control_value_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_value_type'), 'control_value_type', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_value_type', False, pyxb.utils.utility.Location('avdecc.xsd', 699, 12), )

    
    control_value_type = property(__control_value_type.value, __control_value_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sources uses Python identifier sources
    __sources = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sources'), 'sources', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsources', False, pyxb.utils.utility.Location('avdecc.xsd', 700, 12), )

    
    sources = property(__sources.value, __sources.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}values uses Python identifier values
    __values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'values'), 'values', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlvalues', False, pyxb.utils.utility.Location('avdecc.xsd', 701, 12), )

    
    values = property(__values.value, __values.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 703, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 703, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __block_latency.name() : __block_latency,
        __control_latency.name() : __control_latency,
        __control_domain.name() : __control_domain,
        __control_value_type.name() : __control_value_type,
        __sources.name() : __sources,
        __values.name() : __values
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'MixerDescriptor', MixerDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MixerSignalSources with content type ELEMENT_ONLY
class MixerSignalSources (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MixerSignalSources with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MixerSignalSources')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 705, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal uses Python identifier signal
    __signal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal'), 'signal', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerSignalSources_httpgrouper_ieee_orggroups17221contributionsxmlsignal', True, pyxb.utils.utility.Location('avdecc.xsd', 707, 12), )

    
    signal = property(__signal.value, __signal.set, None, None)

    _ElementMap.update({
        __signal.name() : __signal
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MixerSignalSources', MixerSignalSources)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MixerSignalSource with content type ELEMENT_ONLY
class MixerSignalSource (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MixerSignalSource with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MixerSignalSource')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 710, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 712, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 713, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_MixerSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 714, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    _ElementMap.update({
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MixerSignalSource', MixerSignalSource)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MatrixDescriptors with content type ELEMENT_ONLY
class MatrixDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MatrixDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MatrixDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 718, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}matrix uses Python identifier matrix
    __matrix = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'matrix'), 'matrix', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlmatrix', True, pyxb.utils.utility.Location('avdecc.xsd', 720, 12), )

    
    matrix = property(__matrix.value, __matrix.set, None, None)

    _ElementMap.update({
        __matrix.name() : __matrix
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MatrixDescriptors', MatrixDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MatrixDescriptor with content type ELEMENT_ONLY
class MatrixDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.25"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MatrixDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 723, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 728, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 729, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 730, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_latency uses Python identifier control_latency
    __control_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), 'control_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 731, 12), )

    
    control_latency = property(__control_latency.value, __control_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_domain uses Python identifier control_domain
    __control_domain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), 'control_domain', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_domain', False, pyxb.utils.utility.Location('avdecc.xsd', 732, 12), )

    
    control_domain = property(__control_domain.value, __control_domain.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_type uses Python identifier control_type
    __control_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_type'), 'control_type', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_type', False, pyxb.utils.utility.Location('avdecc.xsd', 733, 12), )

    
    control_type = property(__control_type.value, __control_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_value_type uses Python identifier control_value_type
    __control_value_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_value_type'), 'control_value_type', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_value_type', False, pyxb.utils.utility.Location('avdecc.xsd', 734, 12), )

    
    control_value_type = property(__control_value_type.value, __control_value_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}width uses Python identifier width
    __width = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'width'), 'width', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlwidth', False, pyxb.utils.utility.Location('avdecc.xsd', 735, 12), )

    
    width = property(__width.value, __width.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}height uses Python identifier height
    __height = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'height'), 'height', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlheight', False, pyxb.utils.utility.Location('avdecc.xsd', 736, 12), )

    
    height = property(__height.value, __height.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}values uses Python identifier values
    __values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'values'), 'values', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlvalues', False, pyxb.utils.utility.Location('avdecc.xsd', 737, 12), )

    
    values = property(__values.value, __values.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sources uses Python identifier sources
    __sources = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sources'), 'sources', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsources', False, pyxb.utils.utility.Location('avdecc.xsd', 738, 12), )

    
    sources = property(__sources.value, __sources.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 740, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 740, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __block_latency.name() : __block_latency,
        __control_latency.name() : __control_latency,
        __control_domain.name() : __control_domain,
        __control_type.name() : __control_type,
        __control_value_type.name() : __control_value_type,
        __width.name() : __width,
        __height.name() : __height,
        __values.name() : __values,
        __sources.name() : __sources
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'MatrixDescriptor', MatrixDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MatrixSignalDescriptors with content type ELEMENT_ONLY
class MatrixSignalDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MatrixSignalDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MatrixSignalDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 743, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}matrix_signal uses Python identifier matrix_signal
    __matrix_signal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'matrix_signal'), 'matrix_signal', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixSignalDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlmatrix_signal', True, pyxb.utils.utility.Location('avdecc.xsd', 745, 12), )

    
    matrix_signal = property(__matrix_signal.value, __matrix_signal.set, None, None)

    _ElementMap.update({
        __matrix_signal.name() : __matrix_signal
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MatrixSignalDescriptors', MatrixSignalDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MatrixSignalDescriptor with content type ELEMENT_ONLY
class MatrixSignalDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.26"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MatrixSignalDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 749, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signals uses Python identifier signals
    __signals = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signals'), 'signals', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixSignalDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignals', True, pyxb.utils.utility.Location('avdecc.xsd', 754, 12), )

    
    signals = property(__signals.value, __signals.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixSignalDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 756, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 756, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __signals.name() : __signals
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'MatrixSignalDescriptor', MatrixSignalDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MatrixSignalSourceContent with content type ELEMENT_ONLY
class MatrixSignalSourceContent (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MatrixSignalSourceContent with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MatrixSignalSourceContent')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 758, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal uses Python identifier signal
    __signal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal'), 'signal', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixSignalSourceContent_httpgrouper_ieee_orggroups17221contributionsxmlsignal', True, pyxb.utils.utility.Location('avdecc.xsd', 760, 12), )

    
    signal = property(__signal.value, __signal.set, None, None)

    _ElementMap.update({
        __signal.name() : __signal
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MatrixSignalSourceContent', MatrixSignalSourceContent)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MatrixSignalSource with content type ELEMENT_ONLY
class MatrixSignalSource (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}MatrixSignalSource with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'MatrixSignalSource')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 763, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 765, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 766, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_MatrixSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 767, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    _ElementMap.update({
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'MatrixSignalSource', MatrixSignalSource)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSplitterDescriptors with content type ELEMENT_ONLY
class SignalSplitterDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSplitterDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalSplitterDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 771, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_splitter uses Python identifier signal_splitter
    __signal_splitter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_splitter'), 'signal_splitter', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlsignal_splitter', True, pyxb.utils.utility.Location('avdecc.xsd', 773, 12), )

    
    signal_splitter = property(__signal_splitter.value, __signal_splitter.set, None, None)

    _ElementMap.update({
        __signal_splitter.name() : __signal_splitter
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalSplitterDescriptors', SignalSplitterDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSplitterDescriptor with content type ELEMENT_ONLY
class SignalSplitterDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.27"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalSplitterDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 776, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 781, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 782, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 783, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_latency uses Python identifier control_latency
    __control_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), 'control_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 784, 12), )

    
    control_latency = property(__control_latency.value, __control_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_domain uses Python identifier control_domain
    __control_domain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), 'control_domain', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_domain', False, pyxb.utils.utility.Location('avdecc.xsd', 785, 12), )

    
    control_domain = property(__control_domain.value, __control_domain.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 786, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 787, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 788, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}number_of_outputs uses Python identifier number_of_outputs
    __number_of_outputs = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'number_of_outputs'), 'number_of_outputs', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlnumber_of_outputs', False, pyxb.utils.utility.Location('avdecc.xsd', 789, 12), )

    
    number_of_outputs = property(__number_of_outputs.value, __number_of_outputs.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}mapping uses Python identifier mapping
    __mapping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'mapping'), 'mapping', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmapping', False, pyxb.utils.utility.Location('avdecc.xsd', 790, 12), )

    
    mapping = property(__mapping.value, __mapping.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 792, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 792, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __block_latency.name() : __block_latency,
        __control_latency.name() : __control_latency,
        __control_domain.name() : __control_domain,
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output,
        __number_of_outputs.name() : __number_of_outputs,
        __mapping.name() : __mapping
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'SignalSplitterDescriptor', SignalSplitterDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSplitterMappings with content type ELEMENT_ONLY
class SignalSplitterMappings (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSplitterMappings with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalSplitterMappings')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 794, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}splitter_mapping uses Python identifier splitter_mapping
    __splitter_mapping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'splitter_mapping'), 'splitter_mapping', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterMappings_httpgrouper_ieee_orggroups17221contributionsxmlsplitter_mapping', True, pyxb.utils.utility.Location('avdecc.xsd', 796, 12), )

    
    splitter_mapping = property(__splitter_mapping.value, __splitter_mapping.set, None, None)

    _ElementMap.update({
        __splitter_mapping.name() : __splitter_mapping
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalSplitterMappings', SignalSplitterMappings)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSplitterMapping with content type ELEMENT_ONLY
class SignalSplitterMapping (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalSplitterMapping with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalSplitterMapping')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 799, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sub_signal_start uses Python identifier sub_signal_start
    __sub_signal_start = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_start'), 'sub_signal_start', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterMapping_httpgrouper_ieee_orggroups17221contributionsxmlsub_signal_start', False, pyxb.utils.utility.Location('avdecc.xsd', 801, 12), )

    
    sub_signal_start = property(__sub_signal_start.value, __sub_signal_start.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sub_signal_count uses Python identifier sub_signal_count
    __sub_signal_count = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_count'), 'sub_signal_count', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterMapping_httpgrouper_ieee_orggroups17221contributionsxmlsub_signal_count', False, pyxb.utils.utility.Location('avdecc.xsd', 802, 12), )

    
    sub_signal_count = property(__sub_signal_count.value, __sub_signal_count.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_index uses Python identifier output_index
    __output_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_index'), 'output_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalSplitterMapping_httpgrouper_ieee_orggroups17221contributionsxmloutput_index', False, pyxb.utils.utility.Location('avdecc.xsd', 803, 12), )

    
    output_index = property(__output_index.value, __output_index.set, None, None)

    _ElementMap.update({
        __sub_signal_start.name() : __sub_signal_start,
        __sub_signal_count.name() : __sub_signal_count,
        __output_index.name() : __output_index
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalSplitterMapping', SignalSplitterMapping)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalCombinerDescriptors with content type ELEMENT_ONLY
class SignalCombinerDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalCombinerDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalCombinerDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 807, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_combiner uses Python identifier signal_combiner
    __signal_combiner = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_combiner'), 'signal_combiner', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlsignal_combiner', True, pyxb.utils.utility.Location('avdecc.xsd', 809, 12), )

    
    signal_combiner = property(__signal_combiner.value, __signal_combiner.set, None, None)

    _ElementMap.update({
        __signal_combiner.name() : __signal_combiner
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalCombinerDescriptors', SignalCombinerDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalCombinerDescriptor with content type ELEMENT_ONLY
class SignalCombinerDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.28"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalCombinerDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 812, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 817, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 818, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 819, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_latency uses Python identifier control_latency
    __control_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), 'control_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 820, 12), )

    
    control_latency = property(__control_latency.value, __control_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_domain uses Python identifier control_domain
    __control_domain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), 'control_domain', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_domain', False, pyxb.utils.utility.Location('avdecc.xsd', 821, 12), )

    
    control_domain = property(__control_domain.value, __control_domain.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sources uses Python identifier sources
    __sources = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sources'), 'sources', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsources', False, pyxb.utils.utility.Location('avdecc.xsd', 822, 12), )

    
    sources = property(__sources.value, __sources.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}mapping uses Python identifier mapping
    __mapping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'mapping'), 'mapping', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmapping', False, pyxb.utils.utility.Location('avdecc.xsd', 823, 12), )

    
    mapping = property(__mapping.value, __mapping.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 825, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 825, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __block_latency.name() : __block_latency,
        __control_latency.name() : __control_latency,
        __control_domain.name() : __control_domain,
        __sources.name() : __sources,
        __mapping.name() : __mapping
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'SignalCombinerDescriptor', SignalCombinerDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalCombinerSources with content type ELEMENT_ONLY
class SignalCombinerSources (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalCombinerSources with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalCombinerSources')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 827, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal uses Python identifier signal
    __signal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal'), 'signal', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerSources_httpgrouper_ieee_orggroups17221contributionsxmlsignal', True, pyxb.utils.utility.Location('avdecc.xsd', 829, 12), )

    
    signal = property(__signal.value, __signal.set, None, None)

    _ElementMap.update({
        __signal.name() : __signal
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalCombinerSources', SignalCombinerSources)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalCombinerSource with content type ELEMENT_ONLY
class SignalCombinerSource (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalCombinerSource with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalCombinerSource')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 832, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 834, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 835, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 836, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    _ElementMap.update({
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalCombinerSource', SignalCombinerSource)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalCombinerMappings with content type ELEMENT_ONLY
class SignalCombinerMappings (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalCombinerMappings with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalCombinerMappings')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 839, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}combiner_mapping uses Python identifier combiner_mapping
    __combiner_mapping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'combiner_mapping'), 'combiner_mapping', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerMappings_httpgrouper_ieee_orggroups17221contributionsxmlcombiner_mapping', True, pyxb.utils.utility.Location('avdecc.xsd', 841, 12), )

    
    combiner_mapping = property(__combiner_mapping.value, __combiner_mapping.set, None, None)

    _ElementMap.update({
        __combiner_mapping.name() : __combiner_mapping
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalCombinerMappings', SignalCombinerMappings)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalCombinerMapping with content type ELEMENT_ONLY
class SignalCombinerMapping (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalCombinerMapping with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalCombinerMapping')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 844, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sub_signal_start uses Python identifier sub_signal_start
    __sub_signal_start = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_start'), 'sub_signal_start', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerMapping_httpgrouper_ieee_orggroups17221contributionsxmlsub_signal_start', False, pyxb.utils.utility.Location('avdecc.xsd', 846, 12), )

    
    sub_signal_start = property(__sub_signal_start.value, __sub_signal_start.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sub_signal_count uses Python identifier sub_signal_count
    __sub_signal_count = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_count'), 'sub_signal_count', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerMapping_httpgrouper_ieee_orggroups17221contributionsxmlsub_signal_count', False, pyxb.utils.utility.Location('avdecc.xsd', 847, 12), )

    
    sub_signal_count = property(__sub_signal_count.value, __sub_signal_count.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}input_index uses Python identifier input_index
    __input_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'input_index'), 'input_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalCombinerMapping_httpgrouper_ieee_orggroups17221contributionsxmlinput_index', False, pyxb.utils.utility.Location('avdecc.xsd', 848, 12), )

    
    input_index = property(__input_index.value, __input_index.set, None, None)

    _ElementMap.update({
        __sub_signal_start.name() : __sub_signal_start,
        __sub_signal_count.name() : __sub_signal_count,
        __input_index.name() : __input_index
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalCombinerMapping', SignalCombinerMapping)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalDemultiplexerDescriptors with content type ELEMENT_ONLY
class SignalDemultiplexerDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalDemultiplexerDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalDemultiplexerDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 852, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_demultiplexer uses Python identifier signal_demultiplexer
    __signal_demultiplexer = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_demultiplexer'), 'signal_demultiplexer', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlsignal_demultiplexer', True, pyxb.utils.utility.Location('avdecc.xsd', 854, 12), )

    
    signal_demultiplexer = property(__signal_demultiplexer.value, __signal_demultiplexer.set, None, None)

    _ElementMap.update({
        __signal_demultiplexer.name() : __signal_demultiplexer
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalDemultiplexerDescriptors', SignalDemultiplexerDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalDemultiplexerDescriptor with content type ELEMENT_ONLY
class SignalDemultiplexerDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.29"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalDemultiplexerDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 857, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 862, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 863, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 864, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_latency uses Python identifier control_latency
    __control_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), 'control_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 865, 12), )

    
    control_latency = property(__control_latency.value, __control_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_domain uses Python identifier control_domain
    __control_domain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), 'control_domain', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_domain', False, pyxb.utils.utility.Location('avdecc.xsd', 866, 12), )

    
    control_domain = property(__control_domain.value, __control_domain.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 867, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 868, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 869, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}number_of_outputs uses Python identifier number_of_outputs
    __number_of_outputs = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'number_of_outputs'), 'number_of_outputs', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlnumber_of_outputs', False, pyxb.utils.utility.Location('avdecc.xsd', 870, 12), )

    
    number_of_outputs = property(__number_of_outputs.value, __number_of_outputs.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}mapping uses Python identifier mapping
    __mapping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'mapping'), 'mapping', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmapping', False, pyxb.utils.utility.Location('avdecc.xsd', 871, 12), )

    
    mapping = property(__mapping.value, __mapping.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 873, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 873, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __block_latency.name() : __block_latency,
        __control_latency.name() : __control_latency,
        __control_domain.name() : __control_domain,
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output,
        __number_of_outputs.name() : __number_of_outputs,
        __mapping.name() : __mapping
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'SignalDemultiplexerDescriptor', SignalDemultiplexerDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalDemultiplexerMappings with content type ELEMENT_ONLY
class SignalDemultiplexerMappings (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalDemultiplexerMappings with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalDemultiplexerMappings')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 875, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}demultiplexer_mapping uses Python identifier demultiplexer_mapping
    __demultiplexer_mapping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'demultiplexer_mapping'), 'demultiplexer_mapping', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerMappings_httpgrouper_ieee_orggroups17221contributionsxmldemultiplexer_mapping', True, pyxb.utils.utility.Location('avdecc.xsd', 877, 12), )

    
    demultiplexer_mapping = property(__demultiplexer_mapping.value, __demultiplexer_mapping.set, None, None)

    _ElementMap.update({
        __demultiplexer_mapping.name() : __demultiplexer_mapping
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalDemultiplexerMappings', SignalDemultiplexerMappings)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalDemultiplexerMapping with content type ELEMENT_ONLY
class SignalDemultiplexerMapping (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalDemultiplexerMapping with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalDemultiplexerMapping')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 880, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sub_signal_start uses Python identifier sub_signal_start
    __sub_signal_start = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_start'), 'sub_signal_start', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerMapping_httpgrouper_ieee_orggroups17221contributionsxmlsub_signal_start', False, pyxb.utils.utility.Location('avdecc.xsd', 882, 12), )

    
    sub_signal_start = property(__sub_signal_start.value, __sub_signal_start.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sub_signal_count uses Python identifier sub_signal_count
    __sub_signal_count = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_count'), 'sub_signal_count', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerMapping_httpgrouper_ieee_orggroups17221contributionsxmlsub_signal_count', False, pyxb.utils.utility.Location('avdecc.xsd', 883, 12), )

    
    sub_signal_count = property(__sub_signal_count.value, __sub_signal_count.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}output_index uses Python identifier output_index
    __output_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'output_index'), 'output_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalDemultiplexerMapping_httpgrouper_ieee_orggroups17221contributionsxmloutput_index', False, pyxb.utils.utility.Location('avdecc.xsd', 884, 12), )

    
    output_index = property(__output_index.value, __output_index.set, None, None)

    _ElementMap.update({
        __sub_signal_start.name() : __sub_signal_start,
        __sub_signal_count.name() : __sub_signal_count,
        __output_index.name() : __output_index
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalDemultiplexerMapping', SignalDemultiplexerMapping)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalMultiplexerDescriptors with content type ELEMENT_ONLY
class SignalMultiplexerDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalMultiplexerDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalMultiplexerDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 888, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_multiplexer uses Python identifier signal_multiplexer
    __signal_multiplexer = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_multiplexer'), 'signal_multiplexer', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlsignal_multiplexer', True, pyxb.utils.utility.Location('avdecc.xsd', 890, 12), )

    
    signal_multiplexer = property(__signal_multiplexer.value, __signal_multiplexer.set, None, None)

    _ElementMap.update({
        __signal_multiplexer.name() : __signal_multiplexer
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalMultiplexerDescriptors', SignalMultiplexerDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalMultiplexerDescriptor with content type ELEMENT_ONLY
class SignalMultiplexerDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.30"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalMultiplexerDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 893, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 898, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 899, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 900, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_latency uses Python identifier control_latency
    __control_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), 'control_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 901, 12), )

    
    control_latency = property(__control_latency.value, __control_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_domain uses Python identifier control_domain
    __control_domain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), 'control_domain', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_domain', False, pyxb.utils.utility.Location('avdecc.xsd', 902, 12), )

    
    control_domain = property(__control_domain.value, __control_domain.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sources uses Python identifier sources
    __sources = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sources'), 'sources', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsources', False, pyxb.utils.utility.Location('avdecc.xsd', 903, 12), )

    
    sources = property(__sources.value, __sources.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}mapping uses Python identifier mapping
    __mapping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'mapping'), 'mapping', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlmapping', False, pyxb.utils.utility.Location('avdecc.xsd', 904, 12), )

    
    mapping = property(__mapping.value, __mapping.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 906, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 906, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __block_latency.name() : __block_latency,
        __control_latency.name() : __control_latency,
        __control_domain.name() : __control_domain,
        __sources.name() : __sources,
        __mapping.name() : __mapping
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'SignalMultiplexerDescriptor', SignalMultiplexerDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalMultiplexerSignalSources with content type ELEMENT_ONLY
class SignalMultiplexerSignalSources (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalMultiplexerSignalSources with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalMultiplexerSignalSources')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 908, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal uses Python identifier signal
    __signal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal'), 'signal', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerSignalSources_httpgrouper_ieee_orggroups17221contributionsxmlsignal', True, pyxb.utils.utility.Location('avdecc.xsd', 910, 12), )

    
    signal = property(__signal.value, __signal.set, None, None)

    _ElementMap.update({
        __signal.name() : __signal
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalMultiplexerSignalSources', SignalMultiplexerSignalSources)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalMultiplexerSignalSource with content type ELEMENT_ONLY
class SignalMultiplexerSignalSource (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalMultiplexerSignalSource with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalMultiplexerSignalSource')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 913, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 915, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 916, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerSignalSource_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 917, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    _ElementMap.update({
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalMultiplexerSignalSource', SignalMultiplexerSignalSource)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalMultiplexerSignalSourceMappings with content type ELEMENT_ONLY
class SignalMultiplexerSignalSourceMappings (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalMultiplexerSignalSourceMappings with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalMultiplexerSignalSourceMappings')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 920, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal uses Python identifier signal
    __signal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal'), 'signal', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalMultiplexerSignalSourceMappings_httpgrouper_ieee_orggroups17221contributionsxmlsignal', True, pyxb.utils.utility.Location('avdecc.xsd', 922, 12), )

    
    signal = property(__signal.value, __signal.set, None, None)

    _ElementMap.update({
        __signal.name() : __signal
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalMultiplexerSignalSourceMappings', SignalMultiplexerSignalSourceMappings)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalTranscoderDescriptors with content type ELEMENT_ONLY
class SignalTranscoderDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalTranscoderDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalTranscoderDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 926, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_transcoder uses Python identifier signal_transcoder
    __signal_transcoder = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_transcoder'), 'signal_transcoder', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlsignal_transcoder', True, pyxb.utils.utility.Location('avdecc.xsd', 928, 12), )

    
    signal_transcoder = property(__signal_transcoder.value, __signal_transcoder.set, None, None)

    _ElementMap.update({
        __signal_transcoder.name() : __signal_transcoder
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignalTranscoderDescriptors', SignalTranscoderDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignalTranscoderDescriptor with content type ELEMENT_ONLY
class SignalTranscoderDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.31"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignalTranscoderDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 931, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 936, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 937, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}block_latency uses Python identifier block_latency
    __block_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), 'block_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlblock_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 938, 12), )

    
    block_latency = property(__block_latency.value, __block_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_latency uses Python identifier control_latency
    __control_latency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), 'control_latency', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_latency', False, pyxb.utils.utility.Location('avdecc.xsd', 939, 12), )

    
    control_latency = property(__control_latency.value, __control_latency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_domain uses Python identifier control_domain
    __control_domain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), 'control_domain', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_domain', False, pyxb.utils.utility.Location('avdecc.xsd', 940, 12), )

    
    control_domain = property(__control_domain.value, __control_domain.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_value_type uses Python identifier control_value_type
    __control_value_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_value_type'), 'control_value_type', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_value_type', False, pyxb.utils.utility.Location('avdecc.xsd', 941, 12), )

    
    control_value_type = property(__control_value_type.value, __control_value_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_type uses Python identifier signal_type
    __signal_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), 'signal_type', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_type', False, pyxb.utils.utility.Location('avdecc.xsd', 942, 12), )

    
    signal_type = property(__signal_type.value, __signal_type.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_index uses Python identifier signal_index
    __signal_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), 'signal_index', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_index', False, pyxb.utils.utility.Location('avdecc.xsd', 943, 12), )

    
    signal_index = property(__signal_index.value, __signal_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}signal_output uses Python identifier signal_output
    __signal_output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), 'signal_output', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlsignal_output', False, pyxb.utils.utility.Location('avdecc.xsd', 944, 12), )

    
    signal_output = property(__signal_output.value, __signal_output.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}values uses Python identifier values
    __values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'values'), 'values', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlvalues', False, pyxb.utils.utility.Location('avdecc.xsd', 945, 12), )

    
    values = property(__values.value, __values.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_SignalTranscoderDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 947, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 947, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __block_latency.name() : __block_latency,
        __control_latency.name() : __control_latency,
        __control_domain.name() : __control_domain,
        __control_value_type.name() : __control_value_type,
        __signal_type.name() : __signal_type,
        __signal_index.name() : __signal_index,
        __signal_output.name() : __signal_output,
        __values.name() : __values
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'SignalTranscoderDescriptor', SignalTranscoderDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ClockDomainDescriptors with content type ELEMENT_ONLY
class ClockDomainDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ClockDomainDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ClockDomainDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 950, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_domain uses Python identifier clock_domain
    __clock_domain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_domain'), 'clock_domain', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockDomainDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlclock_domain', True, pyxb.utils.utility.Location('avdecc.xsd', 952, 12), )

    
    clock_domain = property(__clock_domain.value, __clock_domain.set, None, None)

    _ElementMap.update({
        __clock_domain.name() : __clock_domain
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ClockDomainDescriptors', ClockDomainDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ClockDomainDescriptor with content type ELEMENT_ONLY
class ClockDomainDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.32"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ClockDomainDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 955, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockDomainDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 960, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockDomainDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 961, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_source_index uses Python identifier clock_source_index
    __clock_source_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_source_index'), 'clock_source_index', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockDomainDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_source_index', False, pyxb.utils.utility.Location('avdecc.xsd', 962, 12), )

    
    clock_source_index = property(__clock_source_index.value, __clock_source_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_sources uses Python identifier clock_sources
    __clock_sources = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_sources'), 'clock_sources', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockDomainDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlclock_sources', False, pyxb.utils.utility.Location('avdecc.xsd', 963, 12), )

    
    clock_sources = property(__clock_sources.value, __clock_sources.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockDomainDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 965, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 965, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __clock_source_index.name() : __clock_source_index,
        __clock_sources.name() : __clock_sources
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'ClockDomainDescriptor', ClockDomainDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ClockSourceIndexes with content type ELEMENT_ONLY
class ClockSourceIndexes (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ClockSourceIndexes with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ClockSourceIndexes')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 967, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}clock_source_index uses Python identifier clock_source_index
    __clock_source_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'clock_source_index'), 'clock_source_index', '__httpgrouper_ieee_orggroups17221contributionsxml_ClockSourceIndexes_httpgrouper_ieee_orggroups17221contributionsxmlclock_source_index', True, pyxb.utils.utility.Location('avdecc.xsd', 969, 12), )

    
    clock_source_index = property(__clock_source_index.value, __clock_source_index.set, None, None)

    _ElementMap.update({
        __clock_source_index.name() : __clock_source_index
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ClockSourceIndexes', ClockSourceIndexes)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ControlBlockDescriptors with content type ELEMENT_ONLY
class ControlBlockDescriptors (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ControlBlockDescriptors with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ControlBlockDescriptors')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 973, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}control_block uses Python identifier control_block
    __control_block = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'control_block'), 'control_block', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlBlockDescriptors_httpgrouper_ieee_orggroups17221contributionsxmlcontrol_block', True, pyxb.utils.utility.Location('avdecc.xsd', 975, 12), )

    
    control_block = property(__control_block.value, __control_block.set, None, None)

    _ElementMap.update({
        __control_block.name() : __control_block
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'ControlBlockDescriptors', ControlBlockDescriptors)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}ControlBlockDescriptor with content type ELEMENT_ONLY
class ControlBlockDescriptor (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.2.33"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'ControlBlockDescriptor')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 978, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}object_name uses Python identifier object_name
    __object_name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'object_name'), 'object_name', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlBlockDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlobject_name', False, pyxb.utils.utility.Location('avdecc.xsd', 983, 12), )

    
    object_name = property(__object_name.value, __object_name.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_description uses Python identifier localized_description
    __localized_description = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), 'localized_description', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlBlockDescriptor_httpgrouper_ieee_orggroups17221contributionsxmllocalized_description', False, pyxb.utils.utility.Location('avdecc.xsd', 984, 12), )

    
    localized_description = property(__localized_description.value, __localized_description.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}final_control_index uses Python identifier final_control_index
    __final_control_index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'final_control_index'), 'final_control_index', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlBlockDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlfinal_control_index', False, pyxb.utils.utility.Location('avdecc.xsd', 985, 12), )

    
    final_control_index = property(__final_control_index.value, __final_control_index.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}controls uses Python identifier controls
    __controls = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'controls'), 'controls', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlBlockDescriptor_httpgrouper_ieee_orggroups17221contributionsxmlcontrols', True, pyxb.utils.utility.Location('avdecc.xsd', 986, 12), )

    
    controls = property(__controls.value, __controls.set, None, None)

    
    # Attribute symbol uses Python identifier symbol
    __symbol = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'symbol'), 'symbol', '__httpgrouper_ieee_orggroups17221contributionsxml_ControlBlockDescriptor_symbol', pyxb.binding.datatypes.string)
    __symbol._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 988, 8)
    __symbol._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 988, 8)
    
    symbol = property(__symbol.value, __symbol.set, None, None)

    _ElementMap.update({
        __object_name.name() : __object_name,
        __localized_description.name() : __localized_description,
        __final_control_index.name() : __final_control_index,
        __controls.name() : __controls
    })
    _AttributeMap.update({
        __symbol.name() : __symbol
    })
Namespace.addCategoryObject('typeBinding', u'ControlBlockDescriptor', ControlBlockDescriptor)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}Value with content type EMPTY
class Value (pyxb.binding.basis.complexTypeDefinition):
    """See IEEE Std 1722.1-2013 Clause 7.3.5"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Value')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 993, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'Value', Value)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}StreamFormats with content type ELEMENT_ONLY
class StreamFormats (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}StreamFormats with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'StreamFormats')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1753, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}stream_format uses Python identifier stream_format
    __stream_format = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'stream_format'), 'stream_format', '__httpgrouper_ieee_orggroups17221contributionsxml_StreamFormats_httpgrouper_ieee_orggroups17221contributionsxmlstream_format', True, pyxb.utils.utility.Location('avdecc.xsd', 1755, 12), )

    
    stream_format = property(__stream_format.value, __stream_format.set, None, None)

    _ElementMap.update({
        __stream_format.name() : __stream_format
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'StreamFormats', StreamFormats)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AspectRatio with content type ELEMENT_ONLY
class AspectRatio (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}AspectRatio with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'AspectRatio')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1759, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}pixel_width uses Python identifier pixel_width
    __pixel_width = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'pixel_width'), 'pixel_width', '__httpgrouper_ieee_orggroups17221contributionsxml_AspectRatio_httpgrouper_ieee_orggroups17221contributionsxmlpixel_width', False, pyxb.utils.utility.Location('avdecc.xsd', 1761, 12), )

    
    pixel_width = property(__pixel_width.value, __pixel_width.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}pixel_height uses Python identifier pixel_height
    __pixel_height = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'pixel_height'), 'pixel_height', '__httpgrouper_ieee_orggroups17221contributionsxml_AspectRatio_httpgrouper_ieee_orggroups17221contributionsxmlpixel_height', False, pyxb.utils.utility.Location('avdecc.xsd', 1762, 12), )

    
    pixel_height = property(__pixel_height.value, __pixel_height.set, None, None)

    _ElementMap.update({
        __pixel_width.name() : __pixel_width,
        __pixel_height.name() : __pixel_height
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'AspectRatio', AspectRatio)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}LocalizedStringContainer with content type ELEMENT_ONLY
class LocalizedStringContainer (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}LocalizedStringContainer with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LocalizedStringContainer')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1766, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}localized_string uses Python identifier localized_string
    __localized_string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'localized_string'), 'localized_string', '__httpgrouper_ieee_orggroups17221contributionsxml_LocalizedStringContainer_httpgrouper_ieee_orggroups17221contributionsxmllocalized_string', False, pyxb.utils.utility.Location('avdecc.xsd', 1768, 12), )

    
    localized_string = property(__localized_string.value, __localized_string.set, None, None)

    _ElementMap.update({
        __localized_string.name() : __localized_string
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LocalizedStringContainer', LocalizedStringContainer)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}LocalizedString with content type ELEMENT_ONLY
class LocalizedString (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}LocalizedString with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LocalizedString')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1772, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}offset uses Python identifier offset
    __offset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'offset'), 'offset', '__httpgrouper_ieee_orggroups17221contributionsxml_LocalizedString_httpgrouper_ieee_orggroups17221contributionsxmloffset', False, pyxb.utils.utility.Location('avdecc.xsd', 1774, 12), )

    
    offset = property(__offset.value, __offset.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}index uses Python identifier index
    __index = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'index'), 'index', '__httpgrouper_ieee_orggroups17221contributionsxml_LocalizedString_httpgrouper_ieee_orggroups17221contributionsxmlindex', False, pyxb.utils.utility.Location('avdecc.xsd', 1775, 12), )

    
    index = property(__index.value, __index.set, None, None)

    _ElementMap.update({
        __offset.name() : __offset,
        __index.name() : __index
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LocalizedString', LocalizedString)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoSize with content type ELEMENT_ONLY
class VideoSize (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}VideoSize with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'VideoSize')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1779, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}frame_width uses Python identifier frame_width
    __frame_width = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'frame_width'), 'frame_width', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoSize_httpgrouper_ieee_orggroups17221contributionsxmlframe_width', False, pyxb.utils.utility.Location('avdecc.xsd', 1781, 12), )

    
    frame_width = property(__frame_width.value, __frame_width.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}frame_height uses Python identifier frame_height
    __frame_height = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'frame_height'), 'frame_height', '__httpgrouper_ieee_orggroups17221contributionsxml_VideoSize_httpgrouper_ieee_orggroups17221contributionsxmlframe_height', False, pyxb.utils.utility.Location('avdecc.xsd', 1782, 12), )

    
    frame_height = property(__frame_height.value, __frame_height.set, None, None)

    _ElementMap.update({
        __frame_width.name() : __frame_width,
        __frame_height.name() : __frame_height
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'VideoSize', VideoSize)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}BodePlot with content type ELEMENT_ONLY
class BodePlot (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}BodePlot with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BodePlot')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1786, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}frequency uses Python identifier frequency
    __frequency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'frequency'), 'frequency', '__httpgrouper_ieee_orggroups17221contributionsxml_BodePlot_httpgrouper_ieee_orggroups17221contributionsxmlfrequency', False, pyxb.utils.utility.Location('avdecc.xsd', 1788, 12), )

    
    frequency = property(__frequency.value, __frequency.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}magnitude uses Python identifier magnitude
    __magnitude = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'magnitude'), 'magnitude', '__httpgrouper_ieee_orggroups17221contributionsxml_BodePlot_httpgrouper_ieee_orggroups17221contributionsxmlmagnitude', False, pyxb.utils.utility.Location('avdecc.xsd', 1789, 12), )

    
    magnitude = property(__magnitude.value, __magnitude.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}phase uses Python identifier phase
    __phase = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'phase'), 'phase', '__httpgrouper_ieee_orggroups17221contributionsxml_BodePlot_httpgrouper_ieee_orggroups17221contributionsxmlphase', False, pyxb.utils.utility.Location('avdecc.xsd', 1790, 12), )

    
    phase = property(__phase.value, __phase.set, None, None)

    _ElementMap.update({
        __frequency.name() : __frequency,
        __magnitude.name() : __magnitude,
        __phase.name() : __phase
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'BodePlot', BodePlot)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}BodePlotPoint with content type ELEMENT_ONLY
class BodePlotPoint (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}BodePlotPoint with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BodePlotPoint')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1793, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}bode_plot uses Python identifier bode_plot
    __bode_plot = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'bode_plot'), 'bode_plot', '__httpgrouper_ieee_orggroups17221contributionsxml_BodePlotPoint_httpgrouper_ieee_orggroups17221contributionsxmlbode_plot', False, pyxb.utils.utility.Location('avdecc.xsd', 1795, 12), )

    
    bode_plot = property(__bode_plot.value, __bode_plot.set, None, None)

    _ElementMap.update({
        __bode_plot.name() : __bode_plot
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'BodePlotPoint', BodePlotPoint)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}BodePlotList with content type ELEMENT_ONLY
class BodePlotList (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}BodePlotList with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'BodePlotList')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1798, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}bode_plot uses Python identifier bode_plot
    __bode_plot = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'bode_plot'), 'bode_plot', '__httpgrouper_ieee_orggroups17221contributionsxml_BodePlotList_httpgrouper_ieee_orggroups17221contributionsxmlbode_plot', True, pyxb.utils.utility.Location('avdecc.xsd', 1800, 12), )

    
    bode_plot = property(__bode_plot.value, __bode_plot.set, None, None)

    _ElementMap.update({
        __bode_plot.name() : __bode_plot
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'BodePlotList', BodePlotList)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SamplingRates with content type ELEMENT_ONLY
class SamplingRates (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SamplingRates with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SamplingRates')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1804, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}sampling_rate uses Python identifier sampling_rate
    __sampling_rate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'sampling_rate'), 'sampling_rate', '__httpgrouper_ieee_orggroups17221contributionsxml_SamplingRates_httpgrouper_ieee_orggroups17221contributionsxmlsampling_rate', True, pyxb.utils.utility.Location('avdecc.xsd', 1806, 12), )

    
    sampling_rate = property(__sampling_rate.value, __sampling_rate.set, None, None)

    _ElementMap.update({
        __sampling_rate.name() : __sampling_rate
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SamplingRates', SamplingRates)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SamplingRate with content type ELEMENT_ONLY
class SamplingRate (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SamplingRate with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SamplingRate')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1809, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}pull uses Python identifier pull
    __pull = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'pull'), 'pull', '__httpgrouper_ieee_orggroups17221contributionsxml_SamplingRate_httpgrouper_ieee_orggroups17221contributionsxmlpull', False, pyxb.utils.utility.Location('avdecc.xsd', 1811, 12), )

    
    pull = property(__pull.value, __pull.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}base_frequency uses Python identifier base_frequency
    __base_frequency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'base_frequency'), 'base_frequency', '__httpgrouper_ieee_orggroups17221contributionsxml_SamplingRate_httpgrouper_ieee_orggroups17221contributionsxmlbase_frequency', False, pyxb.utils.utility.Location('avdecc.xsd', 1812, 12), )

    
    base_frequency = property(__base_frequency.value, __base_frequency.set, None, None)

    _ElementMap.update({
        __pull.name() : __pull,
        __base_frequency.name() : __base_frequency
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SamplingRate', SamplingRate)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}Values with content type ELEMENT_ONLY
class Values (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}Values with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'Values')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1816, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}value uses Python identifier value_
    __value = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'value'), 'value_', '__httpgrouper_ieee_orggroups17221contributionsxml_Values_httpgrouper_ieee_orggroups17221contributionsxmlvalue', True, pyxb.utils.utility.Location('avdecc.xsd', 1818, 12), )

    
    value_ = property(__value.value, __value.set, None, None)

    _ElementMap.update({
        __value.name() : __value
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'Values', Values)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignedOctetOptions with content type ELEMENT_ONLY
class SignedOctetOptions (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignedOctetOptions with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignedOctetOptions')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1823, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'option'), 'option', '__httpgrouper_ieee_orggroups17221contributionsxml_SignedOctetOptions_httpgrouper_ieee_orggroups17221contributionsxmloption', True, pyxb.utils.utility.Location('avdecc.xsd', 1825, 12), )

    
    option = property(__option.value, __option.set, None, None)

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignedOctetOptions', SignedOctetOptions)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}UnsignedOctetOptions with content type ELEMENT_ONLY
class UnsignedOctetOptions (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}UnsignedOctetOptions with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UnsignedOctetOptions')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1828, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'option'), 'option', '__httpgrouper_ieee_orggroups17221contributionsxml_UnsignedOctetOptions_httpgrouper_ieee_orggroups17221contributionsxmloption', True, pyxb.utils.utility.Location('avdecc.xsd', 1830, 12), )

    
    option = property(__option.value, __option.set, None, None)

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'UnsignedOctetOptions', UnsignedOctetOptions)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignedDoubletOptions with content type ELEMENT_ONLY
class SignedDoubletOptions (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignedDoubletOptions with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignedDoubletOptions')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1833, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'option'), 'option', '__httpgrouper_ieee_orggroups17221contributionsxml_SignedDoubletOptions_httpgrouper_ieee_orggroups17221contributionsxmloption', True, pyxb.utils.utility.Location('avdecc.xsd', 1835, 12), )

    
    option = property(__option.value, __option.set, None, None)

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignedDoubletOptions', SignedDoubletOptions)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}UnsignedDoubletOptions with content type ELEMENT_ONLY
class UnsignedDoubletOptions (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}UnsignedDoubletOptions with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UnsignedDoubletOptions')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1838, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'option'), 'option', '__httpgrouper_ieee_orggroups17221contributionsxml_UnsignedDoubletOptions_httpgrouper_ieee_orggroups17221contributionsxmloption', True, pyxb.utils.utility.Location('avdecc.xsd', 1840, 12), )

    
    option = property(__option.value, __option.set, None, None)

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'UnsignedDoubletOptions', UnsignedDoubletOptions)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignedQuadletOptions with content type ELEMENT_ONLY
class SignedQuadletOptions (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignedQuadletOptions with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignedQuadletOptions')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1843, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'option'), 'option', '__httpgrouper_ieee_orggroups17221contributionsxml_SignedQuadletOptions_httpgrouper_ieee_orggroups17221contributionsxmloption', True, pyxb.utils.utility.Location('avdecc.xsd', 1845, 12), )

    
    option = property(__option.value, __option.set, None, None)

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignedQuadletOptions', SignedQuadletOptions)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}UnsignedQuadletOptions with content type ELEMENT_ONLY
class UnsignedQuadletOptions (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}UnsignedQuadletOptions with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UnsignedQuadletOptions')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1848, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'option'), 'option', '__httpgrouper_ieee_orggroups17221contributionsxml_UnsignedQuadletOptions_httpgrouper_ieee_orggroups17221contributionsxmloption', True, pyxb.utils.utility.Location('avdecc.xsd', 1850, 12), )

    
    option = property(__option.value, __option.set, None, None)

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'UnsignedQuadletOptions', UnsignedQuadletOptions)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignedOctletOptions with content type ELEMENT_ONLY
class SignedOctletOptions (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}SignedOctletOptions with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'SignedOctletOptions')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1853, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'option'), 'option', '__httpgrouper_ieee_orggroups17221contributionsxml_SignedOctletOptions_httpgrouper_ieee_orggroups17221contributionsxmloption', True, pyxb.utils.utility.Location('avdecc.xsd', 1855, 12), )

    
    option = property(__option.value, __option.set, None, None)

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'SignedOctletOptions', SignedOctletOptions)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}UnsignedOctletOptions with content type ELEMENT_ONLY
class UnsignedOctletOptions (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}UnsignedOctletOptions with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'UnsignedOctletOptions')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1858, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'option'), 'option', '__httpgrouper_ieee_orggroups17221contributionsxml_UnsignedOctletOptions_httpgrouper_ieee_orggroups17221contributionsxmloption', True, pyxb.utils.utility.Location('avdecc.xsd', 1860, 12), )

    
    option = property(__option.value, __option.set, None, None)

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'UnsignedOctletOptions', UnsignedOctletOptions)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}FloatOptions with content type ELEMENT_ONLY
class FloatOptions (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}FloatOptions with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'FloatOptions')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1863, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'option'), 'option', '__httpgrouper_ieee_orggroups17221contributionsxml_FloatOptions_httpgrouper_ieee_orggroups17221contributionsxmloption', True, pyxb.utils.utility.Location('avdecc.xsd', 1865, 12), )

    
    option = property(__option.value, __option.set, None, None)

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'FloatOptions', FloatOptions)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}DoubleOptions with content type ELEMENT_ONLY
class DoubleOptions (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}DoubleOptions with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'DoubleOptions')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1868, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'option'), 'option', '__httpgrouper_ieee_orggroups17221contributionsxml_DoubleOptions_httpgrouper_ieee_orggroups17221contributionsxmloption', True, pyxb.utils.utility.Location('avdecc.xsd', 1870, 12), )

    
    option = property(__option.value, __option.set, None, None)

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'DoubleOptions', DoubleOptions)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}LocalizedStringContainerOptions with content type ELEMENT_ONLY
class LocalizedStringContainerOptions (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}LocalizedStringContainerOptions with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'LocalizedStringContainerOptions')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1873, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}option uses Python identifier option
    __option = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'option'), 'option', '__httpgrouper_ieee_orggroups17221contributionsxml_LocalizedStringContainerOptions_httpgrouper_ieee_orggroups17221contributionsxmloption', True, pyxb.utils.utility.Location('avdecc.xsd', 1875, 12), )

    
    option = property(__option.value, __option.set, None, None)

    _ElementMap.update({
        __option.name() : __option
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'LocalizedStringContainerOptions', LocalizedStringContainerOptions)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentSignedOctets with content type ELEMENT_ONLY
class CurrentSignedOctets (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentSignedOctets with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurrentSignedOctets')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1879, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_CurrentSignedOctets_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', True, pyxb.utils.utility.Location('avdecc.xsd', 1881, 12), )

    
    current = property(__current.value, __current.set, None, None)

    _ElementMap.update({
        __current.name() : __current
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurrentSignedOctets', CurrentSignedOctets)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentUnsignedOctets with content type ELEMENT_ONLY
class CurrentUnsignedOctets (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentUnsignedOctets with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurrentUnsignedOctets')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1884, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_CurrentUnsignedOctets_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', True, pyxb.utils.utility.Location('avdecc.xsd', 1886, 12), )

    
    current = property(__current.value, __current.set, None, None)

    _ElementMap.update({
        __current.name() : __current
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurrentUnsignedOctets', CurrentUnsignedOctets)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentSignedDoublets with content type ELEMENT_ONLY
class CurrentSignedDoublets (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentSignedDoublets with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurrentSignedDoublets')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1889, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_CurrentSignedDoublets_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', True, pyxb.utils.utility.Location('avdecc.xsd', 1891, 12), )

    
    current = property(__current.value, __current.set, None, None)

    _ElementMap.update({
        __current.name() : __current
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurrentSignedDoublets', CurrentSignedDoublets)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentUnsignedDoublets with content type ELEMENT_ONLY
class CurrentUnsignedDoublets (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentUnsignedDoublets with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurrentUnsignedDoublets')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1894, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_CurrentUnsignedDoublets_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', True, pyxb.utils.utility.Location('avdecc.xsd', 1896, 12), )

    
    current = property(__current.value, __current.set, None, None)

    _ElementMap.update({
        __current.name() : __current
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurrentUnsignedDoublets', CurrentUnsignedDoublets)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentSignedQuadlets with content type ELEMENT_ONLY
class CurrentSignedQuadlets (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentSignedQuadlets with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurrentSignedQuadlets')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1899, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_CurrentSignedQuadlets_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', True, pyxb.utils.utility.Location('avdecc.xsd', 1901, 12), )

    
    current = property(__current.value, __current.set, None, None)

    _ElementMap.update({
        __current.name() : __current
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurrentSignedQuadlets', CurrentSignedQuadlets)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentUnsignedQuadlets with content type ELEMENT_ONLY
class CurrentUnsignedQuadlets (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentUnsignedQuadlets with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurrentUnsignedQuadlets')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1904, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_CurrentUnsignedQuadlets_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', True, pyxb.utils.utility.Location('avdecc.xsd', 1906, 12), )

    
    current = property(__current.value, __current.set, None, None)

    _ElementMap.update({
        __current.name() : __current
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurrentUnsignedQuadlets', CurrentUnsignedQuadlets)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentSignedOctlets with content type ELEMENT_ONLY
class CurrentSignedOctlets (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentSignedOctlets with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurrentSignedOctlets')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1909, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_CurrentSignedOctlets_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', True, pyxb.utils.utility.Location('avdecc.xsd', 1911, 12), )

    
    current = property(__current.value, __current.set, None, None)

    _ElementMap.update({
        __current.name() : __current
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurrentSignedOctlets', CurrentSignedOctlets)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentUnsignedOctlets with content type ELEMENT_ONLY
class CurrentUnsignedOctlets (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentUnsignedOctlets with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurrentUnsignedOctlets')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1914, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_CurrentUnsignedOctlets_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', True, pyxb.utils.utility.Location('avdecc.xsd', 1916, 12), )

    
    current = property(__current.value, __current.set, None, None)

    _ElementMap.update({
        __current.name() : __current
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurrentUnsignedOctlets', CurrentUnsignedOctlets)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentFloats with content type ELEMENT_ONLY
class CurrentFloats (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentFloats with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurrentFloats')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1919, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_CurrentFloats_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', True, pyxb.utils.utility.Location('avdecc.xsd', 1921, 12), )

    
    current = property(__current.value, __current.set, None, None)

    _ElementMap.update({
        __current.name() : __current
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurrentFloats', CurrentFloats)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentDoubles with content type ELEMENT_ONLY
class CurrentDoubles (pyxb.binding.basis.complexTypeDefinition):
    """Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}CurrentDoubles with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'CurrentDoubles')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1924, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_CurrentDoubles_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', True, pyxb.utils.utility.Location('avdecc.xsd', 1926, 12), )

    
    current = property(__current.value, __current.set, None, None)

    _ElementMap.update({
        __current.name() : __current
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'CurrentDoubles', CurrentDoubles)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0000 with content type ELEMENT_ONLY
class T0000 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.1 - CONTROL_LINEAR_INT8"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0000')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 999, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}string uses Python identifier string
    __string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'string'), 'string', '__httpgrouper_ieee_orggroups17221contributionsxml_T0000_httpgrouper_ieee_orggroups17221contributionsxmlstring', False, pyxb.utils.utility.Location('avdecc.xsd', 1006, 20), )

    
    string = property(__string.value, __string.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0000_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1007, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0000_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1008, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0000_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1009, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0000_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1010, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0000_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1011, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0000_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1012, 20), )

    
    default = property(__default.value, __default.set, None, None)

    _ElementMap.update({
        __string.name() : __string,
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __current.name() : __current,
        __default.name() : __default
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0000', T0000)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0001 with content type ELEMENT_ONLY
class T0001 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.1 - CONTROL_LINEAR_UINT8"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0001')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1018, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}string uses Python identifier string
    __string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'string'), 'string', '__httpgrouper_ieee_orggroups17221contributionsxml_T0001_httpgrouper_ieee_orggroups17221contributionsxmlstring', False, pyxb.utils.utility.Location('avdecc.xsd', 1025, 20), )

    
    string = property(__string.value, __string.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0001_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1026, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0001_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1027, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0001_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1028, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0001_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1029, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0001_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1030, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0001_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1031, 20), )

    
    default = property(__default.value, __default.set, None, None)

    _ElementMap.update({
        __string.name() : __string,
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __current.name() : __current,
        __default.name() : __default
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0001', T0001)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0002 with content type ELEMENT_ONLY
class T0002 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.1 - CONTROL_LINEAR_INT16"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0002')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1037, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}string uses Python identifier string
    __string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'string'), 'string', '__httpgrouper_ieee_orggroups17221contributionsxml_T0002_httpgrouper_ieee_orggroups17221contributionsxmlstring', False, pyxb.utils.utility.Location('avdecc.xsd', 1044, 20), )

    
    string = property(__string.value, __string.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0002_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1045, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0002_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1046, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0002_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1047, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0002_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1048, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0002_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1049, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0002_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1050, 20), )

    
    default = property(__default.value, __default.set, None, None)

    _ElementMap.update({
        __string.name() : __string,
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __current.name() : __current,
        __default.name() : __default
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0002', T0002)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0003 with content type ELEMENT_ONLY
class T0003 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.1 - CONTROL_LINEAR_UINT16"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0003')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1056, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}string uses Python identifier string
    __string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'string'), 'string', '__httpgrouper_ieee_orggroups17221contributionsxml_T0003_httpgrouper_ieee_orggroups17221contributionsxmlstring', False, pyxb.utils.utility.Location('avdecc.xsd', 1063, 20), )

    
    string = property(__string.value, __string.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0003_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1064, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0003_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1065, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0003_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1066, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0003_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1067, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0003_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1068, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0003_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1069, 20), )

    
    default = property(__default.value, __default.set, None, None)

    _ElementMap.update({
        __string.name() : __string,
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __current.name() : __current,
        __default.name() : __default
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0003', T0003)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0004 with content type ELEMENT_ONLY
class T0004 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.1 - CONTROL_LINEAR_INT32"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0004')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1075, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}string uses Python identifier string
    __string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'string'), 'string', '__httpgrouper_ieee_orggroups17221contributionsxml_T0004_httpgrouper_ieee_orggroups17221contributionsxmlstring', False, pyxb.utils.utility.Location('avdecc.xsd', 1082, 20), )

    
    string = property(__string.value, __string.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0004_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1083, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0004_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1084, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0004_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1085, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0004_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1086, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0004_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1087, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0004_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1088, 20), )

    
    default = property(__default.value, __default.set, None, None)

    _ElementMap.update({
        __string.name() : __string,
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __current.name() : __current,
        __default.name() : __default
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0004', T0004)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0005 with content type ELEMENT_ONLY
class T0005 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.1 - CONTROL_LINEAR_UINT32"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0005')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1094, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}string uses Python identifier string
    __string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'string'), 'string', '__httpgrouper_ieee_orggroups17221contributionsxml_T0005_httpgrouper_ieee_orggroups17221contributionsxmlstring', False, pyxb.utils.utility.Location('avdecc.xsd', 1101, 20), )

    
    string = property(__string.value, __string.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0005_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1102, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0005_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1103, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0005_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1104, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0005_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1105, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0005_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1106, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0005_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1107, 20), )

    
    default = property(__default.value, __default.set, None, None)

    _ElementMap.update({
        __string.name() : __string,
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __current.name() : __current,
        __default.name() : __default
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0005', T0005)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0006 with content type ELEMENT_ONLY
class T0006 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.1 - CONTROL_LINEAR_INT64"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0006')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1113, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}string uses Python identifier string
    __string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'string'), 'string', '__httpgrouper_ieee_orggroups17221contributionsxml_T0006_httpgrouper_ieee_orggroups17221contributionsxmlstring', False, pyxb.utils.utility.Location('avdecc.xsd', 1120, 20), )

    
    string = property(__string.value, __string.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0006_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1121, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0006_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1122, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0006_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1123, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0006_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1124, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0006_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1125, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0006_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1126, 20), )

    
    default = property(__default.value, __default.set, None, None)

    _ElementMap.update({
        __string.name() : __string,
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __current.name() : __current,
        __default.name() : __default
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0006', T0006)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0007 with content type ELEMENT_ONLY
class T0007 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.1 - CONTROL_LINEAR_UINT64"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0007')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1132, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}string uses Python identifier string
    __string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'string'), 'string', '__httpgrouper_ieee_orggroups17221contributionsxml_T0007_httpgrouper_ieee_orggroups17221contributionsxmlstring', False, pyxb.utils.utility.Location('avdecc.xsd', 1139, 20), )

    
    string = property(__string.value, __string.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0007_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1140, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0007_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1141, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0007_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1142, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0007_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1143, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0007_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1144, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0007_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1145, 20), )

    
    default = property(__default.value, __default.set, None, None)

    _ElementMap.update({
        __string.name() : __string,
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __current.name() : __current,
        __default.name() : __default
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0007', T0007)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0008 with content type ELEMENT_ONLY
class T0008 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.1 - CONTROL_LINEAR_FLOAT"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0008')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1151, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}string uses Python identifier string
    __string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'string'), 'string', '__httpgrouper_ieee_orggroups17221contributionsxml_T0008_httpgrouper_ieee_orggroups17221contributionsxmlstring', False, pyxb.utils.utility.Location('avdecc.xsd', 1158, 20), )

    
    string = property(__string.value, __string.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0008_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1159, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0008_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1160, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0008_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1161, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0008_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1162, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0008_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1163, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0008_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1164, 20), )

    
    default = property(__default.value, __default.set, None, None)

    _ElementMap.update({
        __string.name() : __string,
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __current.name() : __current,
        __default.name() : __default
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0008', T0008)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0009 with content type ELEMENT_ONLY
class T0009 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.1 - CONTROL_LINEAR_DOUBLE"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0009')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1170, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}string uses Python identifier string
    __string = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'string'), 'string', '__httpgrouper_ieee_orggroups17221contributionsxml_T0009_httpgrouper_ieee_orggroups17221contributionsxmlstring', False, pyxb.utils.utility.Location('avdecc.xsd', 1177, 20), )

    
    string = property(__string.value, __string.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0009_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1178, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0009_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1179, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0009_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1180, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0009_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1181, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0009_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1182, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0009_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1183, 20), )

    
    default = property(__default.value, __default.set, None, None)

    _ElementMap.update({
        __string.name() : __string,
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __current.name() : __current,
        __default.name() : __default
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0009', T0009)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T000a with content type ELEMENT_ONLY
class T000a (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.2 - CONTROL_SELECTOR_INT8"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T000a')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1189, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T000a_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1196, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T000a_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1197, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T000a_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1198, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}options uses Python identifier options
    __options = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'options'), 'options', '__httpgrouper_ieee_orggroups17221contributionsxml_T000a_httpgrouper_ieee_orggroups17221contributionsxmloptions', False, pyxb.utils.utility.Location('avdecc.xsd', 1199, 20), )

    
    options = property(__options.value, __options.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __current.name() : __current,
        __default.name() : __default,
        __options.name() : __options
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T000a', T000a)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T000b with content type ELEMENT_ONLY
class T000b (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.2 - CONTROL_SELECTOR_UINT8"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T000b')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1207, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T000b_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1214, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T000b_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1215, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T000b_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1216, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}options uses Python identifier options
    __options = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'options'), 'options', '__httpgrouper_ieee_orggroups17221contributionsxml_T000b_httpgrouper_ieee_orggroups17221contributionsxmloptions', False, pyxb.utils.utility.Location('avdecc.xsd', 1217, 20), )

    
    options = property(__options.value, __options.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __current.name() : __current,
        __default.name() : __default,
        __options.name() : __options
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T000b', T000b)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T000c with content type ELEMENT_ONLY
class T000c (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.2 - CONTROL_SELECTOR_INT16"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T000c')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1223, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T000c_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1230, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T000c_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1231, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T000c_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1232, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}options uses Python identifier options
    __options = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'options'), 'options', '__httpgrouper_ieee_orggroups17221contributionsxml_T000c_httpgrouper_ieee_orggroups17221contributionsxmloptions', False, pyxb.utils.utility.Location('avdecc.xsd', 1233, 20), )

    
    options = property(__options.value, __options.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __current.name() : __current,
        __default.name() : __default,
        __options.name() : __options
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T000c', T000c)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T000d with content type ELEMENT_ONLY
class T000d (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.2 - CONTROL_SELECTOR_UINT16"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T000d')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1239, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T000d_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1246, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T000d_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1247, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T000d_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1248, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}options uses Python identifier options
    __options = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'options'), 'options', '__httpgrouper_ieee_orggroups17221contributionsxml_T000d_httpgrouper_ieee_orggroups17221contributionsxmloptions', False, pyxb.utils.utility.Location('avdecc.xsd', 1249, 20), )

    
    options = property(__options.value, __options.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __current.name() : __current,
        __default.name() : __default,
        __options.name() : __options
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T000d', T000d)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T000e with content type ELEMENT_ONLY
class T000e (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.2 - CONTROL_SELECTOR_INT32"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T000e')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1255, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T000e_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1262, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T000e_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1263, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T000e_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1264, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}options uses Python identifier options
    __options = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'options'), 'options', '__httpgrouper_ieee_orggroups17221contributionsxml_T000e_httpgrouper_ieee_orggroups17221contributionsxmloptions', False, pyxb.utils.utility.Location('avdecc.xsd', 1265, 20), )

    
    options = property(__options.value, __options.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __current.name() : __current,
        __default.name() : __default,
        __options.name() : __options
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T000e', T000e)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T000f with content type ELEMENT_ONLY
class T000f (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.2 - CONTROL_SELECTOR_UINT32"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T000f')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1271, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T000f_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1278, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T000f_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1279, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T000f_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1280, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}options uses Python identifier options
    __options = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'options'), 'options', '__httpgrouper_ieee_orggroups17221contributionsxml_T000f_httpgrouper_ieee_orggroups17221contributionsxmloptions', False, pyxb.utils.utility.Location('avdecc.xsd', 1281, 20), )

    
    options = property(__options.value, __options.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __current.name() : __current,
        __default.name() : __default,
        __options.name() : __options
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T000f', T000f)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0010 with content type ELEMENT_ONLY
class T0010 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.2 - CONTROL_SELECTOR_INT64"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0010')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1287, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0010_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1294, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0010_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1295, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0010_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1296, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}options uses Python identifier options
    __options = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'options'), 'options', '__httpgrouper_ieee_orggroups17221contributionsxml_T0010_httpgrouper_ieee_orggroups17221contributionsxmloptions', False, pyxb.utils.utility.Location('avdecc.xsd', 1297, 20), )

    
    options = property(__options.value, __options.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __current.name() : __current,
        __default.name() : __default,
        __options.name() : __options
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0010', T0010)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0011 with content type ELEMENT_ONLY
class T0011 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.2 - CONTROL_SELECTOR_UINT64"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0011')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1303, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0011_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1310, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0011_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1311, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0011_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1312, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}options uses Python identifier options
    __options = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'options'), 'options', '__httpgrouper_ieee_orggroups17221contributionsxml_T0011_httpgrouper_ieee_orggroups17221contributionsxmloptions', False, pyxb.utils.utility.Location('avdecc.xsd', 1313, 20), )

    
    options = property(__options.value, __options.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __current.name() : __current,
        __default.name() : __default,
        __options.name() : __options
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0011', T0011)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0012 with content type ELEMENT_ONLY
class T0012 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.2 - CONTROL_SELECTOR_FLOAT"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0012')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1319, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0012_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1326, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0012_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1327, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0012_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1328, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}options uses Python identifier options
    __options = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'options'), 'options', '__httpgrouper_ieee_orggroups17221contributionsxml_T0012_httpgrouper_ieee_orggroups17221contributionsxmloptions', False, pyxb.utils.utility.Location('avdecc.xsd', 1329, 20), )

    
    options = property(__options.value, __options.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __current.name() : __current,
        __default.name() : __default,
        __options.name() : __options
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0012', T0012)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0013 with content type ELEMENT_ONLY
class T0013 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.2 - CONTROL_SELECTOR_DOUBLE"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0013')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1335, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0013_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1342, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0013_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1343, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0013_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1344, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}options uses Python identifier options
    __options = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'options'), 'options', '__httpgrouper_ieee_orggroups17221contributionsxml_T0013_httpgrouper_ieee_orggroups17221contributionsxmloptions', False, pyxb.utils.utility.Location('avdecc.xsd', 1345, 20), )

    
    options = property(__options.value, __options.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __current.name() : __current,
        __default.name() : __default,
        __options.name() : __options
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0013', T0013)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0014 with content type ELEMENT_ONLY
class T0014 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.2 - CONTROL_SELECTOR_STRING"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0014')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1351, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0014_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1358, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T0014_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1359, 20), )

    
    current = property(__current.value, __current.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0014_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1360, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}options uses Python identifier options
    __options = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'options'), 'options', '__httpgrouper_ieee_orggroups17221contributionsxml_T0014_httpgrouper_ieee_orggroups17221contributionsxmloptions', False, pyxb.utils.utility.Location('avdecc.xsd', 1361, 20), )

    
    options = property(__options.value, __options.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __current.name() : __current,
        __default.name() : __default,
        __options.name() : __options
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0014', T0014)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0015 with content type ELEMENT_ONLY
class T0015 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.3 - CONTROL_ARRAY_INT8"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0015')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1367, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0015_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1374, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0015_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1375, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0015_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1376, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0015_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1377, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0015_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1378, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_values uses Python identifier current_values
    __current_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_values'), 'current_values', '__httpgrouper_ieee_orggroups17221contributionsxml_T0015_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_values', False, pyxb.utils.utility.Location('avdecc.xsd', 1379, 20), )

    
    current_values = property(__current_values.value, __current_values.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __default.name() : __default,
        __current_values.name() : __current_values
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0015', T0015)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0016 with content type ELEMENT_ONLY
class T0016 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.3 - CONTROL_ARRAY_UINT8"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0016')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1386, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0016_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1393, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0016_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1394, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0016_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1395, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0016_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1396, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0016_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1397, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_values uses Python identifier current_values
    __current_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_values'), 'current_values', '__httpgrouper_ieee_orggroups17221contributionsxml_T0016_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_values', False, pyxb.utils.utility.Location('avdecc.xsd', 1398, 20), )

    
    current_values = property(__current_values.value, __current_values.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __default.name() : __default,
        __current_values.name() : __current_values
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0016', T0016)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0017 with content type ELEMENT_ONLY
class T0017 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.3 - CONTROL_ARRAY_INT16"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0017')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1404, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0017_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1411, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0017_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1412, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0017_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1413, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0017_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1414, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0017_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1415, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_values uses Python identifier current_values
    __current_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_values'), 'current_values', '__httpgrouper_ieee_orggroups17221contributionsxml_T0017_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_values', False, pyxb.utils.utility.Location('avdecc.xsd', 1416, 20), )

    
    current_values = property(__current_values.value, __current_values.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __default.name() : __default,
        __current_values.name() : __current_values
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0017', T0017)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0018 with content type ELEMENT_ONLY
class T0018 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.3 - CONTROL_ARRAY_UINT16"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0018')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1422, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0018_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1429, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0018_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1430, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0018_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1431, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0018_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1432, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0018_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1433, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_values uses Python identifier current_values
    __current_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_values'), 'current_values', '__httpgrouper_ieee_orggroups17221contributionsxml_T0018_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_values', False, pyxb.utils.utility.Location('avdecc.xsd', 1434, 20), )

    
    current_values = property(__current_values.value, __current_values.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __default.name() : __default,
        __current_values.name() : __current_values
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0018', T0018)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0019 with content type ELEMENT_ONLY
class T0019 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.3 - CONTROL_ARRAY_INT32"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0019')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1440, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T0019_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1447, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0019_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1448, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0019_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1449, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0019_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1450, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0019_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1451, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_values uses Python identifier current_values
    __current_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_values'), 'current_values', '__httpgrouper_ieee_orggroups17221contributionsxml_T0019_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_values', False, pyxb.utils.utility.Location('avdecc.xsd', 1452, 20), )

    
    current_values = property(__current_values.value, __current_values.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __default.name() : __default,
        __current_values.name() : __current_values
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0019', T0019)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T001a with content type ELEMENT_ONLY
class T001a (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.3 - CONTROL_ARRAY_UINT32"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T001a')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1458, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T001a_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1465, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T001a_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1466, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T001a_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1467, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T001a_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1468, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T001a_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1469, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_values uses Python identifier current_values
    __current_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_values'), 'current_values', '__httpgrouper_ieee_orggroups17221contributionsxml_T001a_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_values', False, pyxb.utils.utility.Location('avdecc.xsd', 1470, 20), )

    
    current_values = property(__current_values.value, __current_values.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __default.name() : __default,
        __current_values.name() : __current_values
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T001a', T001a)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T001b with content type ELEMENT_ONLY
class T001b (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.3 - CONTROL_ARRAY_INT64"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T001b')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1476, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T001b_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1483, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T001b_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1484, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T001b_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1485, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T001b_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1486, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T001b_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1487, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_values uses Python identifier current_values
    __current_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_values'), 'current_values', '__httpgrouper_ieee_orggroups17221contributionsxml_T001b_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_values', False, pyxb.utils.utility.Location('avdecc.xsd', 1488, 20), )

    
    current_values = property(__current_values.value, __current_values.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __default.name() : __default,
        __current_values.name() : __current_values
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T001b', T001b)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T001c with content type ELEMENT_ONLY
class T001c (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.3 - CONTROL_ARRAY_UINT64"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T001c')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1494, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T001c_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1501, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T001c_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1502, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T001c_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1503, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T001c_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1504, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T001c_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1505, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_values uses Python identifier current_values
    __current_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_values'), 'current_values', '__httpgrouper_ieee_orggroups17221contributionsxml_T001c_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_values', False, pyxb.utils.utility.Location('avdecc.xsd', 1506, 20), )

    
    current_values = property(__current_values.value, __current_values.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __default.name() : __default,
        __current_values.name() : __current_values
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T001c', T001c)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T001d with content type ELEMENT_ONLY
class T001d (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.3 - CONTROL_ARRAY_FLOAT"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T001d')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1512, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T001d_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1519, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T001d_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1520, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T001d_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1521, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T001d_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1522, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T001d_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1523, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_values uses Python identifier current_values
    __current_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_values'), 'current_values', '__httpgrouper_ieee_orggroups17221contributionsxml_T001d_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_values', False, pyxb.utils.utility.Location('avdecc.xsd', 1524, 20), )

    
    current_values = property(__current_values.value, __current_values.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __default.name() : __default,
        __current_values.name() : __current_values
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T001d', T001d)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T001e with content type ELEMENT_ONLY
class T001e (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.3 - ONTROL_ARRAY_DOUBLE"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T001e')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1530, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}units uses Python identifier units
    __units = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'units'), 'units', '__httpgrouper_ieee_orggroups17221contributionsxml_T001e_httpgrouper_ieee_orggroups17221contributionsxmlunits', False, pyxb.utils.utility.Location('avdecc.xsd', 1537, 20), )

    
    units = property(__units.value, __units.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T001e_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1538, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T001e_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1539, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T001e_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1540, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T001e_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1541, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_values uses Python identifier current_values
    __current_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_values'), 'current_values', '__httpgrouper_ieee_orggroups17221contributionsxml_T001e_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_values', False, pyxb.utils.utility.Location('avdecc.xsd', 1542, 20), )

    
    current_values = property(__current_values.value, __current_values.set, None, None)

    _ElementMap.update({
        __units.name() : __units,
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __default.name() : __default,
        __current_values.name() : __current_values
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T001e', T001e)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T001f with content type ELEMENT_ONLY
class T001f (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.4 - CONTROL_UTF8"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T001f')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1548, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current uses Python identifier current
    __current = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current'), 'current', '__httpgrouper_ieee_orggroups17221contributionsxml_T001f_httpgrouper_ieee_orggroups17221contributionsxmlcurrent', False, pyxb.utils.utility.Location('avdecc.xsd', 1555, 20), )

    
    current = property(__current.value, __current.set, None, None)

    _ElementMap.update({
        __current.name() : __current
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T001f', T001f)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0020 with content type ELEMENT_ONLY
class T0020 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.5 - CONTROL_BODE_PLOT"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0020')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1561, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minimum uses Python identifier minimum
    __minimum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minimum'), 'minimum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0020_httpgrouper_ieee_orggroups17221contributionsxmlminimum', False, pyxb.utils.utility.Location('avdecc.xsd', 1568, 20), )

    
    minimum = property(__minimum.value, __minimum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}maximum uses Python identifier maximum
    __maximum = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'maximum'), 'maximum', '__httpgrouper_ieee_orggroups17221contributionsxml_T0020_httpgrouper_ieee_orggroups17221contributionsxmlmaximum', False, pyxb.utils.utility.Location('avdecc.xsd', 1569, 20), )

    
    maximum = property(__maximum.value, __maximum.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'step'), 'step', '__httpgrouper_ieee_orggroups17221contributionsxml_T0020_httpgrouper_ieee_orggroups17221contributionsxmlstep', False, pyxb.utils.utility.Location('avdecc.xsd', 1570, 20), )

    
    step = property(__step.value, __step.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}default uses Python identifier default
    __default = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'default'), 'default', '__httpgrouper_ieee_orggroups17221contributionsxml_T0020_httpgrouper_ieee_orggroups17221contributionsxmldefault', False, pyxb.utils.utility.Location('avdecc.xsd', 1571, 20), )

    
    default = property(__default.value, __default.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}current_values uses Python identifier current_values
    __current_values = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'current_values'), 'current_values', '__httpgrouper_ieee_orggroups17221contributionsxml_T0020_httpgrouper_ieee_orggroups17221contributionsxmlcurrent_values', False, pyxb.utils.utility.Location('avdecc.xsd', 1572, 20), )

    
    current_values = property(__current_values.value, __current_values.set, None, None)

    _ElementMap.update({
        __minimum.name() : __minimum,
        __maximum.name() : __maximum,
        __step.name() : __step,
        __default.name() : __default,
        __current_values.name() : __current_values
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0020', T0020)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0021 with content type ELEMENT_ONLY
class T0021 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.6 - CONTROL_SMPTE_TIME"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0021')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1578, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}hours uses Python identifier hours
    __hours = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'hours'), 'hours', '__httpgrouper_ieee_orggroups17221contributionsxml_T0021_httpgrouper_ieee_orggroups17221contributionsxmlhours', False, pyxb.utils.utility.Location('avdecc.xsd', 1585, 20), )

    
    hours = property(__hours.value, __hours.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}minutes uses Python identifier minutes
    __minutes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'minutes'), 'minutes', '__httpgrouper_ieee_orggroups17221contributionsxml_T0021_httpgrouper_ieee_orggroups17221contributionsxmlminutes', False, pyxb.utils.utility.Location('avdecc.xsd', 1586, 20), )

    
    minutes = property(__minutes.value, __minutes.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}seconds uses Python identifier seconds
    __seconds = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'seconds'), 'seconds', '__httpgrouper_ieee_orggroups17221contributionsxml_T0021_httpgrouper_ieee_orggroups17221contributionsxmlseconds', False, pyxb.utils.utility.Location('avdecc.xsd', 1587, 20), )

    
    seconds = property(__seconds.value, __seconds.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}frames uses Python identifier frames
    __frames = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'frames'), 'frames', '__httpgrouper_ieee_orggroups17221contributionsxml_T0021_httpgrouper_ieee_orggroups17221contributionsxmlframes', False, pyxb.utils.utility.Location('avdecc.xsd', 1588, 20), )

    
    frames = property(__frames.value, __frames.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}subframes uses Python identifier subframes
    __subframes = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'subframes'), 'subframes', '__httpgrouper_ieee_orggroups17221contributionsxml_T0021_httpgrouper_ieee_orggroups17221contributionsxmlsubframes', False, pyxb.utils.utility.Location('avdecc.xsd', 1589, 20), )

    
    subframes = property(__subframes.value, __subframes.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}frames_per_second uses Python identifier frames_per_second
    __frames_per_second = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'frames_per_second'), 'frames_per_second', '__httpgrouper_ieee_orggroups17221contributionsxml_T0021_httpgrouper_ieee_orggroups17221contributionsxmlframes_per_second', False, pyxb.utils.utility.Location('avdecc.xsd', 1590, 20), )

    
    frames_per_second = property(__frames_per_second.value, __frames_per_second.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}drop_frame uses Python identifier drop_frame
    __drop_frame = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'drop_frame'), 'drop_frame', '__httpgrouper_ieee_orggroups17221contributionsxml_T0021_httpgrouper_ieee_orggroups17221contributionsxmldrop_frame', False, pyxb.utils.utility.Location('avdecc.xsd', 1591, 20), )

    
    drop_frame = property(__drop_frame.value, __drop_frame.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}pull uses Python identifier pull
    __pull = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'pull'), 'pull', '__httpgrouper_ieee_orggroups17221contributionsxml_T0021_httpgrouper_ieee_orggroups17221contributionsxmlpull', False, pyxb.utils.utility.Location('avdecc.xsd', 1592, 20), )

    
    pull = property(__pull.value, __pull.set, None, None)

    _ElementMap.update({
        __hours.name() : __hours,
        __minutes.name() : __minutes,
        __seconds.name() : __seconds,
        __frames.name() : __frames,
        __subframes.name() : __subframes,
        __frames_per_second.name() : __frames_per_second,
        __drop_frame.name() : __drop_frame,
        __pull.name() : __pull
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0021', T0021)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0022 with content type ELEMENT_ONLY
class T0022 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.7 - CONTROL_SAMPLE_RATE"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0022')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1598, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}pull uses Python identifier pull
    __pull = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'pull'), 'pull', '__httpgrouper_ieee_orggroups17221contributionsxml_T0022_httpgrouper_ieee_orggroups17221contributionsxmlpull', False, pyxb.utils.utility.Location('avdecc.xsd', 1605, 20), )

    
    pull = property(__pull.value, __pull.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}base_frequency uses Python identifier base_frequency
    __base_frequency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'base_frequency'), 'base_frequency', '__httpgrouper_ieee_orggroups17221contributionsxml_T0022_httpgrouper_ieee_orggroups17221contributionsxmlbase_frequency', False, pyxb.utils.utility.Location('avdecc.xsd', 1606, 20), )

    
    base_frequency = property(__base_frequency.value, __base_frequency.set, None, None)

    _ElementMap.update({
        __pull.name() : __pull,
        __base_frequency.name() : __base_frequency
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0022', T0022)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T0023 with content type ELEMENT_ONLY
class T0023 (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.8 - CONTROL_GPTP_TIME"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T0023')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1612, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}gptp_seconds uses Python identifier gptp_seconds
    __gptp_seconds = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'gptp_seconds'), 'gptp_seconds', '__httpgrouper_ieee_orggroups17221contributionsxml_T0023_httpgrouper_ieee_orggroups17221contributionsxmlgptp_seconds', False, pyxb.utils.utility.Location('avdecc.xsd', 1619, 20), )

    
    gptp_seconds = property(__gptp_seconds.value, __gptp_seconds.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}gptp_nanoseconds uses Python identifier gptp_nanoseconds
    __gptp_nanoseconds = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'gptp_nanoseconds'), 'gptp_nanoseconds', '__httpgrouper_ieee_orggroups17221contributionsxml_T0023_httpgrouper_ieee_orggroups17221contributionsxmlgptp_nanoseconds', False, pyxb.utils.utility.Location('avdecc.xsd', 1620, 20), )

    
    gptp_nanoseconds = property(__gptp_nanoseconds.value, __gptp_nanoseconds.set, None, None)

    _ElementMap.update({
        __gptp_seconds.name() : __gptp_seconds,
        __gptp_nanoseconds.name() : __gptp_nanoseconds
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T0023', T0023)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}T3ffe with content type ELEMENT_ONLY
class T3ffe (Value):
    """See IEEE Std 1722.1-2013 Clause 7.3.5.2.9 - CONTROL_VENDOR"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'T3ffe')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1626, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}vendor_eui64 uses Python identifier vendor_eui64
    __vendor_eui64 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'vendor_eui64'), 'vendor_eui64', '__httpgrouper_ieee_orggroups17221contributionsxml_T3ffe_httpgrouper_ieee_orggroups17221contributionsxmlvendor_eui64', False, pyxb.utils.utility.Location('avdecc.xsd', 1633, 20), )

    
    vendor_eui64 = property(__vendor_eui64.value, __vendor_eui64.set, None, None)

    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}binary_blob uses Python identifier binary_blob
    __binary_blob = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'binary_blob'), 'binary_blob', '__httpgrouper_ieee_orggroups17221contributionsxml_T3ffe_httpgrouper_ieee_orggroups17221contributionsxmlbinary_blob', False, pyxb.utils.utility.Location('avdecc.xsd', 1634, 20), )

    
    binary_blob = property(__binary_blob.value, __binary_blob.set, None, None)

    _ElementMap.update({
        __vendor_eui64.name() : __vendor_eui64,
        __binary_blob.name() : __binary_blob
    })
    _AttributeMap.update({
        
    })
Namespace.addCategoryObject('typeBinding', u'T3ffe', T3ffe)


# Complex type {http://grouper.ieee.org/groups/1722/1/contributions/xml}TUNKNOWN with content type ELEMENT_ONLY
class TUNKNOWN (Value):
    """For value_type codes that do not match the standard set defined in IEEE Std 1722.1 Clause 7.3.5"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, u'TUNKNOWN')
    _XSDLocation = pyxb.utils.utility.Location('avdecc.xsd', 1640, 4)
    _ElementMap = Value._ElementMap.copy()
    _AttributeMap = Value._AttributeMap.copy()
    # Base type is Value
    
    # Element {http://grouper.ieee.org/groups/1722/1/contributions/xml}binary_blob uses Python identifier binary_blob
    __binary_blob = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, u'binary_blob'), 'binary_blob', '__httpgrouper_ieee_orggroups17221contributionsxml_TUNKNOWN_httpgrouper_ieee_orggroups17221contributionsxmlbinary_blob', False, pyxb.utils.utility.Location('avdecc.xsd', 1647, 20), )

    
    binary_blob = property(__binary_blob.value, __binary_blob.set, None, None)

    
    # Attribute value_type uses Python identifier value_type
    __value_type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, u'value_type'), 'value_type', '__httpgrouper_ieee_orggroups17221contributionsxml_TUNKNOWN_value_type', Doublet, required=True)
    __value_type._DeclarationLocation = pyxb.utils.utility.Location('avdecc.xsd', 1649, 16)
    __value_type._UseLocation = pyxb.utils.utility.Location('avdecc.xsd', 1649, 16)
    
    value_type = property(__value_type.value, __value_type.set, None, None)

    _ElementMap.update({
        __binary_blob.name() : __binary_blob
    })
    _AttributeMap.update({
        __value_type.name() : __value_type
    })
Namespace.addCategoryObject('typeBinding', u'TUNKNOWN', TUNKNOWN)


entity = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'entity'), EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 20, 4))
Namespace.addCategoryObject('elementBinding', entity.name().localName(), entity)



EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'entity_id'), EUI64, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 27, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'entity_model_id'), EUI64, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 28, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'entity_capabilities'), Quadlet, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 29, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'talker_stream_sources'), Doublet, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 30, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'talker_capabilties'), Doublet, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 31, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'listener_stream_sinks'), Doublet, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 32, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'listener_capabilities'), Doublet, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 33, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controller_capabilities'), Quadlet, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 34, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'association_id'), EUI64, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 35, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'entity_name'), AVDECCString, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 36, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'vendor_name'), LocalizedStringContainer, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 37, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'model_name'), LocalizedStringContainer, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 38, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'firmware_version'), AVDECCString, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 39, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'group_name'), AVDECCString, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 40, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'serial_number'), AVDECCString, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 41, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_configuration'), DescriptorIndex, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 42, 12)))

EntityV1._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'configurations'), ConfigurationDescriptors, scope=EntityV1, location=pyxb.utils.utility.Location('avdecc.xsd', 43, 12)))

def _BuildAutomaton ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton
    del _BuildAutomaton
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'entity_id')), pyxb.utils.utility.Location('avdecc.xsd', 27, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'entity_model_id')), pyxb.utils.utility.Location('avdecc.xsd', 28, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'entity_capabilities')), pyxb.utils.utility.Location('avdecc.xsd', 29, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'talker_stream_sources')), pyxb.utils.utility.Location('avdecc.xsd', 30, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'talker_capabilties')), pyxb.utils.utility.Location('avdecc.xsd', 31, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'listener_stream_sinks')), pyxb.utils.utility.Location('avdecc.xsd', 32, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'listener_capabilities')), pyxb.utils.utility.Location('avdecc.xsd', 33, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controller_capabilities')), pyxb.utils.utility.Location('avdecc.xsd', 34, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'association_id')), pyxb.utils.utility.Location('avdecc.xsd', 35, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'entity_name')), pyxb.utils.utility.Location('avdecc.xsd', 36, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'vendor_name')), pyxb.utils.utility.Location('avdecc.xsd', 37, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'model_name')), pyxb.utils.utility.Location('avdecc.xsd', 38, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'firmware_version')), pyxb.utils.utility.Location('avdecc.xsd', 39, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'group_name')), pyxb.utils.utility.Location('avdecc.xsd', 40, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'serial_number')), pyxb.utils.utility.Location('avdecc.xsd', 41, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_configuration')), pyxb.utils.utility.Location('avdecc.xsd', 42, 12))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(EntityV1._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'configurations')), pyxb.utils.utility.Location('avdecc.xsd', 43, 12))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
         ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
         ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
         ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
         ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
         ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    st_16._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
EntityV1._Automaton = _BuildAutomaton()




ConfigurationDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'configuration'), ConfigurationDescriptor, scope=ConfigurationDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 50, 12)))

def _BuildAutomaton_ ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_
    del _BuildAutomaton_
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'configuration')), pyxb.utils.utility.Location('avdecc.xsd', 50, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ConfigurationDescriptors._Automaton = _BuildAutomaton_()




ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 58, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 59, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'audio_units'), AudioUnitDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 60, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'video_units'), VideoUnitDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 61, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sensor_units'), SensorUnitDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 62, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_streams'), StreamDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 63, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_streams'), StreamDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 64, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_jacks'), JackDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 65, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_jacks'), JackDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 66, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'avb_interfaces'), AVBInterfaceDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 67, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_sources'), ClockSourceDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 68, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controls'), ControlDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 69, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors'), SignalSelectorDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 70, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mixers'), MixerDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 71, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'matrices'), MatrixDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 72, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'locales'), LocaleDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 73, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'splitters'), SignalSplitterDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 74, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'combiners'), SignalCombinerDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 75, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers'), SignalDemultiplexerDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 76, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiplexers'), SignalMultiplexerDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 77, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'transcoders'), SignalTranscoderDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 78, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'memory_objects'), MemoryObjectDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 79, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_domains'), ClockDomainDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 80, 12)))

ConfigurationDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_blocks'), ControlBlockDescriptors, scope=ConfigurationDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 81, 12)))

def _BuildAutomaton_2 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_2
    del _BuildAutomaton_2
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 58, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 60, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 61, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 62, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 63, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 64, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 65, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 66, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 67, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 68, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 69, 12))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 70, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 71, 12))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 72, 12))
    counters.add(cc_13)
    cc_14 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 73, 12))
    counters.add(cc_14)
    cc_15 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 74, 12))
    counters.add(cc_15)
    cc_16 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 75, 12))
    counters.add(cc_16)
    cc_17 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 76, 12))
    counters.add(cc_17)
    cc_18 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 77, 12))
    counters.add(cc_18)
    cc_19 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 78, 12))
    counters.add(cc_19)
    cc_20 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 79, 12))
    counters.add(cc_20)
    cc_21 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 80, 12))
    counters.add(cc_21)
    cc_22 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 81, 12))
    counters.add(cc_22)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 58, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 59, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'audio_units')), pyxb.utils.utility.Location('avdecc.xsd', 60, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'video_units')), pyxb.utils.utility.Location('avdecc.xsd', 61, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sensor_units')), pyxb.utils.utility.Location('avdecc.xsd', 62, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_streams')), pyxb.utils.utility.Location('avdecc.xsd', 63, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_streams')), pyxb.utils.utility.Location('avdecc.xsd', 64, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_jacks')), pyxb.utils.utility.Location('avdecc.xsd', 65, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_jacks')), pyxb.utils.utility.Location('avdecc.xsd', 66, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'avb_interfaces')), pyxb.utils.utility.Location('avdecc.xsd', 67, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_sources')), pyxb.utils.utility.Location('avdecc.xsd', 68, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controls')), pyxb.utils.utility.Location('avdecc.xsd', 69, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors')), pyxb.utils.utility.Location('avdecc.xsd', 70, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mixers')), pyxb.utils.utility.Location('avdecc.xsd', 71, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'matrices')), pyxb.utils.utility.Location('avdecc.xsd', 72, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_14, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'locales')), pyxb.utils.utility.Location('avdecc.xsd', 73, 12))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_15, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'splitters')), pyxb.utils.utility.Location('avdecc.xsd', 74, 12))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_16, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'combiners')), pyxb.utils.utility.Location('avdecc.xsd', 75, 12))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_17, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers')), pyxb.utils.utility.Location('avdecc.xsd', 76, 12))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_18, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiplexers')), pyxb.utils.utility.Location('avdecc.xsd', 77, 12))
    st_19 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_19)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_19, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'transcoders')), pyxb.utils.utility.Location('avdecc.xsd', 78, 12))
    st_20 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_20)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_20, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'memory_objects')), pyxb.utils.utility.Location('avdecc.xsd', 79, 12))
    st_21 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_21)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_21, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_domains')), pyxb.utils.utility.Location('avdecc.xsd', 80, 12))
    st_22 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_22)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_22, False))
    symbol = pyxb.binding.content.ElementUse(ConfigurationDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_blocks')), pyxb.utils.utility.Location('avdecc.xsd', 81, 12))
    st_23 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_23)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    transitions.append(fac.Transition(st_19, [
         ]))
    transitions.append(fac.Transition(st_20, [
         ]))
    transitions.append(fac.Transition(st_21, [
         ]))
    transitions.append(fac.Transition(st_22, [
         ]))
    transitions.append(fac.Transition(st_23, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_13, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_13, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_14, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_14, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_15, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_15, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_16, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_16, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_16, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_16, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_16, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_16, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_16, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_17, True) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_17, False) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_17, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_17, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_17, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_17, False) ]))
    st_18._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_18, True) ]))
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_18, False) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_18, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_18, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_18, False) ]))
    st_19._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_20, [
        fac.UpdateInstruction(cc_19, True) ]))
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_19, False) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_19, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_19, False) ]))
    st_20._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_21, [
        fac.UpdateInstruction(cc_20, True) ]))
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_20, False) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_20, False) ]))
    st_21._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_22, [
        fac.UpdateInstruction(cc_21, True) ]))
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_21, False) ]))
    st_22._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_23, [
        fac.UpdateInstruction(cc_22, True) ]))
    st_23._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ConfigurationDescriptor._Automaton = _BuildAutomaton_2()




AudioUnitDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'audio_unit'), AudioUnitDescriptor, scope=AudioUnitDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 88, 12)))

def _BuildAutomaton_3 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_3
    del _BuildAutomaton_3
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 88, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'audio_unit')), pyxb.utils.utility.Location('avdecc.xsd', 88, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
AudioUnitDescriptors._Automaton = _BuildAutomaton_3()




AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 96, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 97, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), DescriptorIndex, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 98, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_stream_ports'), AudioStreamPortDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 99, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_stream_ports'), AudioStreamPortDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 100, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_external_ports'), ExternalPortDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 101, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_external_ports'), ExternalPortDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 102, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_internal_ports'), InternalPortDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 103, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_internal_ports'), InternalPortDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 104, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controls'), ControlDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 105, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors'), SignalSelectorDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 106, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mixers'), MixerDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 107, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'matrices'), MatrixDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 108, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'splitters'), SignalSplitterDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 109, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'combiners'), SignalCombinerDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 110, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers'), SignalDemultiplexerDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 111, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiplexers'), SignalMultiplexerDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 112, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'transcoders'), SignalTranscoderDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 113, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_blocks'), ControlBlockDescriptors, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 114, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_sampling_rate'), SamplingRate, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 115, 12)))

AudioUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sampling_rates'), SamplingRates, scope=AudioUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 116, 12)))

def _BuildAutomaton_4 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_4
    del _BuildAutomaton_4
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 96, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 99, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 100, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 101, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 102, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 103, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 104, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 105, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 106, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 107, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 108, 12))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 109, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 110, 12))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 111, 12))
    counters.add(cc_13)
    cc_14 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 112, 12))
    counters.add(cc_14)
    cc_15 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 113, 12))
    counters.add(cc_15)
    cc_16 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 114, 12))
    counters.add(cc_16)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 96, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 97, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index')), pyxb.utils.utility.Location('avdecc.xsd', 98, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_stream_ports')), pyxb.utils.utility.Location('avdecc.xsd', 99, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_stream_ports')), pyxb.utils.utility.Location('avdecc.xsd', 100, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_external_ports')), pyxb.utils.utility.Location('avdecc.xsd', 101, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_external_ports')), pyxb.utils.utility.Location('avdecc.xsd', 102, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_internal_ports')), pyxb.utils.utility.Location('avdecc.xsd', 103, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_internal_ports')), pyxb.utils.utility.Location('avdecc.xsd', 104, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controls')), pyxb.utils.utility.Location('avdecc.xsd', 105, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors')), pyxb.utils.utility.Location('avdecc.xsd', 106, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mixers')), pyxb.utils.utility.Location('avdecc.xsd', 107, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'matrices')), pyxb.utils.utility.Location('avdecc.xsd', 108, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'splitters')), pyxb.utils.utility.Location('avdecc.xsd', 109, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'combiners')), pyxb.utils.utility.Location('avdecc.xsd', 110, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers')), pyxb.utils.utility.Location('avdecc.xsd', 111, 12))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiplexers')), pyxb.utils.utility.Location('avdecc.xsd', 112, 12))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'transcoders')), pyxb.utils.utility.Location('avdecc.xsd', 113, 12))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_blocks')), pyxb.utils.utility.Location('avdecc.xsd', 114, 12))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_sampling_rate')), pyxb.utils.utility.Location('avdecc.xsd', 115, 12))
    st_19 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_19)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AudioUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sampling_rates')), pyxb.utils.utility.Location('avdecc.xsd', 116, 12))
    st_20 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_20)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    transitions.append(fac.Transition(st_19, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_13, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_13, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_14, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_14, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_15, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_15, False) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_15, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_16, True) ]))
    transitions.append(fac.Transition(st_19, [
        fac.UpdateInstruction(cc_16, False) ]))
    st_18._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_20, [
         ]))
    st_19._set_transitionSet(transitions)
    transitions = []
    st_20._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AudioUnitDescriptor._Automaton = _BuildAutomaton_4()




VideoUnitDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'video_unit'), VideoUnitDescriptor, scope=VideoUnitDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 123, 12)))

def _BuildAutomaton_5 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_5
    del _BuildAutomaton_5
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 123, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'video_unit')), pyxb.utils.utility.Location('avdecc.xsd', 123, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
VideoUnitDescriptors._Automaton = _BuildAutomaton_5()




VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 131, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 132, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), DescriptorIndex, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 133, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_stream_ports'), VideoStreamPortDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 134, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_stream_ports'), VideoStreamPortDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 135, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_external_ports'), ExternalPortDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 136, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_external_ports'), ExternalPortDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 137, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_internal_ports'), InternalPortDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 138, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_internal_ports'), InternalPortDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 139, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controls'), ControlDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 140, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors'), SignalSelectorDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 141, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mixers'), MixerDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 142, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'matrices'), MatrixDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 143, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'splitters'), SignalSplitterDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 144, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'combiners'), SignalCombinerDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 145, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers'), SignalDemultiplexerDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 146, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiplexers'), SignalMultiplexerDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 147, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'transcoders'), SignalTranscoderDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 148, 12)))

VideoUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_blocks'), ControlBlockDescriptors, scope=VideoUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 149, 12)))

def _BuildAutomaton_6 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_6
    del _BuildAutomaton_6
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 131, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 134, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 135, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 136, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 137, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 138, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 139, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 140, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 141, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 142, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 143, 12))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 144, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 145, 12))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 146, 12))
    counters.add(cc_13)
    cc_14 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 147, 12))
    counters.add(cc_14)
    cc_15 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 148, 12))
    counters.add(cc_15)
    cc_16 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 149, 12))
    counters.add(cc_16)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 131, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 132, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index')), pyxb.utils.utility.Location('avdecc.xsd', 133, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_stream_ports')), pyxb.utils.utility.Location('avdecc.xsd', 134, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_stream_ports')), pyxb.utils.utility.Location('avdecc.xsd', 135, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_external_ports')), pyxb.utils.utility.Location('avdecc.xsd', 136, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_external_ports')), pyxb.utils.utility.Location('avdecc.xsd', 137, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_internal_ports')), pyxb.utils.utility.Location('avdecc.xsd', 138, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_internal_ports')), pyxb.utils.utility.Location('avdecc.xsd', 139, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controls')), pyxb.utils.utility.Location('avdecc.xsd', 140, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors')), pyxb.utils.utility.Location('avdecc.xsd', 141, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mixers')), pyxb.utils.utility.Location('avdecc.xsd', 142, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'matrices')), pyxb.utils.utility.Location('avdecc.xsd', 143, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'splitters')), pyxb.utils.utility.Location('avdecc.xsd', 144, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'combiners')), pyxb.utils.utility.Location('avdecc.xsd', 145, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers')), pyxb.utils.utility.Location('avdecc.xsd', 146, 12))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_14, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiplexers')), pyxb.utils.utility.Location('avdecc.xsd', 147, 12))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_15, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'transcoders')), pyxb.utils.utility.Location('avdecc.xsd', 148, 12))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_16, False))
    symbol = pyxb.binding.content.ElementUse(VideoUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_blocks')), pyxb.utils.utility.Location('avdecc.xsd', 149, 12))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_13, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_13, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_14, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_14, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_15, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_15, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_16, True) ]))
    st_18._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VideoUnitDescriptor._Automaton = _BuildAutomaton_6()




SensorUnitDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sensor_unit'), SensorUnitDescriptor, scope=SensorUnitDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 156, 12)))

def _BuildAutomaton_7 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_7
    del _BuildAutomaton_7
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 156, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sensor_unit')), pyxb.utils.utility.Location('avdecc.xsd', 156, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SensorUnitDescriptors._Automaton = _BuildAutomaton_7()




SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 164, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 165, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), DescriptorIndex, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 166, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_stream_ports'), SensorStreamPortDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 167, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_stream_ports'), SensorStreamPortDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 168, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_external_ports'), ExternalPortDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 169, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_external_ports'), ExternalPortDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 170, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_internal_ports'), InternalPortDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 171, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_internal_ports'), InternalPortDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 172, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controls'), ControlDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 173, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors'), SignalSelectorDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 174, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mixers'), MixerDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 175, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'matrices'), MatrixDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 176, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'splitters'), SignalSplitterDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 177, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'combiners'), SignalCombinerDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 178, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers'), SignalDemultiplexerDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 179, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'multiplexers'), SignalMultiplexerDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 180, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'transcoders'), SignalTranscoderDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 181, 12)))

SensorUnitDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_blocks'), ControlBlockDescriptors, scope=SensorUnitDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 182, 12)))

def _BuildAutomaton_8 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_8
    del _BuildAutomaton_8
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 164, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 167, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 168, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 169, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 170, 12))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 171, 12))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 172, 12))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 173, 12))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 174, 12))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 175, 12))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 176, 12))
    counters.add(cc_10)
    cc_11 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 177, 12))
    counters.add(cc_11)
    cc_12 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 178, 12))
    counters.add(cc_12)
    cc_13 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 179, 12))
    counters.add(cc_13)
    cc_14 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 180, 12))
    counters.add(cc_14)
    cc_15 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 181, 12))
    counters.add(cc_15)
    cc_16 = fac.CounterCondition(min=0L, max=1L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 182, 12))
    counters.add(cc_16)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 164, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 165, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index')), pyxb.utils.utility.Location('avdecc.xsd', 166, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_stream_ports')), pyxb.utils.utility.Location('avdecc.xsd', 167, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_stream_ports')), pyxb.utils.utility.Location('avdecc.xsd', 168, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_external_ports')), pyxb.utils.utility.Location('avdecc.xsd', 169, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_external_ports')), pyxb.utils.utility.Location('avdecc.xsd', 170, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_internal_ports')), pyxb.utils.utility.Location('avdecc.xsd', 171, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_internal_ports')), pyxb.utils.utility.Location('avdecc.xsd', 172, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controls')), pyxb.utils.utility.Location('avdecc.xsd', 173, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_selectors')), pyxb.utils.utility.Location('avdecc.xsd', 174, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mixers')), pyxb.utils.utility.Location('avdecc.xsd', 175, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'matrices')), pyxb.utils.utility.Location('avdecc.xsd', 176, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_11, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'splitters')), pyxb.utils.utility.Location('avdecc.xsd', 177, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_12, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'combiners')), pyxb.utils.utility.Location('avdecc.xsd', 178, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_13, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'demultiplexers')), pyxb.utils.utility.Location('avdecc.xsd', 179, 12))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_14, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'multiplexers')), pyxb.utils.utility.Location('avdecc.xsd', 180, 12))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_15, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'transcoders')), pyxb.utils.utility.Location('avdecc.xsd', 181, 12))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_16, False))
    symbol = pyxb.binding.content.ElementUse(SensorUnitDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_blocks')), pyxb.utils.utility.Location('avdecc.xsd', 182, 12))
    st_18 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_11, True) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_11, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_11, False) ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_12, True) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_12, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_12, False) ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_13, True) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_13, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_13, False) ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_14, True) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_14, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_14, False) ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_15, True) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_15, False) ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_16, True) ]))
    st_18._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SensorUnitDescriptor._Automaton = _BuildAutomaton_8()




StreamDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream'), StreamDescriptor, scope=StreamDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 189, 12)))

def _BuildAutomaton_9 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_9
    del _BuildAutomaton_9
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 189, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(StreamDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream')), pyxb.utils.utility.Location('avdecc.xsd', 189, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
StreamDescriptors._Automaton = _BuildAutomaton_9()




StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 197, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 198, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), DescriptorIndex, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 199, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream_flags'), Doublet, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 200, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_stream_format'), StreamFormat, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 201, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_entity_id0'), EUI64, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 202, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_uniqueid0'), Doublet, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 203, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_entity_id1'), EUI64, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 204, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_uniqueid1'), Doublet, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 205, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_entity_id2'), EUI64, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 206, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_uniqueid2'), Doublet, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 207, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'backed_up_talker_entity_id'), EUI64, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 208, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'backed_up_talker_uniqueid'), Doublet, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 209, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'avb_interface_index'), DescriptorIndex, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 210, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'buffer_length'), Quadlet, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 211, 12)))

StreamDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream_formats'), StreamFormats, scope=StreamDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 212, 12)))

def _BuildAutomaton_10 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_10
    del _BuildAutomaton_10
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 197, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 197, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 198, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index')), pyxb.utils.utility.Location('avdecc.xsd', 199, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream_flags')), pyxb.utils.utility.Location('avdecc.xsd', 200, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_stream_format')), pyxb.utils.utility.Location('avdecc.xsd', 201, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_entity_id0')), pyxb.utils.utility.Location('avdecc.xsd', 202, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_uniqueid0')), pyxb.utils.utility.Location('avdecc.xsd', 203, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_entity_id1')), pyxb.utils.utility.Location('avdecc.xsd', 204, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_uniqueid1')), pyxb.utils.utility.Location('avdecc.xsd', 205, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_entity_id2')), pyxb.utils.utility.Location('avdecc.xsd', 206, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'backup_talker_uniqueid2')), pyxb.utils.utility.Location('avdecc.xsd', 207, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'backed_up_talker_entity_id')), pyxb.utils.utility.Location('avdecc.xsd', 208, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'backed_up_talker_uniqueid')), pyxb.utils.utility.Location('avdecc.xsd', 209, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'avb_interface_index')), pyxb.utils.utility.Location('avdecc.xsd', 210, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'buffer_length')), pyxb.utils.utility.Location('avdecc.xsd', 211, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(StreamDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream_formats')), pyxb.utils.utility.Location('avdecc.xsd', 212, 12))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
         ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
         ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
         ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
         ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    st_15._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
StreamDescriptor._Automaton = _BuildAutomaton_10()




JackDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'jack'), JackDescriptor, scope=JackDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 219, 12)))

def _BuildAutomaton_11 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_11
    del _BuildAutomaton_11
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 219, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(JackDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'jack')), pyxb.utils.utility.Location('avdecc.xsd', 219, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
JackDescriptors._Automaton = _BuildAutomaton_11()




JackDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=JackDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 227, 12)))

JackDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=JackDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 228, 12)))

JackDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'jack_flags'), Doublet, scope=JackDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 229, 12)))

JackDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'jack_type'), Doublet, scope=JackDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 230, 12)))

JackDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controls'), ControlDescriptors, scope=JackDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 231, 12)))

def _BuildAutomaton_12 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_12
    del _BuildAutomaton_12
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 227, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 231, 12))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(JackDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 227, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(JackDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 228, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(JackDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'jack_flags')), pyxb.utils.utility.Location('avdecc.xsd', 229, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(JackDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'jack_type')), pyxb.utils.utility.Location('avdecc.xsd', 230, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(JackDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controls')), pyxb.utils.utility.Location('avdecc.xsd', 231, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
JackDescriptor._Automaton = _BuildAutomaton_12()




AVBInterfaceDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'avb_interface'), AVBInterfaceDescriptor, scope=AVBInterfaceDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 238, 12)))

def _BuildAutomaton_13 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_13
    del _BuildAutomaton_13
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 238, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'avb_interface')), pyxb.utils.utility.Location('avdecc.xsd', 238, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
AVBInterfaceDescriptors._Automaton = _BuildAutomaton_13()




AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 246, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 247, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mac_address'), MAC, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 248, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_identity'), EUI64, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 249, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'interface_flags'), Doublet, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 250, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'priority1'), Octet, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 251, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_class'), Octet, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 252, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'offset_scaled_log_variance'), Doublet, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 253, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_accuracy'), Octet, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 254, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'priority2'), Octet, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 255, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'domain_number'), Octet, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 256, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'log_sync_interval'), Octet, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 257, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'log_announce_interval'), Octet, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 258, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'log_pdelay_interval'), Octet, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 259, 12)))

AVBInterfaceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'port_number'), Doublet, scope=AVBInterfaceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 260, 12)))

def _BuildAutomaton_14 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_14
    del _BuildAutomaton_14
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 246, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 246, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 247, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mac_address')), pyxb.utils.utility.Location('avdecc.xsd', 248, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_identity')), pyxb.utils.utility.Location('avdecc.xsd', 249, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'interface_flags')), pyxb.utils.utility.Location('avdecc.xsd', 250, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'priority1')), pyxb.utils.utility.Location('avdecc.xsd', 251, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_class')), pyxb.utils.utility.Location('avdecc.xsd', 252, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'offset_scaled_log_variance')), pyxb.utils.utility.Location('avdecc.xsd', 253, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_accuracy')), pyxb.utils.utility.Location('avdecc.xsd', 254, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'priority2')), pyxb.utils.utility.Location('avdecc.xsd', 255, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'domain_number')), pyxb.utils.utility.Location('avdecc.xsd', 256, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'log_sync_interval')), pyxb.utils.utility.Location('avdecc.xsd', 257, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'log_announce_interval')), pyxb.utils.utility.Location('avdecc.xsd', 258, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'log_pdelay_interval')), pyxb.utils.utility.Location('avdecc.xsd', 259, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AVBInterfaceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'port_number')), pyxb.utils.utility.Location('avdecc.xsd', 260, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
         ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
         ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
         ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    st_14._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AVBInterfaceDescriptor._Automaton = _BuildAutomaton_14()




ClockSourceDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_source'), ClockSourceDescriptor, scope=ClockSourceDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 267, 12)))

def _BuildAutomaton_15 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_15
    del _BuildAutomaton_15
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 267, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ClockSourceDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_source')), pyxb.utils.utility.Location('avdecc.xsd', 267, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ClockSourceDescriptors._Automaton = _BuildAutomaton_15()




ClockSourceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=ClockSourceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 275, 12)))

ClockSourceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=ClockSourceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 276, 12)))

ClockSourceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_source_flags'), Doublet, scope=ClockSourceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 277, 12)))

ClockSourceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_source_type'), Doublet, scope=ClockSourceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 278, 12)))

ClockSourceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_source_id'), EUI64, scope=ClockSourceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 279, 12)))

ClockSourceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_source_location_type'), DescriptorType, scope=ClockSourceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 280, 12)))

ClockSourceDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_source_location_index'), DescriptorIndex, scope=ClockSourceDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 281, 12)))

def _BuildAutomaton_16 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_16
    del _BuildAutomaton_16
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 275, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ClockSourceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 275, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ClockSourceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 276, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ClockSourceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_source_flags')), pyxb.utils.utility.Location('avdecc.xsd', 277, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ClockSourceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_source_type')), pyxb.utils.utility.Location('avdecc.xsd', 278, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ClockSourceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_source_id')), pyxb.utils.utility.Location('avdecc.xsd', 279, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ClockSourceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_source_location_type')), pyxb.utils.utility.Location('avdecc.xsd', 280, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ClockSourceDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_source_location_index')), pyxb.utils.utility.Location('avdecc.xsd', 281, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ClockSourceDescriptor._Automaton = _BuildAutomaton_16()




MemoryObjectDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'memory_object'), MemoryObjectDescriptor, scope=MemoryObjectDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 288, 12)))

def _BuildAutomaton_17 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_17
    del _BuildAutomaton_17
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 288, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MemoryObjectDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'memory_object')), pyxb.utils.utility.Location('avdecc.xsd', 288, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
MemoryObjectDescriptors._Automaton = _BuildAutomaton_17()




MemoryObjectDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=MemoryObjectDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 296, 12)))

MemoryObjectDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=MemoryObjectDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 297, 12)))

MemoryObjectDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'memory_object_type'), Doublet, scope=MemoryObjectDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 298, 12)))

MemoryObjectDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'target_descriptor_type'), DescriptorType, scope=MemoryObjectDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 299, 12)))

MemoryObjectDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'target_descriptor_index'), DescriptorIndex, scope=MemoryObjectDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 300, 12)))

MemoryObjectDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'start_address'), Octlet, scope=MemoryObjectDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 301, 12)))

MemoryObjectDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum_length'), Octlet, scope=MemoryObjectDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 302, 12)))

MemoryObjectDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'length'), Octlet, scope=MemoryObjectDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 303, 12)))

MemoryObjectDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'data_url'), pyxb.binding.datatypes.anyURI, scope=MemoryObjectDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 305, 16)))

MemoryObjectDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'data'), HexBlobData, scope=MemoryObjectDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 306, 16)))

def _BuildAutomaton_18 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_18
    del _BuildAutomaton_18
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 296, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 304, 12))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MemoryObjectDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 296, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MemoryObjectDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 297, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MemoryObjectDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'memory_object_type')), pyxb.utils.utility.Location('avdecc.xsd', 298, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MemoryObjectDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'target_descriptor_type')), pyxb.utils.utility.Location('avdecc.xsd', 299, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MemoryObjectDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'target_descriptor_index')), pyxb.utils.utility.Location('avdecc.xsd', 300, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MemoryObjectDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'start_address')), pyxb.utils.utility.Location('avdecc.xsd', 301, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MemoryObjectDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum_length')), pyxb.utils.utility.Location('avdecc.xsd', 302, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MemoryObjectDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'length')), pyxb.utils.utility.Location('avdecc.xsd', 303, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MemoryObjectDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'data_url')), pyxb.utils.utility.Location('avdecc.xsd', 305, 16))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(MemoryObjectDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'data')), pyxb.utils.utility.Location('avdecc.xsd', 306, 16))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MemoryObjectDescriptor._Automaton = _BuildAutomaton_18()




LocaleDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'locale'), LocaleDescriptor, scope=LocaleDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 314, 12)))

def _BuildAutomaton_19 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_19
    del _BuildAutomaton_19
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 314, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(LocaleDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'locale')), pyxb.utils.utility.Location('avdecc.xsd', 314, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
LocaleDescriptors._Automaton = _BuildAutomaton_19()




LocaleDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'locale_identifier'), AVDECCString, scope=LocaleDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 322, 12)))

LocaleDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'locale_strings'), StringsDescriptors, scope=LocaleDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 323, 12)))

def _BuildAutomaton_20 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_20
    del _BuildAutomaton_20
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(LocaleDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'locale_identifier')), pyxb.utils.utility.Location('avdecc.xsd', 322, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(LocaleDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'locale_strings')), pyxb.utils.utility.Location('avdecc.xsd', 323, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
LocaleDescriptor._Automaton = _BuildAutomaton_20()




StringsDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'strings'), StringsDescriptor, scope=StringsDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 330, 12)))

def _BuildAutomaton_21 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_21
    del _BuildAutomaton_21
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 330, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(StringsDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'strings')), pyxb.utils.utility.Location('avdecc.xsd', 330, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
StringsDescriptors._Automaton = _BuildAutomaton_21()




StringsDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'string'), AVDECCString, scope=StringsDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 339, 12)))

def _BuildAutomaton_22 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_22
    del _BuildAutomaton_22
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=7L, metadata=pyxb.utils.utility.Location('avdecc.xsd', 339, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(StringsDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'string')), pyxb.utils.utility.Location('avdecc.xsd', 339, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
StringsDescriptor._Automaton = _BuildAutomaton_22()




AudioStreamPortDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream_port'), AudioStreamPortDescriptor, scope=AudioStreamPortDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 346, 12)))

def _BuildAutomaton_23 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_23
    del _BuildAutomaton_23
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 346, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(AudioStreamPortDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream_port')), pyxb.utils.utility.Location('avdecc.xsd', 346, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
AudioStreamPortDescriptors._Automaton = _BuildAutomaton_23()




AudioStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), DescriptorIndex, scope=AudioStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 354, 12)))

AudioStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'port_flags'), Doublet, scope=AudioStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 355, 12)))

AudioStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controls'), ControlDescriptors, scope=AudioStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 356, 12)))

AudioStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clusters'), AudioClusterDescriptors, scope=AudioStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 357, 12)))

AudioStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maps'), AudioMapDescriptors, scope=AudioStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 358, 12)))

def _BuildAutomaton_24 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_24
    del _BuildAutomaton_24
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 356, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 358, 12))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index')), pyxb.utils.utility.Location('avdecc.xsd', 354, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'port_flags')), pyxb.utils.utility.Location('avdecc.xsd', 355, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controls')), pyxb.utils.utility.Location('avdecc.xsd', 356, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AudioStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clusters')), pyxb.utils.utility.Location('avdecc.xsd', 357, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(AudioStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maps')), pyxb.utils.utility.Location('avdecc.xsd', 358, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AudioStreamPortDescriptor._Automaton = _BuildAutomaton_24()




VideoStreamPortDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream_port'), VideoStreamPortDescriptor, scope=VideoStreamPortDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 365, 12)))

def _BuildAutomaton_25 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_25
    del _BuildAutomaton_25
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 365, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoStreamPortDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream_port')), pyxb.utils.utility.Location('avdecc.xsd', 365, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
VideoStreamPortDescriptors._Automaton = _BuildAutomaton_25()




VideoStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), DescriptorIndex, scope=VideoStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 373, 12)))

VideoStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'port_flags'), Doublet, scope=VideoStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 374, 12)))

VideoStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controls'), ControlDescriptors, scope=VideoStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 375, 12)))

VideoStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clusters'), VideoClusterDescriptors, scope=VideoStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 376, 12)))

VideoStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maps'), VideoMapDescriptors, scope=VideoStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 377, 12)))

def _BuildAutomaton_26 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_26
    del _BuildAutomaton_26
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 375, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 377, 12))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index')), pyxb.utils.utility.Location('avdecc.xsd', 373, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'port_flags')), pyxb.utils.utility.Location('avdecc.xsd', 374, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controls')), pyxb.utils.utility.Location('avdecc.xsd', 375, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clusters')), pyxb.utils.utility.Location('avdecc.xsd', 376, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(VideoStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maps')), pyxb.utils.utility.Location('avdecc.xsd', 377, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VideoStreamPortDescriptor._Automaton = _BuildAutomaton_26()




SensorStreamPortDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream_port'), SensorStreamPortDescriptor, scope=SensorStreamPortDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 384, 12)))

def _BuildAutomaton_27 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_27
    del _BuildAutomaton_27
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 384, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SensorStreamPortDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream_port')), pyxb.utils.utility.Location('avdecc.xsd', 384, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SensorStreamPortDescriptors._Automaton = _BuildAutomaton_27()




SensorStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), DescriptorIndex, scope=SensorStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 392, 12)))

SensorStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'port_flags'), Doublet, scope=SensorStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 393, 12)))

SensorStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controls'), ControlDescriptors, scope=SensorStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 394, 12)))

SensorStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clusters'), SensorClusterDescriptors, scope=SensorStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 395, 12)))

SensorStreamPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maps'), SensorMapDescriptors, scope=SensorStreamPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 396, 12)))

def _BuildAutomaton_28 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_28
    del _BuildAutomaton_28
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 394, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 396, 12))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index')), pyxb.utils.utility.Location('avdecc.xsd', 392, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'port_flags')), pyxb.utils.utility.Location('avdecc.xsd', 393, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controls')), pyxb.utils.utility.Location('avdecc.xsd', 394, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SensorStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clusters')), pyxb.utils.utility.Location('avdecc.xsd', 395, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(SensorStreamPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maps')), pyxb.utils.utility.Location('avdecc.xsd', 396, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SensorStreamPortDescriptor._Automaton = _BuildAutomaton_28()




ExternalPortDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'external_port'), ExternalPortDescriptor, scope=ExternalPortDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 403, 12)))

def _BuildAutomaton_29 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_29
    del _BuildAutomaton_29
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 403, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ExternalPortDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'external_port')), pyxb.utils.utility.Location('avdecc.xsd', 403, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ExternalPortDescriptors._Automaton = _BuildAutomaton_29()




ExternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), DescriptorIndex, scope=ExternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 411, 12)))

ExternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'port_flags'), Doublet, scope=ExternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 412, 12)))

ExternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controls'), ControlDescriptors, scope=ExternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 413, 12)))

ExternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=ExternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 414, 12)))

ExternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=ExternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 415, 12)))

ExternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=ExternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 416, 12)))

ExternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=ExternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 417, 12)))

ExternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'jack_index'), DescriptorIndex, scope=ExternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 418, 12)))

def _BuildAutomaton_30 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_30
    del _BuildAutomaton_30
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 413, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ExternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index')), pyxb.utils.utility.Location('avdecc.xsd', 411, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ExternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'port_flags')), pyxb.utils.utility.Location('avdecc.xsd', 412, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ExternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controls')), pyxb.utils.utility.Location('avdecc.xsd', 413, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ExternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 414, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ExternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 415, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ExternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 416, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ExternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 417, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ExternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'jack_index')), pyxb.utils.utility.Location('avdecc.xsd', 418, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ExternalPortDescriptor._Automaton = _BuildAutomaton_30()




InternalPortDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'internal_port'), InternalPortDescriptor, scope=InternalPortDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 425, 12)))

def _BuildAutomaton_31 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_31
    del _BuildAutomaton_31
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 425, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(InternalPortDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'internal_port')), pyxb.utils.utility.Location('avdecc.xsd', 425, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
InternalPortDescriptors._Automaton = _BuildAutomaton_31()




InternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index'), DescriptorIndex, scope=InternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 433, 12)))

InternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'port_flags'), Doublet, scope=InternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 434, 12)))

InternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controls'), ControlDescriptors, scope=InternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 435, 12)))

InternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=InternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 436, 12)))

InternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=InternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 437, 12)))

InternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=InternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 438, 12)))

InternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=InternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 439, 12)))

InternalPortDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'internal_index'), DescriptorIndex, scope=InternalPortDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 440, 12)))

def _BuildAutomaton_32 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_32
    del _BuildAutomaton_32
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 435, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_domain_index')), pyxb.utils.utility.Location('avdecc.xsd', 433, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'port_flags')), pyxb.utils.utility.Location('avdecc.xsd', 434, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controls')), pyxb.utils.utility.Location('avdecc.xsd', 435, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 436, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 437, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 438, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(InternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 439, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(InternalPortDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'internal_index')), pyxb.utils.utility.Location('avdecc.xsd', 440, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
InternalPortDescriptor._Automaton = _BuildAutomaton_32()




AudioClusterDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'audio_cluster'), AudioClusterDescriptor, scope=AudioClusterDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 447, 12)))

def _BuildAutomaton_33 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_33
    del _BuildAutomaton_33
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 447, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(AudioClusterDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'audio_cluster')), pyxb.utils.utility.Location('avdecc.xsd', 447, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
AudioClusterDescriptors._Automaton = _BuildAutomaton_33()




AudioClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=AudioClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 455, 12)))

AudioClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=AudioClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 456, 12)))

AudioClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=AudioClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 457, 12)))

AudioClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=AudioClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 458, 12)))

AudioClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=AudioClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 459, 12)))

AudioClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'path_latency'), Quadlet, scope=AudioClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 460, 12)))

AudioClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=AudioClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 461, 12)))

AudioClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'channel_count'), Doublet, scope=AudioClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 462, 12)))

AudioClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'format'), Octet, scope=AudioClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 463, 12)))

def _BuildAutomaton_34 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_34
    del _BuildAutomaton_34
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 455, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 455, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 456, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 457, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 458, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 459, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'path_latency')), pyxb.utils.utility.Location('avdecc.xsd', 460, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 461, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'channel_count')), pyxb.utils.utility.Location('avdecc.xsd', 462, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AudioClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'format')), pyxb.utils.utility.Location('avdecc.xsd', 463, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AudioClusterDescriptor._Automaton = _BuildAutomaton_34()




VideoClusterDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'video_cluster'), VideoClusterDescriptor, scope=VideoClusterDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 470, 12)))

def _BuildAutomaton_35 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_35
    del _BuildAutomaton_35
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 470, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'video_cluster')), pyxb.utils.utility.Location('avdecc.xsd', 470, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
VideoClusterDescriptors._Automaton = _BuildAutomaton_35()




VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 478, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 479, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 480, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 481, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 482, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'path_latency'), Quadlet, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 483, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 484, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'format'), Octet, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 485, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_format_specific'), Quadlet, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 486, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_sampling_rate'), SamplingRate, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 487, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_aspect_ratio'), AspectRatio, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 488, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_video_size'), VideoSize, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 489, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_color_space'), ColorSpace, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 490, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'format_specifics'), VideoClusterFormatSpecifics, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 491, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sampling_rates'), SamplingRates, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 492, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'aspect_ratios'), VideoClusterAspectRatios, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 493, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'video_sizes'), VideoClusterSizes, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 494, 12)))

VideoClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'color_spaces'), VideoClusterColorSpaces, scope=VideoClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 495, 12)))

def _BuildAutomaton_36 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_36
    del _BuildAutomaton_36
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 478, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 478, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 479, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 480, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 481, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 482, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'path_latency')), pyxb.utils.utility.Location('avdecc.xsd', 483, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 484, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'format')), pyxb.utils.utility.Location('avdecc.xsd', 485, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_format_specific')), pyxb.utils.utility.Location('avdecc.xsd', 486, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_sampling_rate')), pyxb.utils.utility.Location('avdecc.xsd', 487, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_aspect_ratio')), pyxb.utils.utility.Location('avdecc.xsd', 488, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_video_size')), pyxb.utils.utility.Location('avdecc.xsd', 489, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_color_space')), pyxb.utils.utility.Location('avdecc.xsd', 490, 12))
    st_12 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'format_specifics')), pyxb.utils.utility.Location('avdecc.xsd', 491, 12))
    st_13 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sampling_rates')), pyxb.utils.utility.Location('avdecc.xsd', 492, 12))
    st_14 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'aspect_ratios')), pyxb.utils.utility.Location('avdecc.xsd', 493, 12))
    st_15 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'video_sizes')), pyxb.utils.utility.Location('avdecc.xsd', 494, 12))
    st_16 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'color_spaces')), pyxb.utils.utility.Location('avdecc.xsd', 495, 12))
    st_17 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_12, [
         ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_13, [
         ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_14, [
         ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_15, [
         ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_16, [
         ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_17, [
         ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    st_17._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VideoClusterDescriptor._Automaton = _BuildAutomaton_36()




VideoClusterFormatSpecifics._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'format_specific'), Quadlet, scope=VideoClusterFormatSpecifics, location=pyxb.utils.utility.Location('avdecc.xsd', 501, 12)))

def _BuildAutomaton_37 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_37
    del _BuildAutomaton_37
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 501, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoClusterFormatSpecifics._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'format_specific')), pyxb.utils.utility.Location('avdecc.xsd', 501, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
VideoClusterFormatSpecifics._Automaton = _BuildAutomaton_37()




VideoClusterAspectRatios._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'aspect_ratio'), AspectRatio, scope=VideoClusterAspectRatios, location=pyxb.utils.utility.Location('avdecc.xsd', 506, 12)))

def _BuildAutomaton_38 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_38
    del _BuildAutomaton_38
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 506, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoClusterAspectRatios._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'aspect_ratio')), pyxb.utils.utility.Location('avdecc.xsd', 506, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
VideoClusterAspectRatios._Automaton = _BuildAutomaton_38()




VideoClusterSizes._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'video_size'), VideoSize, scope=VideoClusterSizes, location=pyxb.utils.utility.Location('avdecc.xsd', 511, 12)))

def _BuildAutomaton_39 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_39
    del _BuildAutomaton_39
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 511, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoClusterSizes._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'video_size')), pyxb.utils.utility.Location('avdecc.xsd', 511, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
VideoClusterSizes._Automaton = _BuildAutomaton_39()




VideoClusterColorSpaces._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'color_space'), ColorSpace, scope=VideoClusterColorSpaces, location=pyxb.utils.utility.Location('avdecc.xsd', 516, 12)))

def _BuildAutomaton_40 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_40
    del _BuildAutomaton_40
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 516, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoClusterColorSpaces._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'color_space')), pyxb.utils.utility.Location('avdecc.xsd', 516, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
VideoClusterColorSpaces._Automaton = _BuildAutomaton_40()




SensorClusterDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sensor_cluster'), SensorClusterDescriptor, scope=SensorClusterDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 522, 12)))

def _BuildAutomaton_41 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_41
    del _BuildAutomaton_41
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 522, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sensor_cluster')), pyxb.utils.utility.Location('avdecc.xsd', 522, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SensorClusterDescriptors._Automaton = _BuildAutomaton_41()




SensorClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=SensorClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 530, 12)))

SensorClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=SensorClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 531, 12)))

SensorClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=SensorClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 532, 12)))

SensorClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=SensorClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 533, 12)))

SensorClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=SensorClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 534, 12)))

SensorClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'path_latency'), Quadlet, scope=SensorClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 535, 12)))

SensorClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=SensorClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 536, 12)))

SensorClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_sensor_format'), StreamFormat, scope=SensorClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 537, 12)))

SensorClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sampling_rate'), SamplingRate, scope=SensorClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 538, 12)))

SensorClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sensor_formats'), SensorFormats, scope=SensorClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 539, 12)))

SensorClusterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sampling_rates'), SamplingRates, scope=SensorClusterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 540, 12)))

def _BuildAutomaton_42 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_42
    del _BuildAutomaton_42
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 530, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 530, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 531, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 532, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 533, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 534, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'path_latency')), pyxb.utils.utility.Location('avdecc.xsd', 535, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 536, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_sensor_format')), pyxb.utils.utility.Location('avdecc.xsd', 537, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sampling_rate')), pyxb.utils.utility.Location('avdecc.xsd', 538, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sensor_formats')), pyxb.utils.utility.Location('avdecc.xsd', 539, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SensorClusterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sampling_rates')), pyxb.utils.utility.Location('avdecc.xsd', 540, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    st_10._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SensorClusterDescriptor._Automaton = _BuildAutomaton_42()




SensorFormats._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sensor_format'), StreamFormat, scope=SensorFormats, location=pyxb.utils.utility.Location('avdecc.xsd', 546, 12)))

def _BuildAutomaton_43 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_43
    del _BuildAutomaton_43
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 546, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SensorFormats._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sensor_format')), pyxb.utils.utility.Location('avdecc.xsd', 546, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SensorFormats._Automaton = _BuildAutomaton_43()




AudioMapDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'audio_map'), AudioMapDescriptor, scope=AudioMapDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 553, 12)))

def _BuildAutomaton_44 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_44
    del _BuildAutomaton_44
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 553, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(AudioMapDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'audio_map')), pyxb.utils.utility.Location('avdecc.xsd', 553, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
AudioMapDescriptors._Automaton = _BuildAutomaton_44()




AudioMapDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'audio_mapping'), AudioMapping, scope=AudioMapDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 561, 12)))

def _BuildAutomaton_45 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_45
    del _BuildAutomaton_45
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 561, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(AudioMapDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'audio_mapping')), pyxb.utils.utility.Location('avdecc.xsd', 561, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
AudioMapDescriptor._Automaton = _BuildAutomaton_45()




AudioMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream_index'), DescriptorIndex, scope=AudioMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 567, 12)))

AudioMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream_channel'), Doublet, scope=AudioMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 568, 12)))

AudioMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cluster_offset'), Doublet, scope=AudioMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 569, 12)))

AudioMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cluster_channel'), Doublet, scope=AudioMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 570, 12)))

def _BuildAutomaton_46 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_46
    del _BuildAutomaton_46
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream_index')), pyxb.utils.utility.Location('avdecc.xsd', 567, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream_channel')), pyxb.utils.utility.Location('avdecc.xsd', 568, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AudioMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'cluster_offset')), pyxb.utils.utility.Location('avdecc.xsd', 569, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AudioMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'cluster_channel')), pyxb.utils.utility.Location('avdecc.xsd', 570, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AudioMapping._Automaton = _BuildAutomaton_46()




VideoMapDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'video_map'), VideoMapDescriptor, scope=VideoMapDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 576, 12)))

def _BuildAutomaton_47 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_47
    del _BuildAutomaton_47
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 576, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoMapDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'video_map')), pyxb.utils.utility.Location('avdecc.xsd', 576, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
VideoMapDescriptors._Automaton = _BuildAutomaton_47()




VideoMapDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'video_mapping'), VideoMapping, scope=VideoMapDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 584, 12)))

def _BuildAutomaton_48 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_48
    del _BuildAutomaton_48
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 584, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(VideoMapDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'video_mapping')), pyxb.utils.utility.Location('avdecc.xsd', 584, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
VideoMapDescriptor._Automaton = _BuildAutomaton_48()




VideoMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream_index'), DescriptorIndex, scope=VideoMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 590, 12)))

VideoMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'program_stream'), Doublet, scope=VideoMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 591, 12)))

VideoMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'elementary_stream'), Doublet, scope=VideoMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 592, 12)))

VideoMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cluster_offset'), Doublet, scope=VideoMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 593, 12)))

def _BuildAutomaton_49 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_49
    del _BuildAutomaton_49
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream_index')), pyxb.utils.utility.Location('avdecc.xsd', 590, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'program_stream')), pyxb.utils.utility.Location('avdecc.xsd', 591, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'elementary_stream')), pyxb.utils.utility.Location('avdecc.xsd', 592, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'cluster_offset')), pyxb.utils.utility.Location('avdecc.xsd', 593, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VideoMapping._Automaton = _BuildAutomaton_49()




SensorMapDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sensor_map'), SensorMapDescriptor, scope=SensorMapDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 599, 12)))

def _BuildAutomaton_50 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_50
    del _BuildAutomaton_50
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 599, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SensorMapDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sensor_map')), pyxb.utils.utility.Location('avdecc.xsd', 599, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SensorMapDescriptors._Automaton = _BuildAutomaton_50()




SensorMapDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sensor_mapping'), SensorMapping, scope=SensorMapDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 604, 12)))

def _BuildAutomaton_51 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_51
    del _BuildAutomaton_51
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 604, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SensorMapDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sensor_mapping')), pyxb.utils.utility.Location('avdecc.xsd', 604, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SensorMapDescriptor._Automaton = _BuildAutomaton_51()




SensorMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream_index'), DescriptorIndex, scope=SensorMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 613, 12)))

SensorMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream_signal'), Doublet, scope=SensorMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 614, 12)))

SensorMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'cluster_offset'), Doublet, scope=SensorMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 615, 12)))

def _BuildAutomaton_52 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_52
    del _BuildAutomaton_52
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream_index')), pyxb.utils.utility.Location('avdecc.xsd', 613, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SensorMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream_signal')), pyxb.utils.utility.Location('avdecc.xsd', 614, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SensorMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'cluster_offset')), pyxb.utils.utility.Location('avdecc.xsd', 615, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SensorMapping._Automaton = _BuildAutomaton_52()




ControlDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control'), ControlDescriptor, scope=ControlDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 622, 12)))

def _BuildAutomaton_53 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_53
    del _BuildAutomaton_53
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 622, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ControlDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control')), pyxb.utils.utility.Location('avdecc.xsd', 622, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ControlDescriptors._Automaton = _BuildAutomaton_53()




ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 630, 12)))

ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 631, 12)))

ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 632, 12)))

ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), Quadlet, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 633, 12)))

ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), DescriptorIndex, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 634, 12)))

ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_type'), EUI64, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 635, 12)))

ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_value_type'), Doublet, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 636, 12)))

ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'reset_time'), Quadlet, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 637, 12)))

ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 638, 12)))

ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 639, 12)))

ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 640, 12)))

ControlDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'values'), Values, scope=ControlDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 641, 12)))

def _BuildAutomaton_54 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_54
    del _BuildAutomaton_54
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 630, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 630, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 631, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 632, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_latency')), pyxb.utils.utility.Location('avdecc.xsd', 633, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_domain')), pyxb.utils.utility.Location('avdecc.xsd', 634, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_type')), pyxb.utils.utility.Location('avdecc.xsd', 635, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_value_type')), pyxb.utils.utility.Location('avdecc.xsd', 636, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'reset_time')), pyxb.utils.utility.Location('avdecc.xsd', 637, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 638, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 639, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 640, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ControlDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'values')), pyxb.utils.utility.Location('avdecc.xsd', 641, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ControlDescriptor._Automaton = _BuildAutomaton_54()




SignalSelectorDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_selector'), SignalSelectorDescriptor, scope=SignalSelectorDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 648, 12)))

def _BuildAutomaton_55 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_55
    del _BuildAutomaton_55
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 648, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_selector')), pyxb.utils.utility.Location('avdecc.xsd', 648, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignalSelectorDescriptors._Automaton = _BuildAutomaton_55()




SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 656, 12)))

SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 657, 12)))

SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 658, 12)))

SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), Quadlet, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 659, 12)))

SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), DescriptorIndex, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 660, 12)))

SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_signal_type'), DescriptorType, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 661, 12)))

SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_signal_index'), DescriptorIndex, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 662, 12)))

SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_signal_output'), Doublet, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 663, 12)))

SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default_signal_type'), DescriptorType, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 664, 12)))

SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default_signal_index'), DescriptorIndex, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 665, 12)))

SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default_signal_output'), Doublet, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 666, 12)))

SignalSelectorDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sources'), SignalSelectorSignalSources, scope=SignalSelectorDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 667, 12)))

def _BuildAutomaton_56 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_56
    del _BuildAutomaton_56
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 656, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 656, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 657, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 658, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_latency')), pyxb.utils.utility.Location('avdecc.xsd', 659, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_domain')), pyxb.utils.utility.Location('avdecc.xsd', 660, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 661, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 662, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 663, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default_signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 664, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default_signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 665, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default_signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 666, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalSelectorDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sources')), pyxb.utils.utility.Location('avdecc.xsd', 667, 12))
    st_11 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_11, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    st_11._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalSelectorDescriptor._Automaton = _BuildAutomaton_56()




SignalSelectorSignalSources._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal'), SignalSelectorSignalSource, scope=SignalSelectorSignalSources, location=pyxb.utils.utility.Location('avdecc.xsd', 673, 12)))

def _BuildAutomaton_57 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_57
    del _BuildAutomaton_57
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalSelectorSignalSources._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal')), pyxb.utils.utility.Location('avdecc.xsd', 673, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalSelectorSignalSources._Automaton = _BuildAutomaton_57()




SignalSelectorSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=SignalSelectorSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 678, 12)))

SignalSelectorSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=SignalSelectorSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 679, 12)))

SignalSelectorSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=SignalSelectorSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 680, 12)))

def _BuildAutomaton_58 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_58
    del _BuildAutomaton_58
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 678, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSelectorSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 679, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalSelectorSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 680, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalSelectorSignalSource._Automaton = _BuildAutomaton_58()




MixerDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mixer'), MixerDescriptor, scope=MixerDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 686, 12)))

def _BuildAutomaton_59 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_59
    del _BuildAutomaton_59
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 686, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MixerDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mixer')), pyxb.utils.utility.Location('avdecc.xsd', 686, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
MixerDescriptors._Automaton = _BuildAutomaton_59()




MixerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=MixerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 694, 12)))

MixerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=MixerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 695, 12)))

MixerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=MixerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 696, 12)))

MixerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), Quadlet, scope=MixerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 697, 12)))

MixerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), DescriptorIndex, scope=MixerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 698, 12)))

MixerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_value_type'), Doublet, scope=MixerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 699, 12)))

MixerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sources'), MixerSignalSources, scope=MixerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 700, 12)))

MixerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'values'), Values, scope=MixerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 701, 12)))

def _BuildAutomaton_60 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_60
    del _BuildAutomaton_60
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 694, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MixerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 694, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MixerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 695, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MixerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 696, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MixerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_latency')), pyxb.utils.utility.Location('avdecc.xsd', 697, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MixerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_domain')), pyxb.utils.utility.Location('avdecc.xsd', 698, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MixerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_value_type')), pyxb.utils.utility.Location('avdecc.xsd', 699, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MixerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sources')), pyxb.utils.utility.Location('avdecc.xsd', 700, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MixerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'values')), pyxb.utils.utility.Location('avdecc.xsd', 701, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MixerDescriptor._Automaton = _BuildAutomaton_60()




MixerSignalSources._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal'), MixerSignalSource, scope=MixerSignalSources, location=pyxb.utils.utility.Location('avdecc.xsd', 707, 12)))

def _BuildAutomaton_61 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_61
    del _BuildAutomaton_61
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MixerSignalSources._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal')), pyxb.utils.utility.Location('avdecc.xsd', 707, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MixerSignalSources._Automaton = _BuildAutomaton_61()




MixerSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=MixerSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 712, 12)))

MixerSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=MixerSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 713, 12)))

MixerSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=MixerSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 714, 12)))

def _BuildAutomaton_62 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_62
    del _BuildAutomaton_62
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MixerSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 712, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MixerSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 713, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MixerSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 714, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MixerSignalSource._Automaton = _BuildAutomaton_62()




MatrixDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'matrix'), MatrixDescriptor, scope=MatrixDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 720, 12)))

def _BuildAutomaton_63 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_63
    del _BuildAutomaton_63
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 720, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'matrix')), pyxb.utils.utility.Location('avdecc.xsd', 720, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
MatrixDescriptors._Automaton = _BuildAutomaton_63()




MatrixDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=MatrixDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 728, 12)))

MatrixDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=MatrixDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 729, 12)))

MatrixDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=MatrixDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 730, 12)))

MatrixDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), Quadlet, scope=MatrixDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 731, 12)))

MatrixDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), DescriptorIndex, scope=MatrixDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 732, 12)))

MatrixDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_type'), EUI64, scope=MatrixDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 733, 12)))

MatrixDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_value_type'), Doublet, scope=MatrixDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 734, 12)))

MatrixDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'width'), Doublet, scope=MatrixDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 735, 12)))

MatrixDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'height'), Doublet, scope=MatrixDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 736, 12)))

MatrixDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'values'), Values, scope=MatrixDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 737, 12)))

MatrixDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sources'), MatrixSignalDescriptors, scope=MatrixDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 738, 12)))

def _BuildAutomaton_64 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_64
    del _BuildAutomaton_64
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 728, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 728, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 729, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 730, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_latency')), pyxb.utils.utility.Location('avdecc.xsd', 731, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_domain')), pyxb.utils.utility.Location('avdecc.xsd', 732, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_type')), pyxb.utils.utility.Location('avdecc.xsd', 733, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_value_type')), pyxb.utils.utility.Location('avdecc.xsd', 734, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'width')), pyxb.utils.utility.Location('avdecc.xsd', 735, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'height')), pyxb.utils.utility.Location('avdecc.xsd', 736, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'values')), pyxb.utils.utility.Location('avdecc.xsd', 737, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MatrixDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sources')), pyxb.utils.utility.Location('avdecc.xsd', 738, 12))
    st_10 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_10, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    st_10._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MatrixDescriptor._Automaton = _BuildAutomaton_64()




MatrixSignalDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'matrix_signal'), MatrixSignalDescriptor, scope=MatrixSignalDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 745, 12)))

def _BuildAutomaton_65 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_65
    del _BuildAutomaton_65
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MatrixSignalDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'matrix_signal')), pyxb.utils.utility.Location('avdecc.xsd', 745, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MatrixSignalDescriptors._Automaton = _BuildAutomaton_65()




MatrixSignalDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signals'), MatrixSignalSourceContent, scope=MatrixSignalDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 754, 12)))

def _BuildAutomaton_66 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_66
    del _BuildAutomaton_66
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 754, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MatrixSignalDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signals')), pyxb.utils.utility.Location('avdecc.xsd', 754, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
MatrixSignalDescriptor._Automaton = _BuildAutomaton_66()




MatrixSignalSourceContent._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal'), MatrixSignalSource, scope=MatrixSignalSourceContent, location=pyxb.utils.utility.Location('avdecc.xsd', 760, 12)))

def _BuildAutomaton_67 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_67
    del _BuildAutomaton_67
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 760, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(MatrixSignalSourceContent._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal')), pyxb.utils.utility.Location('avdecc.xsd', 760, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
MatrixSignalSourceContent._Automaton = _BuildAutomaton_67()




MatrixSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=MatrixSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 765, 12)))

MatrixSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=MatrixSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 766, 12)))

MatrixSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=MatrixSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 767, 12)))

def _BuildAutomaton_68 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_68
    del _BuildAutomaton_68
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 765, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(MatrixSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 766, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(MatrixSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 767, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
MatrixSignalSource._Automaton = _BuildAutomaton_68()




SignalSplitterDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_splitter'), SignalSplitterDescriptor, scope=SignalSplitterDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 773, 12)))

def _BuildAutomaton_69 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_69
    del _BuildAutomaton_69
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 773, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignalSplitterDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_splitter')), pyxb.utils.utility.Location('avdecc.xsd', 773, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignalSplitterDescriptors._Automaton = _BuildAutomaton_69()




SignalSplitterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=SignalSplitterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 781, 12)))

SignalSplitterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=SignalSplitterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 782, 12)))

SignalSplitterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=SignalSplitterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 783, 12)))

SignalSplitterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), Quadlet, scope=SignalSplitterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 784, 12)))

SignalSplitterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), DescriptorIndex, scope=SignalSplitterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 785, 12)))

SignalSplitterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=SignalSplitterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 786, 12)))

SignalSplitterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=SignalSplitterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 787, 12)))

SignalSplitterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=SignalSplitterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 788, 12)))

SignalSplitterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'number_of_outputs'), Doublet, scope=SignalSplitterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 789, 12)))

SignalSplitterDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mapping'), SignalSplitterMappings, scope=SignalSplitterDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 790, 12)))

def _BuildAutomaton_70 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_70
    del _BuildAutomaton_70
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 781, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSplitterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 781, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSplitterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 782, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSplitterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 783, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSplitterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_latency')), pyxb.utils.utility.Location('avdecc.xsd', 784, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSplitterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_domain')), pyxb.utils.utility.Location('avdecc.xsd', 785, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSplitterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 786, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSplitterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 787, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSplitterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 788, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSplitterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'number_of_outputs')), pyxb.utils.utility.Location('avdecc.xsd', 789, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalSplitterDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mapping')), pyxb.utils.utility.Location('avdecc.xsd', 790, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalSplitterDescriptor._Automaton = _BuildAutomaton_70()




SignalSplitterMappings._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'splitter_mapping'), SignalSplitterMapping, scope=SignalSplitterMappings, location=pyxb.utils.utility.Location('avdecc.xsd', 796, 12)))

def _BuildAutomaton_71 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_71
    del _BuildAutomaton_71
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 796, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignalSplitterMappings._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'splitter_mapping')), pyxb.utils.utility.Location('avdecc.xsd', 796, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignalSplitterMappings._Automaton = _BuildAutomaton_71()




SignalSplitterMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_start'), Doublet, scope=SignalSplitterMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 801, 12)))

SignalSplitterMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_count'), Doublet, scope=SignalSplitterMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 802, 12)))

SignalSplitterMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_index'), Doublet, scope=SignalSplitterMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 803, 12)))

def _BuildAutomaton_72 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_72
    del _BuildAutomaton_72
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSplitterMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_start')), pyxb.utils.utility.Location('avdecc.xsd', 801, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalSplitterMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_count')), pyxb.utils.utility.Location('avdecc.xsd', 802, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalSplitterMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_index')), pyxb.utils.utility.Location('avdecc.xsd', 803, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalSplitterMapping._Automaton = _BuildAutomaton_72()




SignalCombinerDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_combiner'), SignalCombinerDescriptor, scope=SignalCombinerDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 809, 12)))

def _BuildAutomaton_73 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_73
    del _BuildAutomaton_73
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 809, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignalCombinerDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_combiner')), pyxb.utils.utility.Location('avdecc.xsd', 809, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignalCombinerDescriptors._Automaton = _BuildAutomaton_73()




SignalCombinerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=SignalCombinerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 817, 12)))

SignalCombinerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=SignalCombinerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 818, 12)))

SignalCombinerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=SignalCombinerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 819, 12)))

SignalCombinerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), Quadlet, scope=SignalCombinerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 820, 12)))

SignalCombinerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), DescriptorIndex, scope=SignalCombinerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 821, 12)))

SignalCombinerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sources'), SignalCombinerSources, scope=SignalCombinerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 822, 12)))

SignalCombinerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mapping'), SignalCombinerMappings, scope=SignalCombinerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 823, 12)))

def _BuildAutomaton_74 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_74
    del _BuildAutomaton_74
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 817, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalCombinerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 817, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalCombinerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 818, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalCombinerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 819, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalCombinerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_latency')), pyxb.utils.utility.Location('avdecc.xsd', 820, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalCombinerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_domain')), pyxb.utils.utility.Location('avdecc.xsd', 821, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalCombinerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sources')), pyxb.utils.utility.Location('avdecc.xsd', 822, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalCombinerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mapping')), pyxb.utils.utility.Location('avdecc.xsd', 823, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalCombinerDescriptor._Automaton = _BuildAutomaton_74()




SignalCombinerSources._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal'), SignalCombinerSource, scope=SignalCombinerSources, location=pyxb.utils.utility.Location('avdecc.xsd', 829, 12)))

def _BuildAutomaton_75 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_75
    del _BuildAutomaton_75
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalCombinerSources._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal')), pyxb.utils.utility.Location('avdecc.xsd', 829, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalCombinerSources._Automaton = _BuildAutomaton_75()




SignalCombinerSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=SignalCombinerSource, location=pyxb.utils.utility.Location('avdecc.xsd', 834, 12)))

SignalCombinerSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=SignalCombinerSource, location=pyxb.utils.utility.Location('avdecc.xsd', 835, 12)))

SignalCombinerSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=SignalCombinerSource, location=pyxb.utils.utility.Location('avdecc.xsd', 836, 12)))

def _BuildAutomaton_76 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_76
    del _BuildAutomaton_76
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalCombinerSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 834, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalCombinerSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 835, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalCombinerSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 836, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalCombinerSource._Automaton = _BuildAutomaton_76()




SignalCombinerMappings._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'combiner_mapping'), SignalCombinerMapping, scope=SignalCombinerMappings, location=pyxb.utils.utility.Location('avdecc.xsd', 841, 12)))

def _BuildAutomaton_77 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_77
    del _BuildAutomaton_77
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 841, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignalCombinerMappings._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'combiner_mapping')), pyxb.utils.utility.Location('avdecc.xsd', 841, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignalCombinerMappings._Automaton = _BuildAutomaton_77()




SignalCombinerMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_start'), Doublet, scope=SignalCombinerMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 846, 12)))

SignalCombinerMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_count'), Doublet, scope=SignalCombinerMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 847, 12)))

SignalCombinerMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'input_index'), Doublet, scope=SignalCombinerMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 848, 12)))

def _BuildAutomaton_78 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_78
    del _BuildAutomaton_78
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalCombinerMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_start')), pyxb.utils.utility.Location('avdecc.xsd', 846, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalCombinerMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_count')), pyxb.utils.utility.Location('avdecc.xsd', 847, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalCombinerMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'input_index')), pyxb.utils.utility.Location('avdecc.xsd', 848, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalCombinerMapping._Automaton = _BuildAutomaton_78()




SignalDemultiplexerDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_demultiplexer'), SignalDemultiplexerDescriptor, scope=SignalDemultiplexerDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 854, 12)))

def _BuildAutomaton_79 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_79
    del _BuildAutomaton_79
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 854, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_demultiplexer')), pyxb.utils.utility.Location('avdecc.xsd', 854, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignalDemultiplexerDescriptors._Automaton = _BuildAutomaton_79()




SignalDemultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=SignalDemultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 862, 12)))

SignalDemultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=SignalDemultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 863, 12)))

SignalDemultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=SignalDemultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 864, 12)))

SignalDemultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), Quadlet, scope=SignalDemultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 865, 12)))

SignalDemultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), DescriptorIndex, scope=SignalDemultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 866, 12)))

SignalDemultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=SignalDemultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 867, 12)))

SignalDemultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=SignalDemultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 868, 12)))

SignalDemultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=SignalDemultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 869, 12)))

SignalDemultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'number_of_outputs'), Doublet, scope=SignalDemultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 870, 12)))

SignalDemultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mapping'), SignalDemultiplexerMappings, scope=SignalDemultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 871, 12)))

def _BuildAutomaton_80 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_80
    del _BuildAutomaton_80
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 862, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 862, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 863, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 864, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_latency')), pyxb.utils.utility.Location('avdecc.xsd', 865, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_domain')), pyxb.utils.utility.Location('avdecc.xsd', 866, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 867, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 868, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 869, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'number_of_outputs')), pyxb.utils.utility.Location('avdecc.xsd', 870, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mapping')), pyxb.utils.utility.Location('avdecc.xsd', 871, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalDemultiplexerDescriptor._Automaton = _BuildAutomaton_80()




SignalDemultiplexerMappings._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'demultiplexer_mapping'), SignalDemultiplexerMapping, scope=SignalDemultiplexerMappings, location=pyxb.utils.utility.Location('avdecc.xsd', 877, 12)))

def _BuildAutomaton_81 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_81
    del _BuildAutomaton_81
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerMappings._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'demultiplexer_mapping')), pyxb.utils.utility.Location('avdecc.xsd', 877, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalDemultiplexerMappings._Automaton = _BuildAutomaton_81()




SignalDemultiplexerMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_start'), Doublet, scope=SignalDemultiplexerMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 882, 12)))

SignalDemultiplexerMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_count'), Doublet, scope=SignalDemultiplexerMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 883, 12)))

SignalDemultiplexerMapping._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'output_index'), Doublet, scope=SignalDemultiplexerMapping, location=pyxb.utils.utility.Location('avdecc.xsd', 884, 12)))

def _BuildAutomaton_82 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_82
    del _BuildAutomaton_82
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_start')), pyxb.utils.utility.Location('avdecc.xsd', 882, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sub_signal_count')), pyxb.utils.utility.Location('avdecc.xsd', 883, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalDemultiplexerMapping._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'output_index')), pyxb.utils.utility.Location('avdecc.xsd', 884, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalDemultiplexerMapping._Automaton = _BuildAutomaton_82()




SignalMultiplexerDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_multiplexer'), SignalMultiplexerDescriptor, scope=SignalMultiplexerDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 890, 12)))

def _BuildAutomaton_83 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_83
    del _BuildAutomaton_83
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 890, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_multiplexer')), pyxb.utils.utility.Location('avdecc.xsd', 890, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignalMultiplexerDescriptors._Automaton = _BuildAutomaton_83()




SignalMultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=SignalMultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 898, 12)))

SignalMultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=SignalMultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 899, 12)))

SignalMultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=SignalMultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 900, 12)))

SignalMultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), Quadlet, scope=SignalMultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 901, 12)))

SignalMultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), DescriptorIndex, scope=SignalMultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 902, 12)))

SignalMultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sources'), SignalMultiplexerSignalSources, scope=SignalMultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 903, 12)))

SignalMultiplexerDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'mapping'), SignalMultiplexerSignalSourceMappings, scope=SignalMultiplexerDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 904, 12)))

def _BuildAutomaton_84 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_84
    del _BuildAutomaton_84
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 898, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 898, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 899, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 900, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_latency')), pyxb.utils.utility.Location('avdecc.xsd', 901, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_domain')), pyxb.utils.utility.Location('avdecc.xsd', 902, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sources')), pyxb.utils.utility.Location('avdecc.xsd', 903, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'mapping')), pyxb.utils.utility.Location('avdecc.xsd', 904, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalMultiplexerDescriptor._Automaton = _BuildAutomaton_84()




SignalMultiplexerSignalSources._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal'), SignalMultiplexerSignalSource, scope=SignalMultiplexerSignalSources, location=pyxb.utils.utility.Location('avdecc.xsd', 910, 12)))

def _BuildAutomaton_85 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_85
    del _BuildAutomaton_85
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerSignalSources._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal')), pyxb.utils.utility.Location('avdecc.xsd', 910, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalMultiplexerSignalSources._Automaton = _BuildAutomaton_85()




SignalMultiplexerSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=SignalMultiplexerSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 915, 12)))

SignalMultiplexerSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=SignalMultiplexerSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 916, 12)))

SignalMultiplexerSignalSource._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=SignalMultiplexerSignalSource, location=pyxb.utils.utility.Location('avdecc.xsd', 917, 12)))

def _BuildAutomaton_86 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_86
    del _BuildAutomaton_86
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 915, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 916, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerSignalSource._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 917, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalMultiplexerSignalSource._Automaton = _BuildAutomaton_86()




SignalMultiplexerSignalSourceMappings._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal'), SignalMultiplexerSignalSource, scope=SignalMultiplexerSignalSourceMappings, location=pyxb.utils.utility.Location('avdecc.xsd', 922, 12)))

def _BuildAutomaton_87 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_87
    del _BuildAutomaton_87
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 922, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignalMultiplexerSignalSourceMappings._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal')), pyxb.utils.utility.Location('avdecc.xsd', 922, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignalMultiplexerSignalSourceMappings._Automaton = _BuildAutomaton_87()




SignalTranscoderDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_transcoder'), SignalTranscoderDescriptor, scope=SignalTranscoderDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 928, 12)))

def _BuildAutomaton_88 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_88
    del _BuildAutomaton_88
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 928, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignalTranscoderDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_transcoder')), pyxb.utils.utility.Location('avdecc.xsd', 928, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignalTranscoderDescriptors._Automaton = _BuildAutomaton_88()




SignalTranscoderDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=SignalTranscoderDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 936, 12)))

SignalTranscoderDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=SignalTranscoderDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 937, 12)))

SignalTranscoderDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'block_latency'), Quadlet, scope=SignalTranscoderDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 938, 12)))

SignalTranscoderDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_latency'), Quadlet, scope=SignalTranscoderDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 939, 12)))

SignalTranscoderDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_domain'), DescriptorIndex, scope=SignalTranscoderDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 940, 12)))

SignalTranscoderDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_value_type'), Doublet, scope=SignalTranscoderDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 941, 12)))

SignalTranscoderDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_type'), DescriptorType, scope=SignalTranscoderDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 942, 12)))

SignalTranscoderDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_index'), DescriptorIndex, scope=SignalTranscoderDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 943, 12)))

SignalTranscoderDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'signal_output'), Doublet, scope=SignalTranscoderDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 944, 12)))

SignalTranscoderDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'values'), Values, scope=SignalTranscoderDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 945, 12)))

def _BuildAutomaton_89 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_89
    del _BuildAutomaton_89
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 936, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalTranscoderDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 936, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalTranscoderDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 937, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalTranscoderDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'block_latency')), pyxb.utils.utility.Location('avdecc.xsd', 938, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalTranscoderDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_latency')), pyxb.utils.utility.Location('avdecc.xsd', 939, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalTranscoderDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_domain')), pyxb.utils.utility.Location('avdecc.xsd', 940, 12))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalTranscoderDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_value_type')), pyxb.utils.utility.Location('avdecc.xsd', 941, 12))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalTranscoderDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_type')), pyxb.utils.utility.Location('avdecc.xsd', 942, 12))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalTranscoderDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_index')), pyxb.utils.utility.Location('avdecc.xsd', 943, 12))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SignalTranscoderDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'signal_output')), pyxb.utils.utility.Location('avdecc.xsd', 944, 12))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SignalTranscoderDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'values')), pyxb.utils.utility.Location('avdecc.xsd', 945, 12))
    st_9 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_9, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SignalTranscoderDescriptor._Automaton = _BuildAutomaton_89()




ClockDomainDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_domain'), ClockDomainDescriptor, scope=ClockDomainDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 952, 12)))

def _BuildAutomaton_90 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_90
    del _BuildAutomaton_90
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 952, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ClockDomainDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_domain')), pyxb.utils.utility.Location('avdecc.xsd', 952, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ClockDomainDescriptors._Automaton = _BuildAutomaton_90()




ClockDomainDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=ClockDomainDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 960, 12)))

ClockDomainDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=ClockDomainDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 961, 12)))

ClockDomainDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_source_index'), DescriptorIndex, scope=ClockDomainDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 962, 12)))

ClockDomainDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_sources'), ClockSourceIndexes, scope=ClockDomainDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 963, 12)))

def _BuildAutomaton_91 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_91
    del _BuildAutomaton_91
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 960, 12))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ClockDomainDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 960, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ClockDomainDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 961, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ClockDomainDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_source_index')), pyxb.utils.utility.Location('avdecc.xsd', 962, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ClockDomainDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_sources')), pyxb.utils.utility.Location('avdecc.xsd', 963, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ClockDomainDescriptor._Automaton = _BuildAutomaton_91()




ClockSourceIndexes._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'clock_source_index'), DescriptorIndex, scope=ClockSourceIndexes, location=pyxb.utils.utility.Location('avdecc.xsd', 969, 12)))

def _BuildAutomaton_92 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_92
    del _BuildAutomaton_92
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 969, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ClockSourceIndexes._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'clock_source_index')), pyxb.utils.utility.Location('avdecc.xsd', 969, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ClockSourceIndexes._Automaton = _BuildAutomaton_92()




ControlBlockDescriptors._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'control_block'), ControlBlockDescriptor, scope=ControlBlockDescriptors, location=pyxb.utils.utility.Location('avdecc.xsd', 975, 12)))

def _BuildAutomaton_93 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_93
    del _BuildAutomaton_93
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 975, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(ControlBlockDescriptors._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'control_block')), pyxb.utils.utility.Location('avdecc.xsd', 975, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
ControlBlockDescriptors._Automaton = _BuildAutomaton_93()




ControlBlockDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'object_name'), AVDECCString, scope=ControlBlockDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 983, 12)))

ControlBlockDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_description'), LocalizedStringContainer, scope=ControlBlockDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 984, 12)))

ControlBlockDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'final_control_index'), DescriptorIndex, scope=ControlBlockDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 985, 12)))

ControlBlockDescriptor._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'controls'), ControlDescriptors, scope=ControlBlockDescriptor, location=pyxb.utils.utility.Location('avdecc.xsd', 986, 12)))

def _BuildAutomaton_94 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_94
    del _BuildAutomaton_94
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 983, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 986, 12))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlBlockDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'object_name')), pyxb.utils.utility.Location('avdecc.xsd', 983, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(ControlBlockDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_description')), pyxb.utils.utility.Location('avdecc.xsd', 984, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(ControlBlockDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'final_control_index')), pyxb.utils.utility.Location('avdecc.xsd', 985, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(ControlBlockDescriptor._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'controls')), pyxb.utils.utility.Location('avdecc.xsd', 986, 12))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
ControlBlockDescriptor._Automaton = _BuildAutomaton_94()




StreamFormats._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'stream_format'), StreamFormat, scope=StreamFormats, location=pyxb.utils.utility.Location('avdecc.xsd', 1755, 12)))

def _BuildAutomaton_95 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_95
    del _BuildAutomaton_95
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1755, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(StreamFormats._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'stream_format')), pyxb.utils.utility.Location('avdecc.xsd', 1755, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
StreamFormats._Automaton = _BuildAutomaton_95()




AspectRatio._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pixel_width'), Octet, scope=AspectRatio, location=pyxb.utils.utility.Location('avdecc.xsd', 1761, 12)))

AspectRatio._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pixel_height'), Octet, scope=AspectRatio, location=pyxb.utils.utility.Location('avdecc.xsd', 1762, 12)))

def _BuildAutomaton_96 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_96
    del _BuildAutomaton_96
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(AspectRatio._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pixel_width')), pyxb.utils.utility.Location('avdecc.xsd', 1761, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(AspectRatio._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pixel_height')), pyxb.utils.utility.Location('avdecc.xsd', 1762, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
AspectRatio._Automaton = _BuildAutomaton_96()




LocalizedStringContainer._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'localized_string'), LocalizedString, scope=LocalizedStringContainer, location=pyxb.utils.utility.Location('avdecc.xsd', 1768, 12)))

def _BuildAutomaton_97 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_97
    del _BuildAutomaton_97
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(LocalizedStringContainer._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'localized_string')), pyxb.utils.utility.Location('avdecc.xsd', 1768, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
LocalizedStringContainer._Automaton = _BuildAutomaton_97()




LocalizedString._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'offset'), Doublet, scope=LocalizedString, location=pyxb.utils.utility.Location('avdecc.xsd', 1774, 12)))

LocalizedString._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'index'), Octet, scope=LocalizedString, location=pyxb.utils.utility.Location('avdecc.xsd', 1775, 12)))

def _BuildAutomaton_98 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_98
    del _BuildAutomaton_98
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(LocalizedString._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'offset')), pyxb.utils.utility.Location('avdecc.xsd', 1774, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(LocalizedString._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'index')), pyxb.utils.utility.Location('avdecc.xsd', 1775, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
LocalizedString._Automaton = _BuildAutomaton_98()




VideoSize._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'frame_width'), Doublet, scope=VideoSize, location=pyxb.utils.utility.Location('avdecc.xsd', 1781, 12)))

VideoSize._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'frame_height'), Doublet, scope=VideoSize, location=pyxb.utils.utility.Location('avdecc.xsd', 1782, 12)))

def _BuildAutomaton_99 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_99
    del _BuildAutomaton_99
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(VideoSize._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'frame_width')), pyxb.utils.utility.Location('avdecc.xsd', 1781, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(VideoSize._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'frame_height')), pyxb.utils.utility.Location('avdecc.xsd', 1782, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
VideoSize._Automaton = _BuildAutomaton_99()




BodePlot._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'frequency'), Float, scope=BodePlot, location=pyxb.utils.utility.Location('avdecc.xsd', 1788, 12)))

BodePlot._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'magnitude'), Float, scope=BodePlot, location=pyxb.utils.utility.Location('avdecc.xsd', 1789, 12)))

BodePlot._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'phase'), Float, scope=BodePlot, location=pyxb.utils.utility.Location('avdecc.xsd', 1790, 12)))

def _BuildAutomaton_100 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_100
    del _BuildAutomaton_100
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(BodePlot._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'frequency')), pyxb.utils.utility.Location('avdecc.xsd', 1788, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(BodePlot._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'magnitude')), pyxb.utils.utility.Location('avdecc.xsd', 1789, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(BodePlot._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'phase')), pyxb.utils.utility.Location('avdecc.xsd', 1790, 12))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
BodePlot._Automaton = _BuildAutomaton_100()




BodePlotPoint._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'bode_plot'), BodePlot, scope=BodePlotPoint, location=pyxb.utils.utility.Location('avdecc.xsd', 1795, 12)))

def _BuildAutomaton_101 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_101
    del _BuildAutomaton_101
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(BodePlotPoint._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'bode_plot')), pyxb.utils.utility.Location('avdecc.xsd', 1795, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
BodePlotPoint._Automaton = _BuildAutomaton_101()




BodePlotList._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'bode_plot'), BodePlot, scope=BodePlotList, location=pyxb.utils.utility.Location('avdecc.xsd', 1800, 12)))

def _BuildAutomaton_102 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_102
    del _BuildAutomaton_102
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1800, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(BodePlotList._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'bode_plot')), pyxb.utils.utility.Location('avdecc.xsd', 1800, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
BodePlotList._Automaton = _BuildAutomaton_102()




SamplingRates._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'sampling_rate'), SamplingRate, scope=SamplingRates, location=pyxb.utils.utility.Location('avdecc.xsd', 1806, 12)))

def _BuildAutomaton_103 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_103
    del _BuildAutomaton_103
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1806, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SamplingRates._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'sampling_rate')), pyxb.utils.utility.Location('avdecc.xsd', 1806, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SamplingRates._Automaton = _BuildAutomaton_103()




SamplingRate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pull'), Octet, scope=SamplingRate, location=pyxb.utils.utility.Location('avdecc.xsd', 1811, 12)))

SamplingRate._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'base_frequency'), Quadlet, scope=SamplingRate, location=pyxb.utils.utility.Location('avdecc.xsd', 1812, 12)))

def _BuildAutomaton_104 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_104
    del _BuildAutomaton_104
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(SamplingRate._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pull')), pyxb.utils.utility.Location('avdecc.xsd', 1811, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(SamplingRate._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'base_frequency')), pyxb.utils.utility.Location('avdecc.xsd', 1812, 12))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
SamplingRate._Automaton = _BuildAutomaton_104()




Values._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'value'), Value, scope=Values, location=pyxb.utils.utility.Location('avdecc.xsd', 1818, 12)))

def _BuildAutomaton_105 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_105
    del _BuildAutomaton_105
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1818, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(Values._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'value')), pyxb.utils.utility.Location('avdecc.xsd', 1818, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
Values._Automaton = _BuildAutomaton_105()




SignedOctetOptions._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'option'), Octet, scope=SignedOctetOptions, location=pyxb.utils.utility.Location('avdecc.xsd', 1825, 12)))

def _BuildAutomaton_106 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_106
    del _BuildAutomaton_106
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1825, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignedOctetOptions._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'option')), pyxb.utils.utility.Location('avdecc.xsd', 1825, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignedOctetOptions._Automaton = _BuildAutomaton_106()




UnsignedOctetOptions._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'option'), Octet, scope=UnsignedOctetOptions, location=pyxb.utils.utility.Location('avdecc.xsd', 1830, 12)))

def _BuildAutomaton_107 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_107
    del _BuildAutomaton_107
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1830, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(UnsignedOctetOptions._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'option')), pyxb.utils.utility.Location('avdecc.xsd', 1830, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
UnsignedOctetOptions._Automaton = _BuildAutomaton_107()




SignedDoubletOptions._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'option'), Doublet, scope=SignedDoubletOptions, location=pyxb.utils.utility.Location('avdecc.xsd', 1835, 12)))

def _BuildAutomaton_108 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_108
    del _BuildAutomaton_108
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1835, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignedDoubletOptions._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'option')), pyxb.utils.utility.Location('avdecc.xsd', 1835, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignedDoubletOptions._Automaton = _BuildAutomaton_108()




UnsignedDoubletOptions._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'option'), Doublet, scope=UnsignedDoubletOptions, location=pyxb.utils.utility.Location('avdecc.xsd', 1840, 12)))

def _BuildAutomaton_109 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_109
    del _BuildAutomaton_109
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1840, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(UnsignedDoubletOptions._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'option')), pyxb.utils.utility.Location('avdecc.xsd', 1840, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
UnsignedDoubletOptions._Automaton = _BuildAutomaton_109()




SignedQuadletOptions._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'option'), Quadlet, scope=SignedQuadletOptions, location=pyxb.utils.utility.Location('avdecc.xsd', 1845, 12)))

def _BuildAutomaton_110 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_110
    del _BuildAutomaton_110
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1845, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignedQuadletOptions._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'option')), pyxb.utils.utility.Location('avdecc.xsd', 1845, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignedQuadletOptions._Automaton = _BuildAutomaton_110()




UnsignedQuadletOptions._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'option'), Quadlet, scope=UnsignedQuadletOptions, location=pyxb.utils.utility.Location('avdecc.xsd', 1850, 12)))

def _BuildAutomaton_111 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_111
    del _BuildAutomaton_111
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1850, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(UnsignedQuadletOptions._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'option')), pyxb.utils.utility.Location('avdecc.xsd', 1850, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
UnsignedQuadletOptions._Automaton = _BuildAutomaton_111()




SignedOctletOptions._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'option'), Octlet, scope=SignedOctletOptions, location=pyxb.utils.utility.Location('avdecc.xsd', 1855, 12)))

def _BuildAutomaton_112 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_112
    del _BuildAutomaton_112
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1855, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(SignedOctletOptions._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'option')), pyxb.utils.utility.Location('avdecc.xsd', 1855, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
SignedOctletOptions._Automaton = _BuildAutomaton_112()




UnsignedOctletOptions._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'option'), Octlet, scope=UnsignedOctletOptions, location=pyxb.utils.utility.Location('avdecc.xsd', 1860, 12)))

def _BuildAutomaton_113 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_113
    del _BuildAutomaton_113
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1860, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(UnsignedOctletOptions._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'option')), pyxb.utils.utility.Location('avdecc.xsd', 1860, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
UnsignedOctletOptions._Automaton = _BuildAutomaton_113()




FloatOptions._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'option'), Float, scope=FloatOptions, location=pyxb.utils.utility.Location('avdecc.xsd', 1865, 12)))

def _BuildAutomaton_114 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_114
    del _BuildAutomaton_114
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1865, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(FloatOptions._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'option')), pyxb.utils.utility.Location('avdecc.xsd', 1865, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
FloatOptions._Automaton = _BuildAutomaton_114()




DoubleOptions._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'option'), Double, scope=DoubleOptions, location=pyxb.utils.utility.Location('avdecc.xsd', 1870, 12)))

def _BuildAutomaton_115 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_115
    del _BuildAutomaton_115
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1870, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(DoubleOptions._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'option')), pyxb.utils.utility.Location('avdecc.xsd', 1870, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
DoubleOptions._Automaton = _BuildAutomaton_115()




LocalizedStringContainerOptions._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'option'), LocalizedStringContainer, scope=LocalizedStringContainerOptions, location=pyxb.utils.utility.Location('avdecc.xsd', 1875, 12)))

def _BuildAutomaton_116 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_116
    del _BuildAutomaton_116
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1875, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(LocalizedStringContainerOptions._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'option')), pyxb.utils.utility.Location('avdecc.xsd', 1875, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
LocalizedStringContainerOptions._Automaton = _BuildAutomaton_116()




CurrentSignedOctets._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octet, scope=CurrentSignedOctets, location=pyxb.utils.utility.Location('avdecc.xsd', 1881, 12)))

def _BuildAutomaton_117 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_117
    del _BuildAutomaton_117
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1881, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CurrentSignedOctets._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1881, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CurrentSignedOctets._Automaton = _BuildAutomaton_117()




CurrentUnsignedOctets._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octet, scope=CurrentUnsignedOctets, location=pyxb.utils.utility.Location('avdecc.xsd', 1886, 12)))

def _BuildAutomaton_118 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_118
    del _BuildAutomaton_118
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1886, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CurrentUnsignedOctets._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1886, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CurrentUnsignedOctets._Automaton = _BuildAutomaton_118()




CurrentSignedDoublets._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Doublet, scope=CurrentSignedDoublets, location=pyxb.utils.utility.Location('avdecc.xsd', 1891, 12)))

def _BuildAutomaton_119 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_119
    del _BuildAutomaton_119
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1891, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CurrentSignedDoublets._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1891, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CurrentSignedDoublets._Automaton = _BuildAutomaton_119()




CurrentUnsignedDoublets._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Doublet, scope=CurrentUnsignedDoublets, location=pyxb.utils.utility.Location('avdecc.xsd', 1896, 12)))

def _BuildAutomaton_120 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_120
    del _BuildAutomaton_120
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1896, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CurrentUnsignedDoublets._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1896, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CurrentUnsignedDoublets._Automaton = _BuildAutomaton_120()




CurrentSignedQuadlets._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Quadlet, scope=CurrentSignedQuadlets, location=pyxb.utils.utility.Location('avdecc.xsd', 1901, 12)))

def _BuildAutomaton_121 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_121
    del _BuildAutomaton_121
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1901, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CurrentSignedQuadlets._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1901, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CurrentSignedQuadlets._Automaton = _BuildAutomaton_121()




CurrentUnsignedQuadlets._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Quadlet, scope=CurrentUnsignedQuadlets, location=pyxb.utils.utility.Location('avdecc.xsd', 1906, 12)))

def _BuildAutomaton_122 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_122
    del _BuildAutomaton_122
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1906, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CurrentUnsignedQuadlets._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1906, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CurrentUnsignedQuadlets._Automaton = _BuildAutomaton_122()




CurrentSignedOctlets._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octlet, scope=CurrentSignedOctlets, location=pyxb.utils.utility.Location('avdecc.xsd', 1911, 12)))

def _BuildAutomaton_123 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_123
    del _BuildAutomaton_123
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1911, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CurrentSignedOctlets._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1911, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CurrentSignedOctlets._Automaton = _BuildAutomaton_123()




CurrentUnsignedOctlets._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octlet, scope=CurrentUnsignedOctlets, location=pyxb.utils.utility.Location('avdecc.xsd', 1916, 12)))

def _BuildAutomaton_124 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_124
    del _BuildAutomaton_124
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1916, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CurrentUnsignedOctlets._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1916, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CurrentUnsignedOctlets._Automaton = _BuildAutomaton_124()




CurrentFloats._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Float, scope=CurrentFloats, location=pyxb.utils.utility.Location('avdecc.xsd', 1921, 12)))

def _BuildAutomaton_125 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_125
    del _BuildAutomaton_125
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1921, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CurrentFloats._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1921, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CurrentFloats._Automaton = _BuildAutomaton_125()




CurrentDoubles._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Double, scope=CurrentDoubles, location=pyxb.utils.utility.Location('avdecc.xsd', 1926, 12)))

def _BuildAutomaton_126 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_126
    del _BuildAutomaton_126
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=None, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1926, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CurrentDoubles._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1926, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CurrentDoubles._Automaton = _BuildAutomaton_126()




T0000._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'string'), LocalizedStringContainer, scope=T0000, location=pyxb.utils.utility.Location('avdecc.xsd', 1006, 20)))

T0000._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0000, location=pyxb.utils.utility.Location('avdecc.xsd', 1007, 20)))

T0000._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Octet, scope=T0000, location=pyxb.utils.utility.Location('avdecc.xsd', 1008, 20)))

T0000._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Octet, scope=T0000, location=pyxb.utils.utility.Location('avdecc.xsd', 1009, 20)))

T0000._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Octet, scope=T0000, location=pyxb.utils.utility.Location('avdecc.xsd', 1010, 20)))

T0000._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octet, scope=T0000, location=pyxb.utils.utility.Location('avdecc.xsd', 1011, 20)))

T0000._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octet, scope=T0000, location=pyxb.utils.utility.Location('avdecc.xsd', 1012, 20)))

def _BuildAutomaton_127 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_127
    del _BuildAutomaton_127
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1011, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0000._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'string')), pyxb.utils.utility.Location('avdecc.xsd', 1006, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0000._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1007, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0000._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1008, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0000._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1009, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0000._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1010, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0000._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1011, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0000._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1012, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0000._Automaton = _BuildAutomaton_127()




T0001._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'string'), LocalizedStringContainer, scope=T0001, location=pyxb.utils.utility.Location('avdecc.xsd', 1025, 20)))

T0001._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0001, location=pyxb.utils.utility.Location('avdecc.xsd', 1026, 20)))

T0001._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Octet, scope=T0001, location=pyxb.utils.utility.Location('avdecc.xsd', 1027, 20)))

T0001._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Octet, scope=T0001, location=pyxb.utils.utility.Location('avdecc.xsd', 1028, 20)))

T0001._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Octet, scope=T0001, location=pyxb.utils.utility.Location('avdecc.xsd', 1029, 20)))

T0001._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octet, scope=T0001, location=pyxb.utils.utility.Location('avdecc.xsd', 1030, 20)))

T0001._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octet, scope=T0001, location=pyxb.utils.utility.Location('avdecc.xsd', 1031, 20)))

def _BuildAutomaton_128 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_128
    del _BuildAutomaton_128
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1030, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0001._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'string')), pyxb.utils.utility.Location('avdecc.xsd', 1025, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0001._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1026, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0001._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1027, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0001._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1028, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0001._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1029, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0001._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1030, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0001._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1031, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0001._Automaton = _BuildAutomaton_128()




T0002._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'string'), LocalizedStringContainer, scope=T0002, location=pyxb.utils.utility.Location('avdecc.xsd', 1044, 20)))

T0002._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0002, location=pyxb.utils.utility.Location('avdecc.xsd', 1045, 20)))

T0002._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Doublet, scope=T0002, location=pyxb.utils.utility.Location('avdecc.xsd', 1046, 20)))

T0002._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Doublet, scope=T0002, location=pyxb.utils.utility.Location('avdecc.xsd', 1047, 20)))

T0002._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Doublet, scope=T0002, location=pyxb.utils.utility.Location('avdecc.xsd', 1048, 20)))

T0002._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Doublet, scope=T0002, location=pyxb.utils.utility.Location('avdecc.xsd', 1049, 20)))

T0002._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Doublet, scope=T0002, location=pyxb.utils.utility.Location('avdecc.xsd', 1050, 20)))

def _BuildAutomaton_129 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_129
    del _BuildAutomaton_129
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1049, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0002._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'string')), pyxb.utils.utility.Location('avdecc.xsd', 1044, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0002._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1045, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0002._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1046, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0002._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1047, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0002._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1048, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0002._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1049, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0002._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1050, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0002._Automaton = _BuildAutomaton_129()




T0003._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'string'), LocalizedStringContainer, scope=T0003, location=pyxb.utils.utility.Location('avdecc.xsd', 1063, 20)))

T0003._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0003, location=pyxb.utils.utility.Location('avdecc.xsd', 1064, 20)))

T0003._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Doublet, scope=T0003, location=pyxb.utils.utility.Location('avdecc.xsd', 1065, 20)))

T0003._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Doublet, scope=T0003, location=pyxb.utils.utility.Location('avdecc.xsd', 1066, 20)))

T0003._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Doublet, scope=T0003, location=pyxb.utils.utility.Location('avdecc.xsd', 1067, 20)))

T0003._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Doublet, scope=T0003, location=pyxb.utils.utility.Location('avdecc.xsd', 1068, 20)))

T0003._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Doublet, scope=T0003, location=pyxb.utils.utility.Location('avdecc.xsd', 1069, 20)))

def _BuildAutomaton_130 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_130
    del _BuildAutomaton_130
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1068, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0003._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'string')), pyxb.utils.utility.Location('avdecc.xsd', 1063, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0003._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1064, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0003._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1065, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0003._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1066, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0003._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1067, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0003._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1068, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0003._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1069, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0003._Automaton = _BuildAutomaton_130()




T0004._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'string'), LocalizedStringContainer, scope=T0004, location=pyxb.utils.utility.Location('avdecc.xsd', 1082, 20)))

T0004._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0004, location=pyxb.utils.utility.Location('avdecc.xsd', 1083, 20)))

T0004._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Quadlet, scope=T0004, location=pyxb.utils.utility.Location('avdecc.xsd', 1084, 20)))

T0004._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Quadlet, scope=T0004, location=pyxb.utils.utility.Location('avdecc.xsd', 1085, 20)))

T0004._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Quadlet, scope=T0004, location=pyxb.utils.utility.Location('avdecc.xsd', 1086, 20)))

T0004._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Quadlet, scope=T0004, location=pyxb.utils.utility.Location('avdecc.xsd', 1087, 20)))

T0004._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Quadlet, scope=T0004, location=pyxb.utils.utility.Location('avdecc.xsd', 1088, 20)))

def _BuildAutomaton_131 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_131
    del _BuildAutomaton_131
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1087, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0004._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'string')), pyxb.utils.utility.Location('avdecc.xsd', 1082, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0004._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1083, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0004._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1084, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0004._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1085, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0004._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1086, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0004._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1087, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0004._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1088, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0004._Automaton = _BuildAutomaton_131()




T0005._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'string'), LocalizedStringContainer, scope=T0005, location=pyxb.utils.utility.Location('avdecc.xsd', 1101, 20)))

T0005._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0005, location=pyxb.utils.utility.Location('avdecc.xsd', 1102, 20)))

T0005._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Quadlet, scope=T0005, location=pyxb.utils.utility.Location('avdecc.xsd', 1103, 20)))

T0005._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Quadlet, scope=T0005, location=pyxb.utils.utility.Location('avdecc.xsd', 1104, 20)))

T0005._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Quadlet, scope=T0005, location=pyxb.utils.utility.Location('avdecc.xsd', 1105, 20)))

T0005._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Quadlet, scope=T0005, location=pyxb.utils.utility.Location('avdecc.xsd', 1106, 20)))

T0005._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Quadlet, scope=T0005, location=pyxb.utils.utility.Location('avdecc.xsd', 1107, 20)))

def _BuildAutomaton_132 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_132
    del _BuildAutomaton_132
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1106, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0005._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'string')), pyxb.utils.utility.Location('avdecc.xsd', 1101, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0005._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1102, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0005._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1103, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0005._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1104, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0005._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1105, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0005._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1106, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0005._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1107, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0005._Automaton = _BuildAutomaton_132()




T0006._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'string'), LocalizedStringContainer, scope=T0006, location=pyxb.utils.utility.Location('avdecc.xsd', 1120, 20)))

T0006._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0006, location=pyxb.utils.utility.Location('avdecc.xsd', 1121, 20)))

T0006._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Octlet, scope=T0006, location=pyxb.utils.utility.Location('avdecc.xsd', 1122, 20)))

T0006._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Octlet, scope=T0006, location=pyxb.utils.utility.Location('avdecc.xsd', 1123, 20)))

T0006._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Octlet, scope=T0006, location=pyxb.utils.utility.Location('avdecc.xsd', 1124, 20)))

T0006._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octlet, scope=T0006, location=pyxb.utils.utility.Location('avdecc.xsd', 1125, 20)))

T0006._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octlet, scope=T0006, location=pyxb.utils.utility.Location('avdecc.xsd', 1126, 20)))

def _BuildAutomaton_133 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_133
    del _BuildAutomaton_133
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1125, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0006._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'string')), pyxb.utils.utility.Location('avdecc.xsd', 1120, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0006._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1121, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0006._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1122, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0006._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1123, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0006._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1124, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0006._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1125, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0006._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1126, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0006._Automaton = _BuildAutomaton_133()




T0007._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'string'), LocalizedStringContainer, scope=T0007, location=pyxb.utils.utility.Location('avdecc.xsd', 1139, 20)))

T0007._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0007, location=pyxb.utils.utility.Location('avdecc.xsd', 1140, 20)))

T0007._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Octlet, scope=T0007, location=pyxb.utils.utility.Location('avdecc.xsd', 1141, 20)))

T0007._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Octlet, scope=T0007, location=pyxb.utils.utility.Location('avdecc.xsd', 1142, 20)))

T0007._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Octlet, scope=T0007, location=pyxb.utils.utility.Location('avdecc.xsd', 1143, 20)))

T0007._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octlet, scope=T0007, location=pyxb.utils.utility.Location('avdecc.xsd', 1144, 20)))

T0007._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octlet, scope=T0007, location=pyxb.utils.utility.Location('avdecc.xsd', 1145, 20)))

def _BuildAutomaton_134 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_134
    del _BuildAutomaton_134
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1144, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0007._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'string')), pyxb.utils.utility.Location('avdecc.xsd', 1139, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0007._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1140, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0007._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1141, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0007._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1142, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0007._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1143, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0007._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1144, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0007._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1145, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0007._Automaton = _BuildAutomaton_134()




T0008._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'string'), LocalizedStringContainer, scope=T0008, location=pyxb.utils.utility.Location('avdecc.xsd', 1158, 20)))

T0008._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0008, location=pyxb.utils.utility.Location('avdecc.xsd', 1159, 20)))

T0008._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Float, scope=T0008, location=pyxb.utils.utility.Location('avdecc.xsd', 1160, 20)))

T0008._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Float, scope=T0008, location=pyxb.utils.utility.Location('avdecc.xsd', 1161, 20)))

T0008._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Float, scope=T0008, location=pyxb.utils.utility.Location('avdecc.xsd', 1162, 20)))

T0008._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Float, scope=T0008, location=pyxb.utils.utility.Location('avdecc.xsd', 1163, 20)))

T0008._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Float, scope=T0008, location=pyxb.utils.utility.Location('avdecc.xsd', 1164, 20)))

def _BuildAutomaton_135 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_135
    del _BuildAutomaton_135
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1163, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0008._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'string')), pyxb.utils.utility.Location('avdecc.xsd', 1158, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0008._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1159, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0008._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1160, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0008._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1161, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0008._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1162, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0008._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1163, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0008._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1164, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0008._Automaton = _BuildAutomaton_135()




T0009._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'string'), LocalizedStringContainer, scope=T0009, location=pyxb.utils.utility.Location('avdecc.xsd', 1177, 20)))

T0009._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0009, location=pyxb.utils.utility.Location('avdecc.xsd', 1178, 20)))

T0009._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Double, scope=T0009, location=pyxb.utils.utility.Location('avdecc.xsd', 1179, 20)))

T0009._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Double, scope=T0009, location=pyxb.utils.utility.Location('avdecc.xsd', 1180, 20)))

T0009._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Double, scope=T0009, location=pyxb.utils.utility.Location('avdecc.xsd', 1181, 20)))

T0009._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Double, scope=T0009, location=pyxb.utils.utility.Location('avdecc.xsd', 1182, 20)))

T0009._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Double, scope=T0009, location=pyxb.utils.utility.Location('avdecc.xsd', 1183, 20)))

def _BuildAutomaton_136 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_136
    del _BuildAutomaton_136
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1182, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0009._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'string')), pyxb.utils.utility.Location('avdecc.xsd', 1177, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0009._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1178, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0009._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1179, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0009._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1180, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0009._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1181, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0009._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1182, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0009._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1183, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0009._Automaton = _BuildAutomaton_136()




T000a._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T000a, location=pyxb.utils.utility.Location('avdecc.xsd', 1196, 20)))

T000a._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octet, scope=T000a, location=pyxb.utils.utility.Location('avdecc.xsd', 1197, 20)))

T000a._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octet, scope=T000a, location=pyxb.utils.utility.Location('avdecc.xsd', 1198, 20)))

T000a._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'options'), SignedOctetOptions, scope=T000a, location=pyxb.utils.utility.Location('avdecc.xsd', 1199, 20)))

def _BuildAutomaton_137 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_137
    del _BuildAutomaton_137
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1197, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000a._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1196, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000a._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1197, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000a._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1198, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T000a._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'options')), pyxb.utils.utility.Location('avdecc.xsd', 1199, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T000a._Automaton = _BuildAutomaton_137()




T000b._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T000b, location=pyxb.utils.utility.Location('avdecc.xsd', 1214, 20)))

T000b._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octet, scope=T000b, location=pyxb.utils.utility.Location('avdecc.xsd', 1215, 20)))

T000b._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octet, scope=T000b, location=pyxb.utils.utility.Location('avdecc.xsd', 1216, 20)))

T000b._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'options'), UnsignedOctetOptions, scope=T000b, location=pyxb.utils.utility.Location('avdecc.xsd', 1217, 20)))

def _BuildAutomaton_138 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_138
    del _BuildAutomaton_138
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1215, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000b._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1214, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000b._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1215, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000b._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1216, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T000b._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'options')), pyxb.utils.utility.Location('avdecc.xsd', 1217, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T000b._Automaton = _BuildAutomaton_138()




T000c._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T000c, location=pyxb.utils.utility.Location('avdecc.xsd', 1230, 20)))

T000c._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Doublet, scope=T000c, location=pyxb.utils.utility.Location('avdecc.xsd', 1231, 20)))

T000c._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Doublet, scope=T000c, location=pyxb.utils.utility.Location('avdecc.xsd', 1232, 20)))

T000c._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'options'), SignedDoubletOptions, scope=T000c, location=pyxb.utils.utility.Location('avdecc.xsd', 1233, 20)))

def _BuildAutomaton_139 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_139
    del _BuildAutomaton_139
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1231, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000c._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1230, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000c._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1231, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000c._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1232, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T000c._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'options')), pyxb.utils.utility.Location('avdecc.xsd', 1233, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T000c._Automaton = _BuildAutomaton_139()




T000d._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T000d, location=pyxb.utils.utility.Location('avdecc.xsd', 1246, 20)))

T000d._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Doublet, scope=T000d, location=pyxb.utils.utility.Location('avdecc.xsd', 1247, 20)))

T000d._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Doublet, scope=T000d, location=pyxb.utils.utility.Location('avdecc.xsd', 1248, 20)))

T000d._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'options'), UnsignedDoubletOptions, scope=T000d, location=pyxb.utils.utility.Location('avdecc.xsd', 1249, 20)))

def _BuildAutomaton_140 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_140
    del _BuildAutomaton_140
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1247, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000d._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1246, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000d._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1247, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000d._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1248, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T000d._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'options')), pyxb.utils.utility.Location('avdecc.xsd', 1249, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T000d._Automaton = _BuildAutomaton_140()




T000e._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T000e, location=pyxb.utils.utility.Location('avdecc.xsd', 1262, 20)))

T000e._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Quadlet, scope=T000e, location=pyxb.utils.utility.Location('avdecc.xsd', 1263, 20)))

T000e._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Quadlet, scope=T000e, location=pyxb.utils.utility.Location('avdecc.xsd', 1264, 20)))

T000e._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'options'), SignedQuadletOptions, scope=T000e, location=pyxb.utils.utility.Location('avdecc.xsd', 1265, 20)))

def _BuildAutomaton_141 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_141
    del _BuildAutomaton_141
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1263, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000e._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1262, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000e._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1263, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000e._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1264, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T000e._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'options')), pyxb.utils.utility.Location('avdecc.xsd', 1265, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T000e._Automaton = _BuildAutomaton_141()




T000f._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T000f, location=pyxb.utils.utility.Location('avdecc.xsd', 1278, 20)))

T000f._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Quadlet, scope=T000f, location=pyxb.utils.utility.Location('avdecc.xsd', 1279, 20)))

T000f._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Quadlet, scope=T000f, location=pyxb.utils.utility.Location('avdecc.xsd', 1280, 20)))

T000f._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'options'), UnsignedQuadletOptions, scope=T000f, location=pyxb.utils.utility.Location('avdecc.xsd', 1281, 20)))

def _BuildAutomaton_142 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_142
    del _BuildAutomaton_142
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1279, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000f._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1278, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000f._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1279, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T000f._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1280, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T000f._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'options')), pyxb.utils.utility.Location('avdecc.xsd', 1281, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T000f._Automaton = _BuildAutomaton_142()




T0010._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0010, location=pyxb.utils.utility.Location('avdecc.xsd', 1294, 20)))

T0010._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octlet, scope=T0010, location=pyxb.utils.utility.Location('avdecc.xsd', 1295, 20)))

T0010._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octlet, scope=T0010, location=pyxb.utils.utility.Location('avdecc.xsd', 1296, 20)))

T0010._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'options'), SignedOctletOptions, scope=T0010, location=pyxb.utils.utility.Location('avdecc.xsd', 1297, 20)))

def _BuildAutomaton_143 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_143
    del _BuildAutomaton_143
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1295, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0010._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1294, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0010._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1295, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0010._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1296, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0010._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'options')), pyxb.utils.utility.Location('avdecc.xsd', 1297, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0010._Automaton = _BuildAutomaton_143()




T0011._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0011, location=pyxb.utils.utility.Location('avdecc.xsd', 1310, 20)))

T0011._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Octlet, scope=T0011, location=pyxb.utils.utility.Location('avdecc.xsd', 1311, 20)))

T0011._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octlet, scope=T0011, location=pyxb.utils.utility.Location('avdecc.xsd', 1312, 20)))

T0011._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'options'), UnsignedOctletOptions, scope=T0011, location=pyxb.utils.utility.Location('avdecc.xsd', 1313, 20)))

def _BuildAutomaton_144 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_144
    del _BuildAutomaton_144
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1311, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0011._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1310, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0011._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1311, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0011._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1312, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0011._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'options')), pyxb.utils.utility.Location('avdecc.xsd', 1313, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0011._Automaton = _BuildAutomaton_144()




T0012._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0012, location=pyxb.utils.utility.Location('avdecc.xsd', 1326, 20)))

T0012._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Float, scope=T0012, location=pyxb.utils.utility.Location('avdecc.xsd', 1327, 20)))

T0012._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Float, scope=T0012, location=pyxb.utils.utility.Location('avdecc.xsd', 1328, 20)))

T0012._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'options'), FloatOptions, scope=T0012, location=pyxb.utils.utility.Location('avdecc.xsd', 1329, 20)))

def _BuildAutomaton_145 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_145
    del _BuildAutomaton_145
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1327, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0012._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1326, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0012._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1327, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0012._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1328, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0012._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'options')), pyxb.utils.utility.Location('avdecc.xsd', 1329, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0012._Automaton = _BuildAutomaton_145()




T0013._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0013, location=pyxb.utils.utility.Location('avdecc.xsd', 1342, 20)))

T0013._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), Double, scope=T0013, location=pyxb.utils.utility.Location('avdecc.xsd', 1343, 20)))

T0013._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Double, scope=T0013, location=pyxb.utils.utility.Location('avdecc.xsd', 1344, 20)))

T0013._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'options'), DoubleOptions, scope=T0013, location=pyxb.utils.utility.Location('avdecc.xsd', 1345, 20)))

def _BuildAutomaton_146 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_146
    del _BuildAutomaton_146
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1343, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0013._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1342, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0013._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1343, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0013._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1344, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0013._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'options')), pyxb.utils.utility.Location('avdecc.xsd', 1345, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0013._Automaton = _BuildAutomaton_146()




T0014._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0014, location=pyxb.utils.utility.Location('avdecc.xsd', 1358, 20)))

T0014._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), LocalizedStringContainer, scope=T0014, location=pyxb.utils.utility.Location('avdecc.xsd', 1359, 20)))

T0014._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), LocalizedStringContainer, scope=T0014, location=pyxb.utils.utility.Location('avdecc.xsd', 1360, 20)))

T0014._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'options'), LocalizedStringContainerOptions, scope=T0014, location=pyxb.utils.utility.Location('avdecc.xsd', 1361, 20)))

def _BuildAutomaton_147 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_147
    del _BuildAutomaton_147
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1359, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0014._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1358, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0014._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1359, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0014._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1360, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0014._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'options')), pyxb.utils.utility.Location('avdecc.xsd', 1361, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0014._Automaton = _BuildAutomaton_147()




T0015._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0015, location=pyxb.utils.utility.Location('avdecc.xsd', 1374, 20)))

T0015._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Octet, scope=T0015, location=pyxb.utils.utility.Location('avdecc.xsd', 1375, 20)))

T0015._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Octet, scope=T0015, location=pyxb.utils.utility.Location('avdecc.xsd', 1376, 20)))

T0015._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Octet, scope=T0015, location=pyxb.utils.utility.Location('avdecc.xsd', 1377, 20)))

T0015._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octet, scope=T0015, location=pyxb.utils.utility.Location('avdecc.xsd', 1378, 20)))

T0015._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_values'), CurrentSignedOctets, scope=T0015, location=pyxb.utils.utility.Location('avdecc.xsd', 1379, 20)))

def _BuildAutomaton_148 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_148
    del _BuildAutomaton_148
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1379, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0015._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1374, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0015._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1375, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0015._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1376, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0015._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1377, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0015._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1378, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T0015._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_values')), pyxb.utils.utility.Location('avdecc.xsd', 1379, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0015._Automaton = _BuildAutomaton_148()




T0016._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0016, location=pyxb.utils.utility.Location('avdecc.xsd', 1393, 20)))

T0016._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Octet, scope=T0016, location=pyxb.utils.utility.Location('avdecc.xsd', 1394, 20)))

T0016._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Octet, scope=T0016, location=pyxb.utils.utility.Location('avdecc.xsd', 1395, 20)))

T0016._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Octet, scope=T0016, location=pyxb.utils.utility.Location('avdecc.xsd', 1396, 20)))

T0016._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octet, scope=T0016, location=pyxb.utils.utility.Location('avdecc.xsd', 1397, 20)))

T0016._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_values'), CurrentUnsignedOctets, scope=T0016, location=pyxb.utils.utility.Location('avdecc.xsd', 1398, 20)))

def _BuildAutomaton_149 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_149
    del _BuildAutomaton_149
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1398, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0016._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1393, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0016._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1394, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0016._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1395, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0016._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1396, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0016._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1397, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T0016._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_values')), pyxb.utils.utility.Location('avdecc.xsd', 1398, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0016._Automaton = _BuildAutomaton_149()




T0017._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0017, location=pyxb.utils.utility.Location('avdecc.xsd', 1411, 20)))

T0017._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Doublet, scope=T0017, location=pyxb.utils.utility.Location('avdecc.xsd', 1412, 20)))

T0017._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Doublet, scope=T0017, location=pyxb.utils.utility.Location('avdecc.xsd', 1413, 20)))

T0017._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Doublet, scope=T0017, location=pyxb.utils.utility.Location('avdecc.xsd', 1414, 20)))

T0017._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Doublet, scope=T0017, location=pyxb.utils.utility.Location('avdecc.xsd', 1415, 20)))

T0017._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_values'), CurrentSignedDoublets, scope=T0017, location=pyxb.utils.utility.Location('avdecc.xsd', 1416, 20)))

def _BuildAutomaton_150 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_150
    del _BuildAutomaton_150
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1416, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0017._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1411, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0017._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1412, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0017._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1413, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0017._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1414, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0017._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1415, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T0017._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_values')), pyxb.utils.utility.Location('avdecc.xsd', 1416, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0017._Automaton = _BuildAutomaton_150()




T0018._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0018, location=pyxb.utils.utility.Location('avdecc.xsd', 1429, 20)))

T0018._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Doublet, scope=T0018, location=pyxb.utils.utility.Location('avdecc.xsd', 1430, 20)))

T0018._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Doublet, scope=T0018, location=pyxb.utils.utility.Location('avdecc.xsd', 1431, 20)))

T0018._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Doublet, scope=T0018, location=pyxb.utils.utility.Location('avdecc.xsd', 1432, 20)))

T0018._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Doublet, scope=T0018, location=pyxb.utils.utility.Location('avdecc.xsd', 1433, 20)))

T0018._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_values'), CurrentUnsignedDoublets, scope=T0018, location=pyxb.utils.utility.Location('avdecc.xsd', 1434, 20)))

def _BuildAutomaton_151 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_151
    del _BuildAutomaton_151
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1434, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0018._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1429, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0018._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1430, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0018._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1431, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0018._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1432, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0018._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1433, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T0018._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_values')), pyxb.utils.utility.Location('avdecc.xsd', 1434, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0018._Automaton = _BuildAutomaton_151()




T0019._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T0019, location=pyxb.utils.utility.Location('avdecc.xsd', 1447, 20)))

T0019._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Quadlet, scope=T0019, location=pyxb.utils.utility.Location('avdecc.xsd', 1448, 20)))

T0019._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Quadlet, scope=T0019, location=pyxb.utils.utility.Location('avdecc.xsd', 1449, 20)))

T0019._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Quadlet, scope=T0019, location=pyxb.utils.utility.Location('avdecc.xsd', 1450, 20)))

T0019._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Quadlet, scope=T0019, location=pyxb.utils.utility.Location('avdecc.xsd', 1451, 20)))

T0019._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_values'), CurrentSignedQuadlets, scope=T0019, location=pyxb.utils.utility.Location('avdecc.xsd', 1452, 20)))

def _BuildAutomaton_152 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_152
    del _BuildAutomaton_152
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1452, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0019._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1447, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0019._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1448, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0019._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1449, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0019._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1450, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0019._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1451, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T0019._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_values')), pyxb.utils.utility.Location('avdecc.xsd', 1452, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0019._Automaton = _BuildAutomaton_152()




T001a._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T001a, location=pyxb.utils.utility.Location('avdecc.xsd', 1465, 20)))

T001a._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Quadlet, scope=T001a, location=pyxb.utils.utility.Location('avdecc.xsd', 1466, 20)))

T001a._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Quadlet, scope=T001a, location=pyxb.utils.utility.Location('avdecc.xsd', 1467, 20)))

T001a._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Quadlet, scope=T001a, location=pyxb.utils.utility.Location('avdecc.xsd', 1468, 20)))

T001a._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Quadlet, scope=T001a, location=pyxb.utils.utility.Location('avdecc.xsd', 1469, 20)))

T001a._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_values'), CurrentUnsignedQuadlets, scope=T001a, location=pyxb.utils.utility.Location('avdecc.xsd', 1470, 20)))

def _BuildAutomaton_153 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_153
    del _BuildAutomaton_153
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1470, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001a._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1465, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001a._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1466, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001a._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1467, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001a._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1468, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T001a._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1469, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T001a._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_values')), pyxb.utils.utility.Location('avdecc.xsd', 1470, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T001a._Automaton = _BuildAutomaton_153()




T001b._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T001b, location=pyxb.utils.utility.Location('avdecc.xsd', 1483, 20)))

T001b._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Octlet, scope=T001b, location=pyxb.utils.utility.Location('avdecc.xsd', 1484, 20)))

T001b._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Octlet, scope=T001b, location=pyxb.utils.utility.Location('avdecc.xsd', 1485, 20)))

T001b._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Octlet, scope=T001b, location=pyxb.utils.utility.Location('avdecc.xsd', 1486, 20)))

T001b._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octlet, scope=T001b, location=pyxb.utils.utility.Location('avdecc.xsd', 1487, 20)))

T001b._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_values'), CurrentSignedOctlets, scope=T001b, location=pyxb.utils.utility.Location('avdecc.xsd', 1488, 20)))

def _BuildAutomaton_154 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_154
    del _BuildAutomaton_154
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1488, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001b._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1483, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001b._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1484, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001b._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1485, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001b._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1486, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T001b._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1487, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T001b._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_values')), pyxb.utils.utility.Location('avdecc.xsd', 1488, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T001b._Automaton = _BuildAutomaton_154()




T001c._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T001c, location=pyxb.utils.utility.Location('avdecc.xsd', 1501, 20)))

T001c._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Octlet, scope=T001c, location=pyxb.utils.utility.Location('avdecc.xsd', 1502, 20)))

T001c._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Octlet, scope=T001c, location=pyxb.utils.utility.Location('avdecc.xsd', 1503, 20)))

T001c._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Octlet, scope=T001c, location=pyxb.utils.utility.Location('avdecc.xsd', 1504, 20)))

T001c._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Octlet, scope=T001c, location=pyxb.utils.utility.Location('avdecc.xsd', 1505, 20)))

T001c._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_values'), CurrentUnsignedOctlets, scope=T001c, location=pyxb.utils.utility.Location('avdecc.xsd', 1506, 20)))

def _BuildAutomaton_155 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_155
    del _BuildAutomaton_155
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1506, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001c._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1501, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001c._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1502, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001c._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1503, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001c._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1504, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T001c._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1505, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T001c._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_values')), pyxb.utils.utility.Location('avdecc.xsd', 1506, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T001c._Automaton = _BuildAutomaton_155()




T001d._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T001d, location=pyxb.utils.utility.Location('avdecc.xsd', 1519, 20)))

T001d._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Float, scope=T001d, location=pyxb.utils.utility.Location('avdecc.xsd', 1520, 20)))

T001d._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Float, scope=T001d, location=pyxb.utils.utility.Location('avdecc.xsd', 1521, 20)))

T001d._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Float, scope=T001d, location=pyxb.utils.utility.Location('avdecc.xsd', 1522, 20)))

T001d._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Float, scope=T001d, location=pyxb.utils.utility.Location('avdecc.xsd', 1523, 20)))

T001d._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_values'), CurrentFloats, scope=T001d, location=pyxb.utils.utility.Location('avdecc.xsd', 1524, 20)))

def _BuildAutomaton_156 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_156
    del _BuildAutomaton_156
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1524, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001d._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1519, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001d._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1520, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001d._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1521, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001d._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1522, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T001d._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1523, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T001d._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_values')), pyxb.utils.utility.Location('avdecc.xsd', 1524, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T001d._Automaton = _BuildAutomaton_156()




T001e._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'units'), Units, scope=T001e, location=pyxb.utils.utility.Location('avdecc.xsd', 1537, 20)))

T001e._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), Double, scope=T001e, location=pyxb.utils.utility.Location('avdecc.xsd', 1538, 20)))

T001e._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), Double, scope=T001e, location=pyxb.utils.utility.Location('avdecc.xsd', 1539, 20)))

T001e._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), Double, scope=T001e, location=pyxb.utils.utility.Location('avdecc.xsd', 1540, 20)))

T001e._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), Double, scope=T001e, location=pyxb.utils.utility.Location('avdecc.xsd', 1541, 20)))

T001e._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_values'), CurrentDoubles, scope=T001e, location=pyxb.utils.utility.Location('avdecc.xsd', 1542, 20)))

def _BuildAutomaton_157 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_157
    del _BuildAutomaton_157
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1542, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001e._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'units')), pyxb.utils.utility.Location('avdecc.xsd', 1537, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001e._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1538, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001e._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1539, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T001e._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1540, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T001e._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1541, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T001e._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_values')), pyxb.utils.utility.Location('avdecc.xsd', 1542, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T001e._Automaton = _BuildAutomaton_157()




T001f._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current'), ControlValueString, scope=T001f, location=pyxb.utils.utility.Location('avdecc.xsd', 1555, 20)))

def _BuildAutomaton_158 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_158
    del _BuildAutomaton_158
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1555, 20))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T001f._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current')), pyxb.utils.utility.Location('avdecc.xsd', 1555, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
T001f._Automaton = _BuildAutomaton_158()




T0020._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minimum'), BodePlotPoint, scope=T0020, location=pyxb.utils.utility.Location('avdecc.xsd', 1568, 20)))

T0020._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'maximum'), BodePlotPoint, scope=T0020, location=pyxb.utils.utility.Location('avdecc.xsd', 1569, 20)))

T0020._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'step'), BodePlotPoint, scope=T0020, location=pyxb.utils.utility.Location('avdecc.xsd', 1570, 20)))

T0020._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'default'), BodePlotPoint, scope=T0020, location=pyxb.utils.utility.Location('avdecc.xsd', 1571, 20)))

T0020._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'current_values'), BodePlotList, scope=T0020, location=pyxb.utils.utility.Location('avdecc.xsd', 1572, 20)))

def _BuildAutomaton_159 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_159
    del _BuildAutomaton_159
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0L, max=1, metadata=pyxb.utils.utility.Location('avdecc.xsd', 1572, 20))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0020._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minimum')), pyxb.utils.utility.Location('avdecc.xsd', 1568, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0020._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'maximum')), pyxb.utils.utility.Location('avdecc.xsd', 1569, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0020._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'step')), pyxb.utils.utility.Location('avdecc.xsd', 1570, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0020._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'default')), pyxb.utils.utility.Location('avdecc.xsd', 1571, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(T0020._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'current_values')), pyxb.utils.utility.Location('avdecc.xsd', 1572, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0020._Automaton = _BuildAutomaton_159()




T0021._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'hours'), Doublet, scope=T0021, location=pyxb.utils.utility.Location('avdecc.xsd', 1585, 20)))

T0021._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'minutes'), Octet, scope=T0021, location=pyxb.utils.utility.Location('avdecc.xsd', 1586, 20)))

T0021._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'seconds'), Octet, scope=T0021, location=pyxb.utils.utility.Location('avdecc.xsd', 1587, 20)))

T0021._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'frames'), Octet, scope=T0021, location=pyxb.utils.utility.Location('avdecc.xsd', 1588, 20)))

T0021._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'subframes'), Doublet, scope=T0021, location=pyxb.utils.utility.Location('avdecc.xsd', 1589, 20)))

T0021._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'frames_per_second'), Octet, scope=T0021, location=pyxb.utils.utility.Location('avdecc.xsd', 1590, 20)))

T0021._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'drop_frame'), Octet, scope=T0021, location=pyxb.utils.utility.Location('avdecc.xsd', 1591, 20)))

T0021._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pull'), Octet, scope=T0021, location=pyxb.utils.utility.Location('avdecc.xsd', 1592, 20)))

def _BuildAutomaton_160 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_160
    del _BuildAutomaton_160
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0021._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'hours')), pyxb.utils.utility.Location('avdecc.xsd', 1585, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0021._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'minutes')), pyxb.utils.utility.Location('avdecc.xsd', 1586, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0021._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'seconds')), pyxb.utils.utility.Location('avdecc.xsd', 1587, 20))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0021._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'frames')), pyxb.utils.utility.Location('avdecc.xsd', 1588, 20))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0021._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'subframes')), pyxb.utils.utility.Location('avdecc.xsd', 1589, 20))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0021._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'frames_per_second')), pyxb.utils.utility.Location('avdecc.xsd', 1590, 20))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0021._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'drop_frame')), pyxb.utils.utility.Location('avdecc.xsd', 1591, 20))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0021._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pull')), pyxb.utils.utility.Location('avdecc.xsd', 1592, 20))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0021._Automaton = _BuildAutomaton_160()




T0022._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'pull'), Octet, scope=T0022, location=pyxb.utils.utility.Location('avdecc.xsd', 1605, 20)))

T0022._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'base_frequency'), Quadlet, scope=T0022, location=pyxb.utils.utility.Location('avdecc.xsd', 1606, 20)))

def _BuildAutomaton_161 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_161
    del _BuildAutomaton_161
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0022._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'pull')), pyxb.utils.utility.Location('avdecc.xsd', 1605, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0022._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'base_frequency')), pyxb.utils.utility.Location('avdecc.xsd', 1606, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0022._Automaton = _BuildAutomaton_161()




T0023._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'gptp_seconds'), GPTPSeconds, scope=T0023, location=pyxb.utils.utility.Location('avdecc.xsd', 1619, 20)))

T0023._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'gptp_nanoseconds'), GPTPNanoseconds, scope=T0023, location=pyxb.utils.utility.Location('avdecc.xsd', 1620, 20)))

def _BuildAutomaton_162 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_162
    del _BuildAutomaton_162
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T0023._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'gptp_seconds')), pyxb.utils.utility.Location('avdecc.xsd', 1619, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T0023._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'gptp_nanoseconds')), pyxb.utils.utility.Location('avdecc.xsd', 1620, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T0023._Automaton = _BuildAutomaton_162()




T3ffe._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'vendor_eui64'), EUI64, scope=T3ffe, location=pyxb.utils.utility.Location('avdecc.xsd', 1633, 20)))

T3ffe._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'binary_blob'), HexBlobData, scope=T3ffe, location=pyxb.utils.utility.Location('avdecc.xsd', 1634, 20)))

def _BuildAutomaton_163 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_163
    del _BuildAutomaton_163
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(T3ffe._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'vendor_eui64')), pyxb.utils.utility.Location('avdecc.xsd', 1633, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(T3ffe._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'binary_blob')), pyxb.utils.utility.Location('avdecc.xsd', 1634, 20))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
T3ffe._Automaton = _BuildAutomaton_163()




TUNKNOWN._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, u'binary_blob'), HexBlobData, scope=TUNKNOWN, location=pyxb.utils.utility.Location('avdecc.xsd', 1647, 20)))

def _BuildAutomaton_164 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_164
    del _BuildAutomaton_164
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(TUNKNOWN._UseForTag(pyxb.namespace.ExpandedName(Namespace, u'binary_blob')), pyxb.utils.utility.Location('avdecc.xsd', 1647, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
TUNKNOWN._Automaton = _BuildAutomaton_164()

